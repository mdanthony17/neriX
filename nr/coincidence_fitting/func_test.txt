		nndomTrials = int(1e4)
		seed(int(time.time()))
		root.gRandom.SetSeed(0)
		aS1 = np.full(numRandomTrials, -1)
		aS2 = np.full(numRandomTrials, -1)
		
		#startTime = time.time()
	
		for i in xrange(numRandomTrials):
		
			passedWithoutError = True
		
			# ------------------------------------------------
			# Get random energy value according to distribution
			# ------------------------------------------------
		
			# the finer binning the better in MC
			mcEnergy = self.hMC.GetRandom()
			if mcEnergy <= 0:
				continue
		
			#print 'Energy: %.3f' % mcEnergy
		
			# ------------------------------------------------
			# Transform to number of quanta via W-value
			# ------------------------------------------------

			wValue = 13.7e-3
			passedWithoutError, mcQuantaBeforeLindhard = safe_poisson(mcEnergy/wValue)
			if not passedWithoutError:
				continue
			
			#print 'Quanta before Lindhard: %.3f' % mcQuantaBeforeLindhard
			
			
			# ------------------------------------------------
			# Apply Lindhard spectrum to quanta
			# ------------------------------------------------
			
			
			passedWithoutError, mcQuanta = safe_binomial(mcQuantaBeforeLindhard, lindhardFactor)
			if not passedWithoutError:
				continue
			
			#print 'Quanta: %.3f' % mcQuanta


			# ------------------------------------------------
			# Convert quanta to excitons and ions
			# ------------------------------------------------

			probExcitonSuccess = 1. - 1./(1. + excitonToIonRatio)
			#print 'Exciton to ion ratio: %.3f' % excitonToIonRatio
			passedWithoutError, mcExcitons = safe_binomial(mcQuanta, probExcitonSuccess)
			if not passedWithoutError:
				continue
			mcIons = mcQuanta - mcExcitons
			
			#print 'Excitons before recombination: %.3f' % mcExcitons
			#print 'Ions before recombination: %.3f' % mcIons
			
			# ------------------------------------------------
			# Ions recombine to form excitons
			# ------------------------------------------------


			passedWithoutError, mcRecombined = safe_binomial(mcIons, recombinationProb)
			if not passedWithoutError:
				continue
			mcExcitons += mcRecombined
			mcIons -= mcRecombined
			
			#print 'Excitons: %.3f' % mcExcitons
			#print 'Ions: %.3f' % mcIons


			# ------------------------------------------------
			# Quenching and conversion to photons+electrons
			# ------------------------------------------------


			passedWithoutError, mcQuenched = safe_binomial(mcExcitons, 1-photonQuenching)
			if not passedWithoutError:
				continue
			mcPhotons = mcExcitons - mcQuenched
			mcElectrons = mcIons
			
			#print 'Photon Yield: %.3f' % (mcPhotons / mcEnergy)
			#print 'Charge Yield: %.3f' % (mcElectrons / mcEnergy)
			
			
			# ------------------------------------------------
			# Convert to photoelectrons
			# ------------------------------------------------
			
			
			passedWithoutError, mcS1Ideal = safe_binomial(mcPhotons, g1Value)
			if not passedWithoutError:
				continue
			passedWithoutError, mcExtractedElectrons = safe_binomial(mcElectrons, extractionEfficiency)
			if not passedWithoutError:
				continue
			passedWithoutError, mcS2Ideal = safe_normal(mcExtractedElectrons*gasGainValue, gasGainWidth * mcExtractedElectrons**0.5)
			if not passedWithoutError:
				continue
				
			#try:
			#	print 'Estimated g1: %.3f' % (float(mcS1Ideal) / mcPhotons)
			#	print 'Estimated g2: %.3f' % (mcS2Ideal / mcElectrons)
			#except:
			#	pass
				
			if mcS1Ideal < 0:
				mcS1Ideal = 0.
			if mcS2Ideal < 0:
				mcS2Ideal = 0.
			
		
			# ------------------------------------------------
			# Apply SPE Smearing
			# ------------------------------------------------


			passedWithoutError, mcS1SPESmeared = safe_normal(mcS1Ideal, speRes*mcS1Ideal**0.5)
			if not passedWithoutError:
				continue
			passedWithoutError, mcS2SPESmeared = safe_normal(mcS2Ideal, speRes*mcS2Ideal**0.5)
			if not passedWithoutError:
				continue
				
			if mcS1SPESmeared < 0:
				mcS1SPESmeared = 0.
			if mcS2SPESmeared < 0:
				mcS2SPESmeared = 0.
			
			
			
			# ------------------------------------------------
			# Apply intrinsic smearing
			# ------------------------------------------------


			passedWithoutError, mcS1Final = safe_normal(mcS1SPESmeared, intrinsicResolutionS1*mcS1SPESmeared**0.5)
			if not passedWithoutError:
				continue
			passedWithoutError, mcS2Final = safe_normal(mcS2SPESmeared, intrinsicResolutionS2*mcS2SPESmeared**0.5)
			if not passedWithoutError:
				continue

			#print 'S1 final: %.2f' % mcS1Final
			#print 'S2 final: %.2f' % mcS2Final

			aS1[i] = mcS1Final
			aS2[i] = mcS2Final
			
		#print 'Time per loop: %f' % ((time.time() - startTime) / numRandomTrials)
		
		
		# ------------------------------------------------
		# create 2D histogram of S1s and S2s
		# ------------------------------------------------
		
		
		aS1S2MC, xEdges, yEdges = np.histogram2d(aS1, aS2, bins=[aS1BinEdges, aS2BinEdges])
		print xEdges, yEdges
		
		

		# ------------------------------------------------
		# apply efficiencies
		# ------------------------------------------------

		# element wise multiplication to combine S1 or S2
		# need to use outer with multiply to make large matrix
		
		aS1Efficiency = egTacEff.get_y_values().flatten()*egPFEff.get_y_values().flatten()
		aS2Efficiency = egTrigEff.get_y_values()
		
		print egTacEff.get_x_values()
		print egPFEff.get_x_values()
		
		aFullEfficiencyMatrix = np.outer(aS1Efficiency, aS2Efficiency)
		
		#print aS1S2.shape, aFullEfficiencyMatrix.shape
		assert aS1S2MC.shape == aFullEfficiencyMatrix.shape
		
		try:
			#aS1S2MC = np.multiply(aS1S2MC, aFullEfficiencyMatrix)
			aS1S2MC = binomial(aS1S2MC.astype('int64', copy=False), aFullEfficiencyMatrix)
			aS1S2MC = np.multiply(aS1S2MC, np.sum(self.aS1S2) / np.sum(aS1S2MC))
		except:
			return -np.inf, aS1S2MCumRandomTrials = int(1e4)
		seed(int(time.time()))
		root.gRandom.SetSeed(0)
		aS1 = np.full(numRandomTrials, -1)
		aS2 = np.full(numRandomTrials, -1)
		
		#startTime = time.time()
	
		for i in xrange(numRandomTrials):
		
			passedWithoutError = True
		
			# ------------------------------------------------
			# Get random energy value according to distribution
			# ------------------------------------------------
		
			# the finer binning the better in MC
			mcEnergy = self.hMC.GetRandom()
			if mcEnergy <= 0:
				continue
		
			#print 'Energy: %.3f' % mcEnergy
		
			# ------------------------------------------------
			# Transform to number of quanta via W-value
			# ------------------------------------------------

			wValue = 13.7e-3
			passedWithoutError, mcQuantaBeforeLindhard = safe_poisson(mcEnergy/wValue)
			if not passedWithoutError:
				continue
			
			#print 'Quanta before Lindhard: %.3f' % mcQuantaBeforeLindhard
			
			
			# ------------------------------------------------
			# Apply Lindhard spectrum to quanta
			# ------------------------------------------------
			
			
			passedWithoutError, mcQuanta = safe_binomial(mcQuantaBeforeLindhard, lindhardFactor)
			if not passedWithoutError:
				continue
			
			#print 'Quanta: %.3f' % mcQuanta


			# ------------------------------------------------
			# Convert quanta to excitons and ions
			# ------------------------------------------------

			probExcitonSuccess = 1. - 1./(1. + excitonToIonRatio)
			#print 'Exciton to ion ratio: %.3f' % excitonToIonRatio
			passedWithoutError, mcExcitons = safe_binomial(mcQuanta, probExcitonSuccess)
			if not passedWithoutError:
				continue
			mcIons = mcQuanta - mcExcitons
			
			#print 'Excitons before recombination: %.3f' % mcExcitons
			#print 'Ions before recombination: %.3f' % mcIons
			
			# ------------------------------------------------
			# Ions recombine to form excitons
			# ------------------------------------------------


			passedWithoutError, mcRecombined = safe_binomial(mcIons, recombinationProb)
			if not passedWithoutError:
				continue
			mcExcitons += mcRecombined
			mcIons -= mcRecombined
			
			#print 'Excitons: %.3f' % mcExcitons
			#print 'Ions: %.3f' % mcIons


			# ------------------------------------------------
			# Quenching and conversion to photons+electrons
			# ------------------------------------------------


			passedWithoutError, mcQuenched = safe_binomial(mcExcitons, 1-photonQuenching)
			if not passedWithoutError:
				continue
			mcPhotons = mcExcitons - mcQuenched
			mcElectrons = mcIons
			
			#print 'Photon Yield: %.3f' % (mcPhotons / mcEnergy)
			#print 'Charge Yield: %.3f' % (mcElectrons / mcEnergy)
			
			
			# ------------------------------------------------
			# Convert to photoelectrons
			# ------------------------------------------------
			
			
			passedWithoutError, mcS1Ideal = safe_binomial(mcPhotons, g1Value)
			if not passedWithoutError:
				continue
			passedWithoutError, mcExtractedElectrons = safe_binomial(mcElectrons, extractionEfficiency)
			if not passedWithoutError:
				continue
			passedWithoutError, mcS2Ideal = safe_normal(mcExtractedElectrons*gasGainValue, gasGainWidth * mcExtractedElectrons**0.5)
			if not passedWithoutError:
				continue
				
			#try:
			#	print 'Estimated g1: %.3f' % (float(mcS1Ideal) / mcPhotons)
			#	print 'Estimated g2: %.3f' % (mcS2Ideal / mcElectrons)
			#except:
			#	pass
				
			if mcS1Ideal < 0:
				mcS1Ideal = 0.
			if mcS2Ideal < 0:
				mcS2Ideal = 0.
			
		
			# ------------------------------------------------
			# Apply SPE Smearing
			# ------------------------------------------------


			passedWithoutError, mcS1SPESmeared = safe_normal(mcS1Ideal, speRes*mcS1Ideal**0.5)
			if not passedWithoutError:
				continue
			passedWithoutError, mcS2SPESmeared = safe_normal(mcS2Ideal, speRes*mcS2Ideal**0.5)
			if not passedWithoutError:
				continue
				
			if mcS1SPESmeared < 0:
				mcS1SPESmeared = 0.
			if mcS2SPESmeared < 0:
				mcS2SPESmeared = 0.
			
			
			
			# ------------------------------------------------
			# Apply intrinsic smearing
			# ------------------------------------------------


			passedWithoutError, mcS1Final = safe_normal(mcS1SPESmeared, intrinsicResolutionS1*mcS1SPESmeared**0.5)
			if not passedWithoutError:
				continue
			passedWithoutError, mcS2Final = safe_normal(mcS2SPESmeared, intrinsicResolutionS2*mcS2SPESmeared**0.5)
			if not passedWithoutError:
				continue

			#print 'S1 final: %.2f' % mcS1Final
			#print 'S2 final: %.2f' % mcS2Final

			aS1[i] = mcS1Final
			aS2[i] = mcS2Final

<!-- chapter frameworks -->
<chapter>
    <title>CCUSB Readout framework</title>
    <para>
        The CCUSB Readout framework provides support for the Wiener-JTec
        CC-USB CAMAC controller.  The CC-USB is a USB CAMAC controller that
        uses a Xilinx gate array to implement a CAMAC list processor.
        The CCUSB Readout framework provides:
    </para>
    <itemizedlist>
        <listitem><para>
            A high level approach to the problem of data taking with the CC-USB
        </para></listitem>
        <listitem><para>
            Support for user written device support without any need to
            understand the format of list operations supported by the CC-USB.
            Drivers can be written in either C++ or in object oriented extensions
            to Tcl.
        </para></listitem>
        <listitem>
            <para>
                Direct insertion of data taken to an arbitrary destination
                ringbuffer.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        This Chapter provides overview information that describes
    </para>
    <itemizedlist>
        <listitem>
            <para>
                The philosophy behind the CCUSB readout framework.
            </para>
        </listitem>
        <listitem>
            <para>
                How to write configuration files for the CCUSB readout
                framework.
            </para>
        </listitem>
        <listitem>
            <para>
                How to write device support modules in in C++ and incorpoprate
                those modules into the
                CCUSB readout framework 
            </para>
        </listitem>
        <listitem>
            <para>
                How to write device support moduels in Tcl and incorporate
                those modules in the CCUSB readout framework.
            </para>
        </listitem>
        <listitem>
            <para>
                How the slow controls framework operates.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        Reference information is available in the <literal>3ccusb</literal>
        section of the referencae material.
    </para>
    <section>
        <title>How the CCUSB readout framework works</title>
        <para>
            The CCUSB readout framework provides a high level approach to
            configuring devices supported by the system.  A plugin architecture
            allows user written device support to be incorporated into
            the framework at run-time.  
        </para>
        <para>
            The framework supports both data taking devices and slow control
            devices that may require a control panel.  Naturally you can
            support relatively static slow control devices by using the
            data taking device support as well.
        </para>
        <para>
            The recurring concepts for both the data taking device support
            and slow controls device support are:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    A Tcl configuration file describes the devices used
                    by the experiment.
                </para>
            </listitem>
            <listitem>
                <para>
                    Each supported device class is represented in the
                    configuration file by a Tcl command ensemble. The
                    command ensemble provides subcommands that allow you to
                    create, configure and query the configuration of
                    physical devices (device instances).
                </para>
            </listitem>
            <listitem>
                <para>
                    The device configuration is represented in the configuration
                    file in manner analagous to the state of a Tk widget.
                    That is, you never actually program the device directly,
                    you simply specify the desired configuration. The actual
                    programming is done by the device class's device support
                    software.
                </para>
            </listitem>
            <listitem>
                <para>
                    In accordance with the way the CC-USB operates, you can create
                    two lists or <firstterm>stack</firstterm>s in CC-USB parlance.
                    One stack is an event stack and is intended to be used
                    to handle event triggers.  The second stack is a scaler stack
                    and typically is set to readout periodically.
                </para>
                <para>
                    Each stack has, configuration properties as well. One
                    configuration property is the set of modules managed
                    by that stack.  Modules managed by that stack are initialized
                    by the software, in accordance with their configuration,
                    and contribute to the readout list that executes in response
                    to that stack's trigger.
                </para>
            </listitem>
        </itemizedlist>

    </section>
    <section>
        <title>Writing DAQ configuration files</title>
        <para>
            The DAQ configuration file is processed at the beginning of each run.
            The configuration file is processed in a fresh interpreter each time.
            You therefore cannot maintain any state across runs via your configuration
            file.
        </para>
        <para>
            To illustrate module creation and configuration,
            this let's look at a fragment from a configuration
            file:
        </para>
        <example>
            <title>Creating and configuring devices</title>
            <programlisting>
ph7xxx create tdc -slot 13 -id 0x7186 -sparse false
ph7xxx config tdc -readhits true -usellt false -usehlt false
            </programlisting>
        </example>
        <para>
            The ph7xxx driver supports the Phillips 7xxx series
            CAMAC 16 channel digitizers.  The <command>ph7xxx</command> command is the Tcl
            command this driver recognizes.  The <command>create</command>
            subcommand creates a new device instance and names it <literal>tdc</literal>.
            When you create a module any addition command words following the
            device name are interpreted as configuration options.
            In this case, the module is configured to be in slot 13,
            the driver is configured to emit a literal value (<option>-id</option>)
            <literal>0x7186</literal> prior to data from the device.
            The module is also configured to read all channels
            (<option>-sparse</option> <literal>false</literal>).
        </para>
        <para>
            The <command>config</command> subcommand allows you to further
            configure the options of a device instance.  The second line
            of the example continues specifying the configuration of the
            device named <literal>tdc</literal>.  The configuration parameters
            on that line request the driver to read the hit pattern register
            (<option>-readhits</option> <literal>true</literal>), to not
            enable  either the lower level threshold or the upler level threshold
            (<option>-usellt</option> and <option>usehlt</option>).
        </para>
        <para>
            The reference section <literal>3ccusb</literal> provides detailed
            information that describes each supported device and the
            configuration options it supports.
        </para>
        <para>
            Configuration files must also specify at least one stack and, if
            scaler modules are to be read periodically, a second scaler stack.
            See the <xref linkend="ccusb3-stack" /> command
            in the reference material for detailed information about how
            to create and configure stacks.
        </para>
        <para>
            To continue with the previous example:
        </para>
        <example>
            <title>Configuring an event stack</title>
            <programlisting>
stack create events
stack config events -modules [list tdc] -type event -delay 108
            </programlisting>
        </example>
        <para>
            Stacks are created and configured exactly like any other module.
            In this configuration file fragment, a stack named
            <literal>events</literal> is created.  It is configured to
            manage the <literal>tdc</literal> module (<option>-modules</option>).
            It is configured as the event stack (<option>-type</option>) which,
            by default is triggered by a nim pulse in the <literal>IN1</literal>
            input of the module. The <option>-delay </option> parameter
            specifies a delay of 108usec between the trigger input and stack
            execution.  This capability is provided to allow the digitizers
            in the stack time to convert.
        </para>
        <para>
            Finally here's a configuration file fragment that sets up an
            LRS 2551 scaler and the scaler stack:
        </para>
        <example>
            <title>Setting up a scaler stack</title>
            <programlisting>

lrs2551 create counters -slot 5
stack create scaler
stack config scaler -type scaler -period 2 -modules [list counters]

            </programlisting>
        </example>
    </section>
    <section>
        <title>Writing device support software</title>
        <para>
            This section describes how to write a device support module.
            Device support modules are built into shared object libraries
            that can be dynamically loaded into the readout software via
            the <command>load</command> command.
        </para>
        <para>
            The device support package is provided as a template driver
            source file and a Makefile that builds the shared object.
            If the DAQ software is installed in $DAQROOT, the following
            commands copy the template driver and its makefile:
        </para>
        <example>
            <title>Obtaining the ccusb driver development kit</title>
            <programlisting>
<command>cp $DAQROOT/ccusbdriver/drivertemplate.cpp .</command>
<command>cp $DAQROOT/ccusbdriver/Makefile .</command>
            </programlisting>
        </example>
        <para>
            The example below shows how to load a user written driver
            and use the driver that is created by an unmodified driver template:
        </para>
        <example>
            <title>Using a user written CCUSB driver</title>
            <programlisting>
set here [file nativename [file dirname [info script]]]
load [file join $here libtemplatedriver.so]
changeme create testing -value 0x1234
            </programlisting>
        </example>
        <para>
            The example assumes that you have built the driver in the same
            directory as your configuration file.  The first example line
            computes the full file path to the configuration file's directory.
            The second loads the driver, joining that path to the name of the
            shared object created by the Makefile.  Note that you typically will
            need to provide a full path to the driver shared object or the
            <command>load</command> command will claim the file cannot be located.
            The final command creates and configures a device instance
            named <literal>testing</literal> using the <command>changeme</command>
            command the unmodified driver creates.
        </para>
        <para>
            Let's look at the template driver you copied.
            The template consists of two main chunks.  The first chunk is a
            class derived from <classname>CReadoutHardware</classname> that is
            responsible for managing the driver itself. You will normally
            need to modify the <methodname>onAttach</methodname>,
            <methodname>Initialize</methodname> and <methodname>addReadoutList</methodname>
            methods of this class, as well as changing the class name to something
            more reasonable than <classname>CTemplateDriver</classname>.
        </para>
        <para>
            The second chunk is a Tcl package initialization function that
            must define the Tcl command that is associated twith the driver.
        </para>
        <para>
            While the driver template is heavily commented, and modification
            points are indicated, the next few sections are a guided tour
            of the main sections you will need to modify.
        </para>
        <section>
            <title>The driver onAttach method</title>
            <para>
                Each driver instance has a configuration database attached to it
                when it is created.  The configuration database holds configuration
                parameter definitions and their current values.  The framework
                takes care of managing the values for you, however you must
                define the set of configuration parameters supported by your
                driver.
            </para>
            <para>
                The template driver's code is (comments removed for brevity:
            </para>
            <informalexample>
                <programlisting>
void
CTemplateDriver::onAttach(CReadoutModule&amp; configuration)
{
  m_pConfiguration = &amp;configuration;                    <co id='ccusb-dtemplate-saveconfig' />
  m_pConfiguration->addIntegerParameter("-slot", 1, 23, 1); <co id='ccusb-dtemplate-slotparam' />

  m_pConfiguration->addIntegerParameter("-value"); // default is 0. <co id='ccusb-dtemplate-valueparam' />
}
                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='ccusb-dtemplate-saveconfig'>
                    <para>
                        <methodname>onAttach</methodname> needs to be able
                        to access its configuration in other methods.
                        The <parameter>configuration</parameter> parameter is
                        a reference to that configuration.  This line
                        saves a pointer to that configuration in the
                        <varname>m_pConfiguration</varname> member variable.
                        Note that a <classname>CReadoutModule</classname>
                        is derived from a <classname>CConfigurableObject</classname>
                        and that base class holds the configuration.
                    </para>
                    <para>
                        This code is provided by the driver template.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-slotparam'>
                    <para>
                        Virtually all of the device support you write will
                        need to know which slot in the CAMAC crate contains
                        your module.  This line creates an integer
                        parameter constrained to lie in the range
                        <literal>[1..23]</literal> named <literal>-slot</literal>.
                        The default value (if the user does not configure
                        this item) is <literal>1</literal> (the last parameter
                        of the <methodname>addIntegerParameter</methodname> call).
                    </para>
                    <para>
                        This code is provided by the driver template.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-valueparam'>
                    <para>
                        This sample line shows how to create an unconstrained
                        integer parameter named <literal>-value</literal>.
                        The configuration subsystem will ensure the value
                        is a valid integer but will not contrain the range
                        of that integer.
                    </para>
                    <para>
                        This line is provided by the template driver but normally
                        is removed as you edit the code to define the
                        configuration options you actually need.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Normally the <methodname>onAttach</methodname> method is simply
                defining the set of configuration parameters it needs to know
                how to initialize and read the device it manages.  Configuration
                parameters are named items (by convention the names start with the
                dash character) and are strongly typed. Integer, real, string,
                enumerated, and boolean simple parameters are supported.  In
                addtion collection (Tcl lists) are supported.
            </para>
            <para>
                Parameter values can have constraints placed on them (the
                range of <option>-slot</option> parameter values e.g.) which
                are checked by the configuration subsystem without any intervention
                by you.  Several pre-defined constraint checkers are available,
                as are convenience functions for defining configuration parameters.
                You can also define custom constraint checkers and register them
                with the configuration subsystem.
            </para>
            <para>
                See <xref linkend='ccusb3-CConfigurableObject' /> for
                detailed information about how to define configuration
                parameters.
            </para>
        </section>
        <section>
            <title>The driver Initialize method</title>
            <para>
                The <methodname>Initialize</methodname> method of each
                device instance that has been put in a stack is called
                after the configuration file is processed prior to loading
                the stack and prior to turning on data taking mode in the
                CC-USB.
            </para>
            <para>
                Typically in <methodname>Initialize</methodname> you must:
                <orderedlist>
                    <listitem>
                        <para>
                            Fetch the configuration parameters you need
                            to know how to initialize the device and prepare
                            it for data taking.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Issue method calls to the <parameter>controller</parameter>
                            <classname>CCCUSB</classname> object passed in to the
                            method.  Note that if your device requires a lot of
                            initialization, you can speed up that process
                            by creating <classname>CCCUSBReadoutList</classname>
                            objects, which are lists of instructions, using
                            its methods to create a list of operatinos and then
                            asking the controller to execute that list.
                        </para>
                    </listitem>
                </orderedlist>
            </para>
            <para>
                For detailed information about the methods supported by
                the <classname>CCCUSB</classname> and <classname>CCCUSBReadoutList</classname>,
                see <xref linkend='ccusb3-CCCUSB' /> and <xref linkend='ccusb3-CCCUSBReadoutList' />
            </para>
            <para>
                The template driver provides the following code (most
                comments removed for brevity).
            </para>
            <informalexample>
                <programlisting>
void
CTemplateDriver::Initialize(CCCUSB&amp; controller)
{

  int slot = m_pConfiguration->getIntegerParameter("-slot"); <co id='ccusb-dtemplate-init1' />

  /* MODIFY ME HERE */
                                                             <co id='ccusb-dtemplate-init2' />
  /* END MODIFICATIONS */

}


                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='ccusb-dtemplate-init1'>
                    <para>
                        In most cases you need the slot number of the module
                        to initialize it.  This call obtains the value of the
                        <option>-slot</option> configuration parameter
                        from the configuration database for this module.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-init2'>
                    <para>
                        You would add code here to fetch parameter values
                        as well as method calls for the <parameter>controller</parameter>
                        object to manipulate the CAMAC crate.  If initialization
                        requires a large number of CAMAC operations you could
                        also create a <classname>CCCUSBReadoutList</classname>,
                        manipulate it to store a set of operatiuons and then
                        use <parameter>controller.executeList(3ccusb)</parameter> to
                        execute that list.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>The driver addReadoutList method</title>
            <para>
                <methodname>addReadoutList</methodname> is called as a run is
                being intialized.  This method is expected to contribute items
                to the <classname>CCCUSBRedoutList</classname> that will be
                loaded into either a scaler or event stack.  Usuall this is done
                by fetching the set of configuration parameters that are required
                to know how to read the device and then invoking appropriate
                methods on the <parameter>list</parameter> parameter to
                add CAMAC operations to the stack.
            </para>
            <para>
                The template driver implements a marker 'device'. The marker
                device ignores its <option>-slot</option> configuration parameter
                (a production quality marker driver would probably not define
                a <option>-slot</option> parameter).  It adds an instrution
                to the <parameter>list</parameter> that inserts a  literal
                value into the event.  The value inserted is determined by
                the <option>-value</option> parameter.
            </para>
            <para>
                Here's the sample driver code for the <methodname>addReadoutList</methodname>
                method:
            </para>
            <informalexample>
                <programlisting>
void
CTemplateDriver::addReadoutList(CCCUSBReadoutList&amp; list)
{
  int slot = m_pConfiguration->getIntegerParameter("-slot");
  
  /* MODIFY ME HERE */
  
  int value = m_pConfiguration->getIntegerParameter("-value");  <co id='ccusb-dtemplate-read1' />
  list.addMarker(value);        // This is a longword marker.   <co id='ccusb-dtemplate-read2' />

  /* END MODIFICATIONS */
}

                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='ccusb-dtemplate-read1'>
                    <para>
                        This line fetches the <option>-value</option>
                        cofiguration parameter.  This is the value
                        that we are going to insert into the event buffer
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-read2'>
                    <para>
                        The <methodname>addMarker</methodname> method adds
                        the CCUSB instructions to insert a literal value in the
                        output buffer to the list being built up. This
                        therefore instructs the CCUSB that the readout of this
                        'device' consists of inserting the value of the
                        <option>-value</option> configuration parameter.
                    </para>
                    <para>
                        Naturally a real device would add NAF instructions or
                        Q-Stop/C-Scan operations to the list via other
                        <classname>CCCUSBReadoutList</classname> methods.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Initializing the driver with the framework.</title>
            <para>
                The Tcl <command>load</command> command searches the
                shared object for a specific function entry point that
                it will call to initialize the library.  The initialization function
                must follow the correct naming conventions or Tcl will complain
                about not being able to find the library's initialization function.
            </para>
            <para>
                The initialization entry point must be the name of the
                resulting library with the <literal>lib</literal> prefix stripped
                off and the first letter capitalized suffixed by <literal>_Init</literal>.
                Thus if you are building
                <filename>libmydriver.so</filename>, the initialation function
                must be called <function>Mydriver_Init</function>.
            </para>
            <para>
                The template driver provides the following code:
            </para>
            <informalexample>
                <programlisting>
extern "C" {                                    <co id='ccusb-dtemplate-dinit1' />
  int Templatedriver_Init(Tcl_Interp* pInterp)  <co id='ccusb-dtemplate-dinit2' />
  {
    Tcl_PkgProvide(pInterp, "Templatedriver", "1.0"); <co id='ccusb-dtemplate-dinit3' />
 
    CUserCommand::addDriver("changeme", new CTemplateDriver); <co id='ccusb-dtemplate-dinit4' />

    return TCL_OK;                               <co id='ccusb-dtemplate-dinit5' />

  }
}
                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='ccusb-dtemplate-dinit1' >
                    <para>
                        Since C++ <firstterm>decorates</firstterm> function  names
                        with an encoding of the call signature, to support function
                        overloading, you must declare the initialization
                        functino using C linkage conventions.  The
                        <literal>extern "C" {}</literal> creates a block of
                        code whose externally visible symbols will use C
                        linkage conventions.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-dinit2'>
                    <para>
                        In general you will need to modify the name of this
                        to work with the name of the library file you
                        create.  The discussion prior to this example
                        describes the naming conventions that are required.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-dinit3'>
                    <para>
                        In our examples we used the Tcl <command>load</command>
                        command to load the driver.  This statement registers
                        the library as providing a Tcl loadable package.
                        You can use the Tcl command <command>pkg_mkIndex</command>
                        to build an auto load index file for loadable packages
                        including those in shared libraries.  This allows you
                        to collect several drivers into a directory added to the
                        auto load path, and use the <command>package require</command>
                        command to load them by package name.  You must
                        change the name of the package in this call
                        to be something unique and descriptive of your driver.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-dinit4'>
                    <para>
                        The <classname>CUserCommand</classname>::<methodname>addDriver</methodname>
                        function associates a template device driver object
                        with its Tcl command ensemble name.  The template device driver
                        object is cloned for each <command>create</command> subcommand
                        issued for this driver in the configuration script.
                        You should change both the name of the driver command
                        from <literal>changeme</literal> and you should have
                        previously changted the class name of the
                        driver class from <classname>CTemplateDriverM</classname>
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-dinit5'>
                    <para>
                        If the library initialization was successful it
                        should return <literal>TCL_OK</literal> on failure
                        it shouild return <literal>TCL_ERROR</literal>.
                        In this case it is also customary to use
                        e.g. Tcl_SetResult or a similar function to set the
                        result of the load command to a descriptive error
                        message.
                    </para>
                </callout>
            </calloutlist>
        </section>
    </section>
    <section>
        <title>Tcl device driver support</title>
        <para>
            This section describes how to provide support for device drivers
            as Tcl modules.  The first subsection will describe in general
            terms how to do this.  The second and third subsections will show
            sample drivers written in the snit and Incr-Tcl object oriented
            extensions of Tcl along with sample fragments of DAQ configuration
            files that show how to use these drivers. Note that while snit and
            Incr-Tcl drivers are shown any Tcl object oriented extension can
            probably be used as could a carefully crafted set of
            <command>namespace ensemble</command> commands.
        </para>
        <section>
            <title>Conceptual background</title>
            <para>
                If you have not read the section on writing C++ device drivers
                you should at least skim it.  Several of the concepts
                are important.  Specifically:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        A device support module provides a command that
                        generates device instances.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Device instances have to provide an
                        <methodname>Initialize</methodname> method that
                        initializes the device according to some configuration
                        of the instance.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Device instances have to provide a
                        <methodname>addReadoutList</methodname> method that
                        adds elements to the list of CAMAC operations
                        that are executed when the stack they live in
                        is triggered.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                All of this is a natural match to the way all of the object
                oriented extensions to Tcl work.  Specifically you write a
                class like thing.  Creating an instance of the class creates
                a new Tcl command <firstterm>ensemble</firstterm>.  The
                public methods of the instance become sub commands of the
                new Tcl command.  
            </para>
            <para>
                The CCUSB framework therefore provides a
                mechanism, the <command>addtcldriver</command> command to
                add an object instance command to the set of devices that
                can be added to a stack. The <command>addtcldriver</command>
                command registers the command name as a name of a  device
                that can be put in a stack.  The command ensemble is also
                wrapped in an actual driver that invokes
                <methodname>Initialize</methodname>, and
                <methodname>addReadoutList</methodname>
                methods at the appropriate times.
            </para>
            <para>
                The final piece of the puzzle is providing access to the
                CCUSB and CCUSBReadout list capabilities to Tcl drivers.
                This has been done by wrapping Tcl command ensembles around both
                of those classes using SWIG
                (see <ulink url='http://www.swig.org'>http://www.swig.org</ulink>).
            </para>
            <para>
                As we will see when we work our way through sample drivers,
                the C++ wrappers are not able to actually pass a SWIG wrapped
                object to the driver methods.  The driver must take the
                swig pointer like parameter and turn it into a SWIG object
                before it can be used.  A Tcl fragment that shows how to
                turn the CCCUSB pointer into a SWIG CCCUSB object is shown
                below:
            </para>
            <informalexample>
                <programlisting>
...
method Initialize ccusbPointer {
    cccusb::CCCUSB c -this $ccusbPointer
    ...
}
...
                </programlisting>
            </informalexample>
            <para>
                The example takes the <varname>ccusbPointer</varname> parameter
                which must be a swig like pointer to  a CCCUSB object and
                turns it in to a swig object named <literal>c</literal>
                which is a SWIG object representing the underlying CCCUSB
                passed in to the <methodname>Initialize</methodname> method.
            </para>
        </section>
        <section>
            <title>A sample snit Tcl CCUSB framework driver</title>
            <para>
                This section will go through a sample snit driver describing
                how it works.  To see this driver incorporated in a DAQ
                configuration file see
                <xref linkend='ccusb-general-tcldriver-usage' />.
            </para>
            <para>
                First a word or two about snit.  Snit is a pure Tcl object
                oriented framework for Tcl written by Will Duquette from
                the Jet Propulsion Laboratory in Pasadena.
                <ulink url='http://wiki.tcl.tk/3963'>
                    http://wiki.tcl.tk/3963</ulink>
                provides access to documentation and examples of snit in action.
            </para>
            <para>
                snit is part of the <literal>TclLib</literal> which is installed
                on all systems at the NSCL.
            </para>
            <para>
                Snit classes are created via the <command>snit::type</command>
                command.  Snit classes feature <command>method</command>s
                which are analagous to member functions in C++ classes.
            </para>
            <para>
                snit also
                provides all types with a <command>configure</command> and
                <command>cget</command> command and a mechanism for declaring
                options that can be manipulated by these commands. Using this
                capability allows you to configure snit device driver instances
                in a manner analagous to the C++ driver instances supported
                by the CCUSB framework.
            </para>
            <para>
                Below is a complete implementation of a snit driver that,
                at initialization time turns on the yellow LED and adds
                a marker to the readout list.  The marker value can be configured
                via the instances built in configure subcommand.
            </para>
            <example>
                <title>A snit CCUSB device driver module</title>
                <programlisting>
lappend auto_path /usr/opt/daq/10.1/lib  <co id='ccusb-snit-auto_path' />

package require snit                    
package require cccusb                  <co id='ccusb-snit-packages' />
package require cccusbreadoutlist


snit::type marker-snit {                <co id='ccusb-snit-type' />
    option -value 0                     <co id='ccusb-snit-option' />

    #
    # Called when the run is being started.  
    # 
    # @param driverPtr - 'pointer' to the CCUSB object.
    #
    method Initialize driverPtr {      <co id='ccusb-snit-Initializemethod' />

 
        cccusb::CCCUSB c -this $driverPtr; <co id='ccusb-snit-ccusbswigwrap' />

        # Get the led programming now
        # Yellow is the mask of FF0000
        # Clear out those bits and set that field to be 110000 which is source I3 and
        # inverted.

        set leds [c readLedSelector]      <co id='ccusb-snit-readleds' />
        set leds [expr {$leds &amp;  0xffff}]
        set leds [expr {$leds | 0x110000}]
        c writeLedSelector $leds         <co id='ccusb-snit-writeleds' />

    }
    # Called to contribute to the readout list
    #   
    # @param list - 'pointer' to the CCCUSBReadoutList which will be wrapped in a
    #                swig wrapper.
    #
    method addReadoutList list {       <co id='ccusb-snit-addReadoutListmethod' />

        #
        # Wrap the list so we can use it:
        #
        cccusbreadoutlist::CCCUSBReadoutList l -this $list; <co id='ccusb-snit-ccusbreadoutlist-swigwrap' />

        l addMarker $options(-value)                        <co id='ccusb-snit-addmarker' />

    }
}

                </programlisting>
            </example>
            <para>
                The numbers in the explanations below refer to the corresponding
                numbers in the example text.
            </para>
            <calloutlist>
                <callout arearefs='ccusb-snit-auto_path'>
                    <para>
                        The SWIG Tcl wrappers for the CCUSB and CCUSBReadoutList
                        classes are installed in the <filename>lib</filename>
                        subdirectory of the NSCLDAQ installation.  This
                        adds that directory for the 10.1 verssion of nslcdaq
                        to the package loads search path.  This allows those
                        packages to be loaded via the <command>package require</command>
                        package.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-packages'>
                    <para>
                        Incorporates the following packages into the
                        driver, if they have not been loaded elsewhere:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term>snit</term>
                            <listitem><para>
                                The snit package.  This implements the
                                object oriented framework this example uses.
                                </para></listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>cccusb</term>
                            <listitem>
                                <para>
                                    The  swig wrapper for the
                                    CCUSB C++ class.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>cccusbreadoutlist</term>
                            <listitem>
                                <para>
                                    The swig wrapper for the CCCUSBReadoutList
                                    C++ class.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </callout>
                <callout arearefs='ccusb-snit-type'>
                    <para>
                        The <command>snit::type</command> command
                        creates a new snit class like entity. The
                        type is named <command>marker-snit</command> and
                        the list of commands that follow define the
                        body of the class.  This creates a new command
                        <command>marker-snit</command> primarly used to
                        construct instances of the type.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-option'>
                    <para>
                        Snit objects all have a set of options that are
                        modified via their built in
                        <command>configure</command> sub command and accessed
                        externally via their <command>cget</command>
                        built in sub command.
                    </para>
                    <para>
                        The <command>option</command> command within a snit
                        type body defines a configurable option
                        (<option>-value</option> in this case), and optionally
                        provides an initial value.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-Initializemethod'>
                    <para>
                        Instance subcommands are created via the
                        snit <command>method</command> command.  This command
                        looks exactly like the <command>pro</command> command
                        except that methods generate subcommands.
                    </para>
                    <para>
                        The <methodname>Initialize</methodname> method must
                        be implemented by all device driver objecgt (do-nothing
                        implementations are fine).  The parameter to this method
                        is a pointer like entity which points to a
                        <classname>CCCUSB</classname> object that communuicates
                        with the selected CAMAC crate.
                    </para>
                    <para>
                        The <methodname>Initialize</methodname> method is
                        invoke for all object instances that are added to stacks.
                        It is suposed to look at the configuration items and
                        do what is necessary to program the module it supports
                        to prepare to take data in the specified configuration.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-ccusbswigwrap'>
                    <para>
                        Creates a swig wrapping of the <classname>CCCUSB</classname>
                        class whose underlying class is the class 'pointed to'
                        by the <parameter>driverPtr</parameter> parameter.
                    </para>
                    <para>
                        The wrapping creats a command <command>c</command>
                        Subcommands of that command are mapped to methods in the
                        <classname>CCCUSB</classname> C++ class.
                    </para>
                    <para>
                        You can also get Swig to name the new object after
                        the pointer that was passed in:
                        <informalexample>
                            <programlisting>
...
cccusb::CCCUSB -this $driverPtr
...
                            </programlisting>
                        </informalexample>
                        Where $driverPtr can be used as the CCCUSB object
                        command.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-readleds'>
                    <para>
                        This is an example of invoking a CCCUSB method.
                        The subcommand <methodname>readLedSelector</methodname>
                        reads the CC-USB LED selector register. The subsequent
                        code makes changes the fields that control the yellow
                        LED so that it's input is the NIM IN3 inpout and is lit
                        when there is no input (inverted state).  This should
                        normally light the yellow LED.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-writeleds'>
                    <para>
                        Invokes the CCCUSB <methodname>writeLedSelector</methodname>
                        so that the new value of the LED selector register
                        takes effect.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-addReadoutListmethod'>
                    <para>
                        The <methodname>addReadoutList</methodname>
                        is invoked for each driver instance that is in a stack
                        as the run is started.  It is is expected to contribute
                        elements to a <classname>CCCUSBReadoutList</classname>
                        object that read the supported module in the manner
                        defined by the object's configuration.
                    </para>
                    <para>
                        The <parameter>list</parameter> parameter is a pointer
                        like value to a <classname>CCCUSBReadoutList</classname>
                        object.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-ccusbreadoutlist-swigwrap'>
                    <para>
                        Wraps the pointer in a SWIG object analagous to what
                        was done for the ccusb pointer passed to
                        <methodname>Initialize</methodname>.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-addmarker'>
                    <para>
                        Adds a marker to the list.
                        The marker value will be value of the
                        <option>-value</option> option. In snit, options
                        are put in an array named <varname>options</varname>
                        indexed by the option name.
                    </para>
                </callout>

            </calloutlist>
        </section>
        <section>
            <title>A sample Incr-Tcl Tcl CCUSB framework driver</title>
            <para>
                Incr Tcl is an object oriented extension for Tcl.  It is installed
                on all NSCL systems.  It provides the ability to define
                <firstterm>classes</firstterm>. As with snit, creating a class
                 instance (object) creates a new command.  The public class
                 methods are then subcommands for the object command.
            </para>
            <para>
                As with snit, objects can have configurations that are manipulated
                and queried via built in <command>config</command> and
                <command>cget</command> object subcommands.  Unlike snit,
                all public member variables are considered to be
                configurable objects to Incr Tcl.
            </para>
            <para>
                The properties above make Incr Tcl a viable option for
                implementing driver support.
            </para>
            <para>
                <ulink url='http://incrtcl.sourceforge.net/itcl/'>
                    http://incrtcl.sourceforge.net/itcl/</ulink>
                provides information about Incr Tcl.
            </para>
            <para>
                The example below shows a marker driver identical in functionality
                to the snit driver shown in the previous section, but written
                with Incr Tcl.
            </para>
            <example>
                <title>CCUSB device support example writtin in Incr Tcl</title>
                <programlisting>
lappend auto_path /usr/opt/daq/10.1/lib
puts $auto_path
package require Itcl                       <co id='ccusb-itcl-header' />
package require cccusb
package require cccusbreadoutlist

itcl::class marker-itcl {                 <co id='ccusb-itcl-class' />
    public variable value 0               <co id='ccusb-itcl-options' />

    #
    # Called when the run is being started.  
    # 
    # @param driverPtr - 'pointer' to the CCUSB object.
    #
    public method Initialize driverPtr {  <co id='ccusb-itcl-initialize' />

        #  This turns the driver pointer into a CCUSB object which
        #  can make use of the SWIG wrappers for the CCUSB code:

        cccusb::CCCUSB c -this $driverPtr; # c is a CAMAC controller object.

        # Get the led programming now
        # Yellow is the mask of FF0000
        # Clear out those bits and set that field to be 110000 which is source I3 and
        # inverted.

        set leds [c readLedSelector]
        set leds [expr {$leds &amp;  0xffff}]
        set leds [expr {$leds | 0x110000}]
        c writeLedSelector $leds

    }
    # Called to contribute to the readout list
    #   
    # @param list - 'pointer' to the CCCUSBReadoutList which will be wrapped in a
    #                swig wrapper.
    #
    public method addReadoutList list {               <co id='ccusb-itcl-addreadoutlist' />

        #
        # Wrap the list so we can use it:
        #
        cccusbreadoutlist::CCCUSBReadoutList l -this $list; # l is now a swig wrapper over the list.

        l addMarker $value                          <co id='ccusb-itcl-addmarker' />

    }

                </programlisting>
            </example>
            <para>
                 The numbers in the explanations below refer to the numbers
                 in the example above.
            </para>
            <calloutlist>
                <callout arearefs='ccusb-itcl-header'>
                    <para>
                        This heading is easily  understandable from the
                        example in the previous section.  The only difference
                        is that the Itcl package is loaded instead of snit.
                    </para>
                </callout>
                <callout arearefs='ccusb-itcl-class'>
                    <para>
                        The <command>class</command> command creates an Incr
                        Tcl class. The class name <command>marker-itcl</command>
                        becomes the command name for creating class instances
                        (objects).
                    </para>
                </callout>
                <callout arearefs='ccusb-itcl-options'>
                    <para>
                        Unlike snit Incr Tcl does not have a separate facility
                        for creating options.  Any instance variable that is
                        declared <literal>public</literal> is treated as
                        a configuration parameter.
                    </para>
                    <para>
                        Therefore this line creates the
                        <option>-value</option>.   Configuring
                        <option>-value</option> will modify this variable.
                        Cgetting <option>-value</option> will read this
                        variable.
                    </para>
                </callout>
                <callout arearefs='ccusb-itcl-initialize'>
                    <para>
                        The <methodname>Initialize</methodname> method
                        has been described previously.  The body of this
                        method is identical to the body of the
                        correpondig <literal>snit::type</literal>.
                        method.
                    </para>
                </callout>
                <callout arearefs='ccusb-itcl-addreadoutlist'>
                    <para>
                        Creates a method to be called when the software
                        is building readout lists.  With the exception
                        shown below, this too is identical to the
                        contents of the same method in the snit example.
                    </para>
                </callout>
                <callout arearefs='ccusb-itcl-addmarker'>
                    <para>
                        In Incr Tcl, options are just member variables.
                        Therefore when the marker is added ot the stack,
                        <literal>$value</literal> substitutes the
                        selected value.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section id="ccusb-general-tcldriver-usage">
            <title>Using Tcl drivers in the DAQ configuration file.</title>
            <para>
                Using a Tcl driver in the DAQ configuration file requires that you
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Incorporate the driver code into your DAQ configuration
                        script.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Create device instances for the hardware you want read
                        out by your experiment.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Register the device instances with the CCUSB frameowork
                        so that they can be referred to in
                        <command>stack</command> or other
                        module containing commands.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Add the instances to a stack
                    </para>
                </listitem>
            </itemizedlist>
            <formalpara>
                <title>Incorporating driver code into the DAQ configuration file</title>
                <para>
                    Tcl provides two suitable mechanisms for incorporating
                    device support code into your DAQ configuration script.  Note
                    that these mechanisms are not restricted to device support
                    code but could be used to incorporate any Tcl library code
                    you might need.
                </para>
            </formalpara>
            <para>
                The <command>source</command> command allows you to include
                a specific Tcl script file given a relative or absolute path
                directly to that script.  Suppose our device support
                file named <filename>mydriver.tcl</filename> is located
                in the same directory as the configuration script.  The
                code fragment below is an accepted way to source that file
                that doesn ot assume the current working directory is where the
                script is:
            </para>
            <informalexample>
                <programlisting>
set here [file dirname [info script]]
source [file join $here mydriver.tcl]
                </programlisting>
            </informalexample>
            <para>
                The first command determines the directory that holds the
                script while the second uses that to construct a path to the
                <filename>mydriver.tcl</filename> file for the <command>source</command>
                command.
            </para>
            <para>
                If you develop a library of device support code, or are using
                someone else's device support code, it is probably preferable
                to use the Tcl <command>package</command> command,
                <filename>pkgIndex.tcl</filename> and package search paths
                to load the driver code.
            </para>
            <para>
                The author of the driver code you are using must have cooperated
                to the extent of having a <command>package provide</command>
                command in their scripts, and creating a <filename>pkgIndex.tcl</filename>
                (through e.g. Tcl's <command>pkg_mkIndex</command> command) in the
                directories holding their packagtes.
            </para>
            <para>
                Once this is done you can append the script package directories
                to your <varname>auto_path</varname> variable and use
                <command>package require</command> to pull in the required
                files.
            </para>
            <para>
                Suppose, for example, <filename>/projects/mydetector/drivers</filename>
                is a directory that contains several device support scripts
                given package names like <literal>device1</literal>
                <literal>device2</literal>, suppose further that you are
                running in conjunction with another system that has
                <literal>device3</literal> in <filename>/projects/otherdetector/drivers</filename>.
                The following script fragment uses the Tcl package facility to load
                those drivers:
            </para>
            <informalexample>
                <programlisting>
lappend auto_path /projects/mydetector/drivers /projects/otherdetector/drivers
package require device1
package require device2
package require device3
                </programlisting>
            </informalexample>
            <para>
                Furthermore, by using the <literal>TCLLIBPATH</literal>
                rather than the <varname>auto_path</varname> variable you
                can make it so that your script does not need to know
                which directories have package files.
            </para>
            <formalpara>
                <title>Creating device instances</title>
                <para>
                    How you create device instances depends on how you the
                    driver was written.  In snit, for example you use the
                    <command>snit::type</command> type name's create
                    sub command.  For example for the previous example driver:
                </para>
            </formalpara>
            <informalexample>
                <programlisting>
marker-snit create snitmarker
                </programlisting>
            </informalexample>
            <para>
                creates an instance of the driver named <literal>snitmarker</literal>.
                The base name of the resulting command ensemble is also
                <command>snitmarker</command>.
                In the case of our Incr Tcl driver:
            </para>
            <informalexample>
                <programlisting>
marker-itcl itclmarker
                </programlisting>
            </informalexample>
            <para>
                Creates an instance whose name is <literal>itclmarker</literal>
                and whose instance command is
                <command>itclmarker</command>
            </para>
            <para>
                Once created, how you configure the device depends on the
                framework used to build the driver.  For both the
                snit and Incr Tcl examples, the <command>configure</command>
                command can be used to configure  the object instance:
            </para>
            <informalexample>
                <programlisting>
<replaceable>instance-command</replaceable> configure -value 0x1234
                </programlisting>
            </informalexample>
            <formalpara>
                <title>Registering device instances</title>
                <para>
                    Device instances must be registered.  Until they are,
                    they have an existence completely independent of the CCUSB
                    framework.  Registration makes their instance command
                    the name of a device that can be added to <command>stack</command>
                    <option>-module</option> lists.
                </para>
            </formalpara>
            <para>
                The <command>addtcldriver</command> command associated a Tcl
                instance command with a module name:
            </para>
            <informalexample>
                <programlisting>
addtcldriver snitmarker
                </programlisting>
            </informalexample>
            <para>
                Creates a module name <literal>snitmarker</literal> that is
                associated with the <command>snitmarker</command>
                instance of the <classname>marker-snit</classname> driver.
            </para>
            <para>
                Given this discussion, here is a fragment of a
                daq cofiguration script:
            </para>
            <example>
                <title>DAQ config script fragment with tcl drivers.</title>
                <programlisting>
...
set here [file dirname [info script]]

source [file join $here testdriver-snit.tcl]
marker-snit create snitmarker
snitmarker configure -value 0x5678
addtcldriver snitmarker

source [file join $here testdriver-itcl.tcl]
marker-itcl itclmarker
itclmarker configure -value 0xfafa
addtcldriver itclmarker


# testing and tdc were defined earlier by 'normal' commands.,

stack create events
stack config events -modules [list itclmarker snitmarker testing tdc] -type event -delay 108

                </programlisting>
            </example>
        </section>
            
    </section>
    <section>
        <title>The slow controls subsystem</title>
        <para>
            There is nothing to stop you from creating device support that
            does not do anything in its <methodname>addReadoutList</methodname>.
            You could do this to implement static controls devices.  That is
            non data taking devices whose configuration is set up at the start of
            a run and cannot be dynamically modified.
        </para>
        <para>
            There are cases, however when you'd like to have some control
            panel associated with a device, that would provide a virtual knob
            allowing you to dynamically modify settings in the device.
            The slow controls subsystem supports this by offering a
            TCP/IP server which can accept commands to set and query
            devices.  
        </para>
        <para>
            If the run is halted, the slow controls server can directly
            manipulate the CCUSB to perform the desired device changes.
            If, however the CCUSB is in data taking mode, the slow controls
            server pauses the run, makes the setting and then resumes the run.
            You should avoid working with control panels during production runs
            for that reason.
        </para>
        <para>
            The philosophy of the slow controls subsystem is similar to that
            of the readout subsystem.  A controls configuration file defines
            the control modules present in the system and their unchanging
            configuration.  Note that the controls configuration file
            is read only as CCUSBReadout starts, not once per run as
            for the data acquisition configuration file.
        </para>
        <para>
            The <command>Module</command> command is used to create configure
            and query the configuration of slow controls devices known to the server.
            The example below shows how to a Phillips PH7106 leading edge
            discriminator:
        </para>
        <informalexample>
            <programlisting>
Module create ph7106  led
Module config led -slot 3
            </programlisting>
        </informalexample>
        <para>
            The <literal>3ccusb</literal> reference section describes the Module types available,
            the configuration options available, their control panels and
            the network protocol used to communicate with the controls server.
        </para>
    </section>
    <section>
        <title>Running CCUSBReadout</title>
        <para>
            <application>CCUSBReadout</application> is installed as:
            <filename>$DAQROOT/bin/CCUSBReadout</filename>.
        </para>
        <para>
            Several command options control the way CCUSBReadout operates:
        </para>
        <variablelist>
            <varlistentry>
                <term><option>-serialno</option></term>
                <listitem>
                    <para>
                        Specifies the serial number of the CCUSB the program
                        will use.  See <option>--enumerate</option> below.
                        If not provided, the first CCUSB located will be used.
                        If you only have one CCUSB connected to your system,
                        this is suitable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--ring</option></term>
                <listitem>
                    <para>
                        Specifies the ring buffer in which event data will
                        be put by the program.  By default this is the
                        same as the username you are logged in on .
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--daqconfig</option></term>
                <listitem>
                    <para>
                        Specifies the filename that contains the data acquisition
                        configuration script.  This defaults to
                        <filename>~/config/daqconfig.tcl</filename>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--ctlconfig</option></term>
                <listitem>
                    <para>
                        Specifies the filename that contains the slow controls
                        configuration script.  This defaults to
                        <filename>~/config/controlconfig.tcl</filename>. Note
                        that this file is required even if it is just an empty file.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--port</option></term>
                <listitem>
                    <para>
                        Specifies the port on which the slow controls server
                        listens for connections.  This default to
                        <literal>27000</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--enumerate</option></term>
                <listitem>
                    <para>
                        Requests that the software list the serial numbers of
                        the CCUSB devices currently attached to the system and
                        exit.  Note that the serial 'numbers' are actually strings
                        of the form <literal>CCnnnn</literal> where <replaceable>nnnn</replaceable>
                        is a number.  One of these strings can be handed to the
                        <option>--serialno </option> to select the CCUSB
                        to use.
                    </para>
                    <para>
                        Sample output:
                    </para>
                    <informalexample>
                        <programlisting>
/usr/opt/daq/10.1/bin/CCUSBReadout --enumerate
CC-USB scriptable readout version V2.0
[0] : CC0134

                        </programlisting>
                        <para>
                            This output says the system is attached to a single
                            CCUSB whose serial number string is
                            <literal>CC0134</literal>
                        </para>
                    </informalexample>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
</chapter>
<!-- /chapter -->

<!-- manpage 3ccusb -->
    <refentry id='ccusb3-addtcldriver'>
        <refmeta>
           <refentrytitle>addtcldriver</refentrytitle>
           <manvolnum>3ccusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>addtcldriver</refname>
           <refpurpose>Register Tcl command ensemble as a device module</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
addtcldriver <replaceable>tcl-command</replaceable>
            </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Registers the base of a Tcl command ensemble (e.g. an object
            instance command) as a device module that can be used in
            module lists such as the <option>-modules</option> option of a
            <command>stack</command> command.
           </para>
           <para>
                The <parameter>tcl-command</parameter> is the command
                to regsiter.
           </para>
        </refsect1>
        <refsect1>
            <title>EXAMPLE</title>
            <para>
                The command below:
            </para>
            <informalexample>
                <programlisting>
addtclcommand sometclinstance
                </programlisting>
            </informalexample>
            <para>
                Registers the Tcl command <command>sometclinstance</command>
                as a module.  The name of the module is the same as the
                name of the command (<literal>sometclinstance</literal>).
            </para>
            </refsect1>

      </refentry>


	 <refentry id="ccusb3-ad811">
	   <refmeta>
	      <refentrytitle>ad811</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>ad811</refname>
	      <refpurpose>Support the Ortec AD811 ADC</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
ad811 create <replaceable>module-name   ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
ad811 config <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
ad811 cget <replaceable>module-name</replaceable>
	     </command>
	     </cmdsynopsis>
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
	       This command ensemble provides support for the ORTEC AD811
	       8 channel peak sensing ADC.  This module requires about 80
	       microseconds to convert.  All channels convert unconditionally.
	      </para>
	      <para>
		  <parameter>module-name</parameter> is either the name to be
		  given to an ADC in the <command>create</command> subcommand
		  or the name given to a previously created module in the
		  <command>config</command> or <command>cget</command> commands.
	      </para>
	      <para>
	       Both <command>create</command> and <command>config</command> take
	       configuration options.   Each option is a keyword value pair where
	       the keyword defines what the option is and the value is a value
	       associated with that option.  See OPTIONS below for more information
	       about the options supported by <command>ad811</command>.
	      </para>
	      <para>
	       The <command>cget</command> option returns the configuration options
	       for the named module as a Tcl list.  Each element of the list is
	       a two element sublist.  The first element of each sublist is
	       the configuration parameter name, and the second the value associated
	       with that name.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>
	       OPTIONS
	    </title>
	    <para>
	       The <command>ad811</command> configuration options are:
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			   Each module has an identifier which, for historical
			   reasons is called a <firstterm>virtual slot number</firstterm>,
			   or <firstterm>vsn</firstterm>.  To maximize the decode
			   error detection the virtual slot numbers for each
			   module should be unique.  This option allows you
			   to set the virtual slot number for the module.
		     </para>
		     </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>slotnum</replaceable></term>
		  <listitem>
		     <para>
			The value of this parameter tells the readout software
			which CAMAC crate slot houses the module.  Recall that
			CAMAC is slot addressable.  Slots number from 1 on the
			left, with an increasing slot number towards the right.
			The right two slots are reserved for the CAMAC Crate
			controller (in our case a CC-USB).
		     </para>
		  </listitem>
	       </varlistentry>
	    </variablelist>
	   </refsect1>
	   <refsect1>
	      <title>EXAMPLE</title>
	      <para>
	       The example below creates and configures an AD811 that is in
	       slot 2 of the CAMAC crate and, when read will have a virtual
	       slot number of 2:
	      </para>
	      <example>
		  <title>AD811 configuration file example</title>
		  <programlisting>
ad811  create adc -slot 2 -id 2
		  </programlisting>
	      </example>
	   </refsect1>
	 
	 </refentry>
         
<refentry id="ccusb3-c1205">
  <refmeta>
     <refentrytitle>c1205</refentrytitle>
     <manvolnum>3ccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>c1205</refname>
     <refpurpose>Manage CAEN C1205 QDC modules.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    <command>
c1205 create <replaceable>module-name ?option...?</replaceable>
    </command>
    </cmdsynopsis>
<cmdsynopsis>
<command>
c1205 config <replaceable>module-name ?option...?</replaceable>
</command>
</cmdsynopsis>
<cmdsynopsis>
<command>
c1205 config <replaceable>module-name</replaceable>
</command>
</cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
	      <para>
		  This command ensemble allows you to create and configure
		  CAEN model C1205 QDC modules.  The C1205 is a sixteen
		  channel charge integrating ADC.
	      </para>
	      <para>
		  The <command>create</command> command
		  allows you to create a new module and assign a
		  <parameter>module-name</parameter> to it so that it can
		  be referred to in subsequent configuration commands.
		  You may optionally include configuration switch value pairs
		  on the <command>create</command> command line.
	      </para>
	      <para>
		  The <command>config</command> subcommand allows you to
		  set the configuration parameters for an existing module.
		  <parameter>module-name</parameter> is the name assigned to
		  that module whe it was created.
	      </para>
	      <para>
		  The <command>cget</command> command returns as its value
		  the module configuration as a Tcl list where each list element
		  is a sublist containing the name and value of a configuration
		  parameter.
	      </para>
	      <para>
		  Configuration options are name/value pairs.   The name
		  of a configuration option is sometimes called a
		  <firstterm>switch</firstterm> because it resembles the
		  command line switches of command shell commands.
		  For a full description of these options see OPTIONS below.
	      </para>
  </refsect1>
  <refsect1>
      <title>OPTIONS</title>
      <para>
	 The CAEN C1205 supports the following configuration option switches.
	 The switches and values can be supplied to both the
	 <command>create</command> and the <command>config</command>
	 subcommands.
      </para>
      <variablelist>
	 <varlistentry>
	 <term><option>-slot</option> <replaceable>n</replaceable></term>
	 <listitem>
	    <para>
	       Specifies the slot in which the module is installed
	       to <literal>n</literal>.
	       If this is not set correctly, the Readout program will
	       not be able to communicate with the module and will emit
	       a warning, if the slot <literal>n</literal> is empty.
	       This parameter must be provided.
	    </para>
	 </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-id</option> <replaceable>n</replaceable></term>
	    <listitem>
	       <para>
		  Sets the id of the module to <literal>n</literal>.
		  The module id is placed as a marker word prior
		  to the data from the module.  It is used by the
		  unpacking software to unambiguously identify The
		  data from each module.  For the C1205, the id
		  value is also programmed into the lower 8 bits of the
		  control status register and will therefore also
		  appear in the bottom 8 bits of the header word
		  read from the module.
	       </para>
	       <para>
		  While the <option>-id</option> value defaults to
		  0, and need not be unique, your data is most
		  reliably decoded if each module in your system has
		  a unique id value.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-usepedestals</option> <replaceable>true|false</replaceable></term>
	    <listitem>
	       <para>
		  The value of this configuration parameter determines how
		  bit 12 of the control status register is initialized.
		  If <literal>true</literal> (default value), the bit is
		  set to one which enables pedestal subtraction from the input
		  signal.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-hires</option> <replaceable>true|false</replaceable></term>
	    <listitem>
	       <para>
		  The value of this configuration parameter determins how
		  bit 16 of the module control status register is
		  initialized.  If <literal>true</literal> (default value)
		  the bit is set to zero enabling high resolution mode.
		  If set <literal>false</literal> low resolution mode
		  is selected.
		  High resolution
		  mode provides 12 bits of data resolution while low
		  resolution mode provides only 10 bits of data resolution.
		  High resolution comes at a cost of an additional 1.5
		  microseconds of conversion time (5.5 microseconds compared
		  with 4 microseconds for low resolution).
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-thresholds</option> <replaceable>threshold-list</replaceable></term>
	    <listitem>
	       <para>
		  Provides the channel threshold registers.  This is a Tcl
		  list of 16 integers in the range <literal>0-4095</literal>.
		  Data is read from a module only if the data value for the
		  module's low range is greater than the corresponding element
		  of the list.  The thresholds default to a list of 16 zeroes.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-lopedestals</option> <replaceable>pedestal-list</replaceable></term>
	    <listitem>
	       <para>
		  Provides a list of 16 integers (0-4095) which are subtracted
		  from the data values to  produce the low range value.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-midpedestals</option> <replaceable>pedestal-list</replaceable></term>
	    <listitem>
	       <para>
		  Same  as <option>-lopedestals</option> but the pedestals
		  are applied to the mid level conversion.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-hipedestal</option> <replaceable>pedestal-list</replaceable></term>
	    <listitem>
	       <para>
		  Same as <option>-lopedestals</option> but the pedestals
		  are applied to the low level conversion.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-rangemode</option> <replaceable>mode</replaceable></term>
	    <listitem>
	       <para>
		  Sets the module range mode.  The value for
		  <replaceable>mode</replaceable> must be one of the following:
		  <variablelist>
		     <varlistentry>
			<term><literal>all</literal></term>
			<listitem>
			   <para>
			      Conversions from all ranges appear in each event.
			      In this mode, some of the conversions will likely
			      have negative values.
			   </para>
			</listitem>
		     </varlistentry>
		     <varlistentry>
			<term><literal>auto</literal></term>
			<listitem>
			   <para>In this mode (default) only the  range
			      the conversion falls in will appear in the
			      data fromt he mdule.
			   </para>
			</listitem>
		     </varlistentry>
		     <varlistentry>
			<term><literal>sparse</literal></term>
			<listitem>
			   <para>Same as auto, but only data from channels
			      are above the channel thresholds set
			      via the <option>-thresholds</option> option
			      appear in the data from the module.
			   </para>
			</listitem>
		     </varlistentry>
			      
		  </variablelist>
	       </para>
	    </listitem>
	 </varlistentry>
	 
      </variablelist>
  </refsect1>
</refentry>

<refentry id="ccusb3-c257">
  <refmeta>
     <refentrytitle>c257</refentrytitle>
     <manvolnum>cccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>c257</refname>
     <refpurpose>Manages the C257 scaler module</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    <command>
c257 create <replaceable>name ?options...?</replaceable>
    </command>
    </cmdsynopsis>
    <cmdsynopsis>
    <command>
c257 config <replaceable>name ?options...?</replaceable>   
    </command>
    </cmdsynopsis>
   <cmdsynopsis>
   <command>
c257 cget <replaceable>name</replaceable>   
   </command>
   </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
	 <para>
	     This command ensemble allows you to create and configure
	     CAEN model C257 scaler modules.  The C257 is a 16 channel
	     scaler module.  Support is intended to be used with the
	     scaler stack.  The C257 is capable of cascading channels
	     to produce very wide counters, however this mode is not supported
	     by this release of the software limiting the width of each
	     scaler to 24 bits.  Thus, to use the module with this
	     software requires that all of the module jumpers be set to the
	     <literal>SINGLE</literal> position rather than to
	     <literal>CASCADE</literal>.
	 </para>
	 <para>
	     The <command>create</command> command
	     allows you to create a new module and assign a
	     <parameter>module-name</parameter> to it so that it can
	     be referred to in subsequent configuration commands.
	     You may optionally include configuration switch value pairs
	     on the <command>create</command> command line.
	 </para>
	 <para>
	     The <command>config</command> subcommand allows you to
	     set the configuration parameters for an existing module.
	     <parameter>module-name</parameter> is the name assigned to
	     that module whe it was created.
	 </para>
	 <para>
	     The <command>cget</command> command returns as its value
	     the module configuration as a Tcl list where each list element
	     is a sublist containing the name and value of a configuration
	     parameter.
	 </para>
	 <para>
	     Configuration options are name/value pairs.   The name
	     of a configuration option is sometimes called a
	     <firstterm>switch</firstterm> because it resembles the
	     command line switches of command shell commands.
	     For a full description of these options see OPTIONS below.
	 </para>
  </refsect1>
  <refsect1>
   <title>
      OPTIONS
   </title>
   <para>
      The module is configured via the following set of options.
   </para>
   <variablelist>
      <varlistentry>
	 <term><option>-slot</option> <replaceable>slotnumber</replaceable></term>
	 <listitem>
	    <para>
	       Specifies <parameter>slotnumber</parameter> as the CAMAC
	       crate slot in which the module  is inserted.  This must
	       be correct or else the software will not be able to
	       communicate with the module.
	    </para>
	 </listitem>
      </varlistentry>
      <varlistentry>
	  <term><option>-id</option> <replaceable>module-id</replaceable></term>
	  <listitem>
	      <para>
	       Specifies a module id for the unit.  If the
	       <option>-insertid</option> configuration parameter is
	       <literal>true</literal> this id is inserted prior to the
	       scaler data readout by the stack.  This option, and
	       <option>-insertid</option> should not be used in the scaler
	       stack and is intended as latent support for using the
	       scaler in an event stack (e.g. for supplying an event
	       timestamp).
	      </para>
	  </listitem>
      </varlistentry>
      <varlistentry>
	  <term><option>-insertid</option> <replaceable>true|false</replaceable></term>
	  <listitem>
	      <para>
	       If this parameter is <literal>true</literal> the value specified
	       by the <option>-id</option> option will be inserted in the data
	       buffer prior to the
	       data from this module.
	       This should be <literal>false</literal> (the default) if
	       the module is used in the scaler stack.
	      </para>
	      <para>
		  <option>-id</option> and <option>-insertid</option>
		  are intended as latent support for using the scaler module
		  in the event stack (e.g. to supply an event timestamp).
	      </para>
	  </listitem>
      </varlistentry>
      <varlistentry>
	  <term><option>-readinhibit</option> <replaceable>true | false</replaceable></term>
	  <listitem>
	      <para>
	       If this parameter is <literal>true</literal> (the default), the
	       CAMAC crate is held inhibited while the scaler module is
	       being read, and the module is read with an F2 Q-scan.
	       If <literal>false</literal> the module is read via 16
	       F0's directed at specific subaddresses followed by an
	       F9 to reset the counters.
	      </para>
	  </listitem>
      </varlistentry>
   </variablelist>
  </refsect1>

</refentry>
      <refentry id="ccusb3_ccusb_command">
        <refmeta>
           <refentrytitle id='ccusb3_ccusb_command_title'>ccusb (command)</refentrytitle>
           <manvolnum>3ccusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>ccusb (command)</refname>
           <refpurpose>Configure and read scalers from CC-USB module</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
ccusb create name ?options?
          </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
ccusb config name ?options?
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
ccusb cget name
            </command>
            </cmdsynopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            <command>ccusb</command> provides a readout module that allows you
            to configure many of the resources of the CCUSB as well as
            providing the capability of rerading the module internal scalers.
            Note that owing to the way the framework operates, you must include
            CCUSB modules in either the event or scaler stack in order to
            configure them, even if you don't intend to readout the scalers.
           </para>
           <para>
            For the configuration options see <literal>OPTIONS</literal>
            below.
           </para>
           <para>
            The resources you can control are the module internal gate and delay
            generators, the module internal scalers, the meaning of the
            Module NIM outputs and inputs and the meaning of the front panel
            LED displays.
           </para>
        </refsect1>
            <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-gdgasource</option></term>
                <listitem>
                    <para>
                        Defines the start of the module internal gate and delay
                        generator A.  This can be one of:
                        <literal>disabled, in1, in2, in3, event, eventend, usbtrigger, </literal>
                        or <literal>pulser</literal>.   Sections 3.3.6 and 3.3.7
                        of the CCUSB manual provide more information about the
                        Gate and delay generators.
                    </para>
                    <para>This option defaults to <literal>disabled</literal></para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgbsource</option></term>
                <listitem>
                    <para>
                        Same as <option>-gdgasource</option>, however the
                        B gate and delay generator start is set.  The same set
                        of values accepted for <option>-gdgasource</option>
                        are accepted for this option.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgawidth</option></term>
                <listitem>
                    <para>
                        Sets the output width of the A Gate and delay generator.
                        This can be a value from <literal>0</literal> through
                        <literal>0xffff</literal> and is in 10ns units.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgbwidth</option></term>
                <listitem>
                    <para>
                        Sets the output width of the B gate and delay generator.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgadelay</option></term>
                <listitem>
                    <para>
                        Sets the output delay on the A gdg output. This can be
                        in the range <literal>0</literal> through
                        <literal>0xffffffff</literal>.  It winds up setting both
                        a field in the
                        <literal>DGG_A</literal> register and the
                        <literal>DGG_Ext</literal> register.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgbdelay</option></term>
                <listitem>
                    <para>
                        Sets the output delay on the B gdg output.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-red</option></term>
                <listitem>
                    <para>
                        Sets the signal that is reflected on the red LED on the
                        module front panel.  This is modified by the
                        <option>-redinvert</option> and <option>-redlatch</option>
                        options described below.
                    </para>
                    <para>
                        Legal values are
                        <literal>event, busy, usboutnotempty</literal> and
                        <literal>usbinnotfull</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-redinvert</option></term>
                <listitem>
                    <para>
                        This boolean parameter, if <literal>true</literal>
                        inverts the sense of the red front panel LED.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>-redlatch</term>
                <listitem>
                    <para>
                        If true, this boolean parameter latches the red front panel
                        LED on once the condition required to ligth it is met.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-green</option></term>
                <listitem>
                    <para>
                        This enumerated parmeter, together with
                        <option>-greeninvert</option> and <option>-greenlatch</option>,
                        determines when the green LED should be lit.  Valid values
                        are:
                        <literal>acquire, nimi1, nimi2, usbinnotemtpy</literal>
                        and <literal>usbtrigger</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-greeninvert</option></term>
                <listitem>
                    <para>
                        Inverts the sense of the green front panel LED.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-greenlatch</option></term>
                <listitem>
                    <para>
                        Latches the green LED on when the condition to light it
                        is met.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-yellow</option></term>
                <listitem>
                    <para>
                        Together with <option>-yellowinvert</option> and
                        <option>-yellowlatch</option> when the yellow front
                        panel LED is lit.  This can be one of the following values:
                        <literal>nimi1, nimi3, busy</literal> or
                        <literal>usbinfifionotempty</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-scalara</option></term>
                <listitem>
                    <para>
                        Defines what makes the A scaler count.  This can have
                        any of the following values:
                        <literal>disabled, nimi1, nimi2, nimi3, event, carryb, dgga</literal>
                        or <literal>dggb</literal>.  The <literal>carryb</literal>
                        increments the scaler when the B scale overflows.  This
                        provides the ability to make the A scaler the most significant
                        24 bits of a 48 bit scaler with the B scaler the least
                        significant 24 bits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-scalerb</option></term>
                <listitem>
                    <para>
                        Defines what makes scaler B count.  This can have any of
                        the following values:
                         <literal>disabled, nimi1, nimi2, nimi3, event, carrya, dgga</literal>
                        or <literal>dggb</literal>. The <literal>carrya</literal>
                        increments the scaler when the A scale overflows.  This
                        provides the ability to make the B scaler the most significant
                        24 bits of a 48 bit scaler with the A scaler the least
                        significant 24 bits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out1</option></term>
                <listitem>
                    <para>
                        Together with <option>-out1invert</option>
                        and <option>-out1latch</option> determines the condition
                        that drives the O1 NIM output.  This can be one of the
                        following values:
                        <literal>busy, event, gdga</literal> or
                        <literal>gdgb</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out1invert</option></term>
                <listitem>
                    <para>
                        Inverts the sense of the O1 NIM output.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out1latch</option></term>
                <listitem>
                    <para>
                        Latches the state of O1 once the condition needed to
                        make it a logic true has been detected.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out2</option></term>
                <listitem>
                    <para>
                        Together with <option>-out2invert</option> and
                        <option>-out2latch</option> determines when the
                        NIM O2 signal is asserted.  This can be one of the
                        following values:
                        <literal>acquire, event, gdga, </literal> or
                        <literal>gdgb</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out2invert</option></term>
                <listitem>
                    <para>
                        Inverts the sense of the O2 NIM output.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out2latch</option></term>
                <listitem>
                    <para>
                        Latches the NIM O2 state when the condition to assert
                        it has been met.  This condition is determined by
                        both <option>-out2</option> and
                        <option>-out2invert</option>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out3</option></term>
                <listitem>
                    <para>
                        Together with <option>-out3invert</option>
                        and <option>-out3latch</option> determines the behavior
                        of the NIM O3 output.  This can be any of the following
                        values: <literal>busyend, busy, gdga, </literal> or
                        <literal>gdgb</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-o3invert</option></term>
                <listitem>
                    <para>
                        Inverts the condition that asserts O3.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-o3latch</option></term>
                <listitem>
                    <para>
                        Latches O3 in the asserted state when the condition
                        to assert it is met.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-readscalers</option></term>
                <listitem>
                    <para>
                        Boolean that when true enables the readout of the A and
                        B scalers in the stack this module is in.  The A scaler
                        is read first then the B scaler.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-incremental</option></term>
                <listitem>
                    <para>
                        This boolean parameters only matters when
                        <option>-readscalers</option> is true.  It causes
                        the scalers to be cleared once they have been read.
                        Note that in general some counts may be lost as there
                        is no way to atomically read and clear the scaler counters.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>

	 <refentry id="lccusb3-rs2228">
	   <refmeta>
	      <refentrytitle>lrs2228</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>lrs2228</refname>
	      <refpurpose>Manages the LRS2228 TDC</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
lrs2228 create <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2228 config <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2228 cget <replaceable>module-name</replaceable>
	     </command>
	     </cmdsynopsis>
	     
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
		  This command ensemble allows you to create and configure
		  LeCroy model LRS 2228 TDC modules.  The LRS 2228 is an eight
		  channel Time digitizer.
	      </para>
	      <para>
		  The <command>create</command> command
		  allows you to create a new module and assign a
		  <parameter>module-name</parameter> to it so that it can
		  be referred to in subsequent configuration commands.
		  You may optionally include configuration switch value pairs
		  on the <command>create</command> command line.
	      </para>
	      <para>
		  The <command>config</command> subcommand allows you to
		  set the configuration parameters for an existing module.
		  <parameter>module-name</parameter> is the name assigned to
		  that module whe it was created.
	      </para>
	      <para>
		  The <command>cget</command> command returns as its value
		  the module configuration as a Tcl list where each list element
		  is a sublist containing the name and value of a configuration
		  parameter.
	      </para>
	      <para>
		  Configuration options are name/value pairs.   The name
		  of a configuration option is sometimes called a
		  <firstterm>switch</firstterm> because it resembles the
		  command line switches of command shell commands.
		  For a full description of these options see OPTIONS below.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>OPTIONS</title>
	    <para>
	       The following options are recognized by the
	       <command>lrs2228 create</command> and
	       <command>lrs2228 config</command> commands.
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			Each module should be assigned a unique virtual
		        number.  If not assigned this will be 0.  The data packet
			returned by the module will be prefixed by the ID.
			This provides error checking for the code that wil be
			unpacking the raw data.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>camac-slot</replaceable></term>
		  <listitem>
		     <para>
			Provides the number of the slot in which the CAMAC
			module has been installed (<parameter>camac_slot</parameter>).
			This must match the physical slot the module has been
			stuffed in in order to ensure the proper module is
			initialized and reads.
		     </para>
		  </listitem>
	       </varlistentry>
	    </variablelist>
	   </refsect1>
	   <refsect1>
	      <title>EXAMPLES</title>
	      <para>
		  The following is an example of the <command>create</command>
		  command for the LRS2228:
	      </para>
	      <example>
	       <title>LRS2228 creation example</title>
	       <programlisting>
lrs2228 create tdc -slot 6 -id 4		  
	       </programlisting>
	      </example>
	   </refsect1>
	 </refentry>
	 <refentry id="ccusb3-lrs2249">
	   <refmeta>
	      <refentrytitle>lrs2249</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>lrs2249</refname>
	      <refpurpose>Manage LeCroy 2249 QDC modules</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
lrs2249 create <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2249 config <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2249 cget <replaceable>module-name</replaceable>
	     </command>
	     </cmdsynopsis>
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
	       The <command>lrs2249</command> command ensemble
	       allows you to read out
	       LeCroy model LRS 2249 modules.  The LRS 2249 is a charge integrating
	       ADC (QDC).
	      </para>
	      <para>
	       The <command>create</command> subcommand creates
	       a new module assigning it the <parameter>module-name</parameter>
	       you supply.  The <parameter>module-name</parameter> can be used
	       to refer to the module in future commands.  You may optionally
	       provide cofiguration information when creating the module.
	      </para>
	      <para>
	       The <command>config</command> subcommand configures an existing
	       module by providing configuration options for an existing
	       <parameter>module-name</parameter> (created via the
	       <command>create</command> subcommand).  Configuration options are
	       name/value pairs that are also sometimes called switches because
	       of their resemblance to shell command switches.  For a list of
	       the valid configuration options for the LRS 2249 module, see
	       the OPTIONS section below.
	      </para>
	      <para>
	       The <command>cget</command> subcommand returns the configuration
	       parameters for <parameter>module-name</parameter> as a Tcl list
	       of items.  Each item is itself a two element sublist containing
	       in order the name and value of a configuration option.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>OPTIONS</title>
	    <para>
	       The <command>lrs2249</command> command has the following configuration
	       options:
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			Sets the module virtual slot number to <parameter>vsn</parameter>.
			The virtual slot number prefixes the data packet read from this
			module and is used by SpecTcl as a check on the validity
			the event.  Each module should have a unique <parameter>vsn</parameter>.
			If the <option>-id</option> option does not set the virtual
			slot it defaults to 0.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>slot</replaceable></term>
		  <listitem>
		     <para>
			Provides the module <parameter>slot</parameter>.  This
			parameter must match the number of the slot in the
			CAMAC crate in which the module is installed.
		     </para>
		  </listitem>
	       </varlistentry>
	    </variablelist>
	       
	   </refsect1>
        </refentry>
	 <refentry id="ccusb3-lrs2551">
	   <refmeta>
	      <refentrytitle>lrs2551</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>lrs2551</refname>
	      <refpurpose>Manage LRS 2551 modules</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
lrs2551 create <replaceable>module-name ?options...?</replaceable> 
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2551 config <replaceable>module-name ?options...?</replaceable> 	     
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2551 cget <replaceable>module-name</replaceable> 	     
	     </command>
	     </cmdsynopsis>
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
	       The <command>lrs2551</command> command allows you to create and
	       configure LeCroy LRS 2551 scaler modules.  The LRS 2551 is a
	       12 channel scaler.  While it is normally read in the periodic
	       scaler stack, it is also possible to read it in the event
	       stack when properly configured.
	      </para>
	      <para>
	       The <command>create</command> subcommand creates a new module
	       assigning it the name <parameter>module-name</parameter>.
	       <parameter>module-name</parameter> should be used to refer
	       to the module in future commands. Optional configuration data
	       can also be appended to the <command>create</command> subcommand.
	      </para>
	      <para>
	       The <command>config</command> subcommand configures an existing
	       <parameter>module-name</parameter>.  The configuration items are
	       name value pairs.  See OPTIONS below for more information about
	       the options supported by the <command>lrs2551</command> command.
	      </para>
	      <para>
	       The <command>cget</command> subcommand returns the current
	       module configuration.  The configuration is returned as a Tcl list.
	       Each element of the list is a two element sublist that contains
	       the configuration name and value in that order.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>OPTIONS</title>
	    <para>
	        The <command>lrs2551</command> command supports the following
		configuration options:
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-cumulative</option> <replaceable>on|off</replaceable></term>
		  <listitem>
		     <para>
			If <option>-cumulative</option> is false (default),
			the scaler module is cleared after each readout providing
			the counts between each readout as the value of each
			channel. This shoulid be false when used with the NSCLDAQ
			scaler display program in the scaler stack.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			Supplies the virtual slot number; <replaceable>vsn</replaceable>
			for the module.  This only needs to be supplied if the
			module is going to be read in the event stack.
			Note that currently unpacking scaler data from the event
			stack is not supported.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-insertid</option> <replaceable>true|false</replaceable></term>
		  <listitem>
		     <para>
			If <literal>true</literal> (the default is <literal>false</literal>),
			the virtual slot number set by the <option>-id</option>
			configuration value is inserted in the data block from
			the scaler.  If <literal>false</literal> it is not.
			If used with the NSCLDAQ Scaler display in the scaler stack,
			this should be <literal>false</literal>.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>slot</replaceable></term>
		  <listitem>
		     <para>
			Sets the <parameter>slot</parameter> configuration.
			When installed in the CAMAC crate, the module should
			be inserted in the <parameter>slot</parameter> specified
			by this option.
		     </para>
		  </listitem>
		  </varlistentry>
	    </variablelist>
	    
	   </refsect1>
	   <refsect1>
	      <title>EXAMPLES</title>
	      <para>
	       This example creates an LRS 2551 scaler:
	      </para>
	      <example>
	       <title>The lrs2551 command</title>
	       <programlisting>
lrs2551 create counters -slot 4
	       </programlisting>
	      </example>
	   </refsect1> 
</refentry>
         <refentry id="ccusb3-ph7xxx">
           <refmeta>
              <refentrytitle>ph7xxx</refentrytitle>
              <manvolnum>3ccusb</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>ph7xxx</refname>
              <refpurpose>Define Phillips ADC/TDC/QDC modules</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>
             <cmdsynopsis>
         	<command>
ph7xxx create <replaceable>name</replaceable> <optional>?option value ...?</optional>         	
         	</command>
             </cmdsynopsis>
                 <cmdsynopsis>
                     <command>
ph7xxx config <replaceable>name  option value...</replaceable>
                     </command>
                 </cmdsynopsis>
                  <cmdsynopsis>
                      <command>
ph7xxx cget <replaceable>name</replaceable>
                      </command>
                  </cmdsynopsis>
                
           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
               Creates, configures and interrogates the configuration of Philips
               CAMAC digitizers.
              </para>
              <para>
               The <command>create</command> command creates
               a new digitizer <replaceable>name</replaceable> configuration.
               The <replaceable>name</replaceable> parameter must be unique.
               The optional <optional>option value</optional> pairs that follow
               specify the configuration for that module.  This configuration
               can  be supplemented or overridden by subsequent
               <command>config</command> operations on the module.
              </para>
               <para>
                  The <command>config</command> subcommand configures the existing
                  module <replaceable>name</replaceable>.  The remainder of the
                  command line are option value pairs described in the section
                  OPTIONS below.  The module <replaceable>name</replaceable> must
                  have already been created via the <command>create</command>
                  subcommand.  Note that configuration options are processed
                  from left to right, if a configuration option appears more than
                  once, the last instance takes effect.
               </para>
               <para>
                  The <command>cget</command> subcommand returns the configuration
                  of the module.  This can be used in more advanced scripts to
                  analyze the configuration of the system.  The configuration of
                  a module <replaceable>name</replaceable> is returned as a
                  properly formatted Tcl list.  Each element of the list is itself
                  a pair (a two element sublist).  The first element of each pair
                  is the configuration parameter name, the second element the
                  value, which may itself be  a list (e.g. for the
                  <literal>-llt</literal> option.
               </para>
           </refsect1>
           <refsect1>
              <title>
         	OPTIONS
              </title>
              <variablelist>
         	<varlistentry>
         	    <term><option>-slot</option> <replaceable>slotnumber</replaceable></term>
         	    <listitem>
         		<para>
                           This option configures the slot in which the module
                           will be installed.  All modules must be in unique slots,
                           although that is not verified by the configuration manager.
                           The slot must be an integer number from one through 23
                           (slot 24/25 holds the CAMAC crate controller).
         		</para>
                        <para>
                           The default value for this parameter is illegal (0),
                           so you must specify this parameter.
                        </para>
         	    </listitem>
         	</varlistentry>
		<varlistentry>
		     <term><option>-id</option> <replaceable>vsn</replaceable></term>
		     <listitem>
			<para>
			   Each module has an identifier which, for historical
			   reasons is called a <firstterm>virtual slot number</firstterm>,
			   or <firstterm>vsn</firstterm>.  To maximize the decode
			   error detection the virtual slot numbers for each
			   module should be unique.  This option allows you
			   to set the virtual slot number for the module.
			</para>
		        <para>
			   If the <option>-id</option> is not supplied, it defaults
			   to zero.
			</para>
		     </listitem>
		</varlistentry>
                <varlistentry>
                  <term><option>-sparse</option> <replaceable>bool</replaceable></term>
                  <listitem>
                     <para>
                        If the value of this configuration is true, the module
                        is read in sparse readout mode (A Q-Stop of F4@A0).
                        SpecTcl expects this to be true and that is also the default
                        value.
                     </para>
                     <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                  </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-readhits</option> <replaceable>bool</replaceable></term>
                     <listitem>
                        <para>
                           If the value of this configuration is true,the module's
                           hit register is read prior to the channels (F6@A1).
                           SpecTcl requires this parameter to be true, and that's the
                           default value.
                        </para>
                        <para>
                           SpecTcl will use this value to determine the number of
                           digitizer data words that follow for this module.
                        </para>
                        <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-pedestals</option> <replaceable>int[16]</replaceable></term>
                     <listitem>
                        <para>
                           Supplies the pedestals for each channel.  This must be
                           a 16 element list of integers.  These values are
                           initialized to zero.  Note that the pedestals are
                           ignored unless <option>-usepdestals</option> is true.
                        </para>
                        <para>
                           The best way to construct this list of pedestals is to
                           use the Tcl <command>list</command> command for example:
                        </para>
                        <example>
                           <title>Using the <command>list</command> command to
                                  construct pedestals</title>
                           <programlisting>
                           <command>
ph7xxx config someadc -pedestals [list 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20]
                           </command>
                           </programlisting>
                        </example>
                        <para>
                           Note that pedestals can be specified as decimal values
                           (as shown in the example above), hexadecimal value
                           by preceding a number with the text <literal>0x</literal>
                           or octal by preceding the number with a leading <literal>0</literal>.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-llt</option> <replaceable>int[16]</replaceable></term>
                     <listitem>
                        <para>
                           Supplies the low level thresholds for each channel.  This must
                           be a 16 element list of integers.  These values are initialized
                           to zero.  Note that the low level thresholds are ignored unless
                           <option>-usellt</option> is true.
                        </para>
                        <para>
                           See the description of <option>-pedestals</option> above
                           for more information about how to construct this list.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-hlt</option> <replaceable>int[16]</replaceable></term>
                     <listitem>
                        <para>
                           Supplies the high level thresholds for each channel. This
                           must be a 16 element list of integers.  These values
                           are initialized to full scale (<literal>4095</literal>).
                           The high level thresholds are ignored unless the
                           parameter <option>-usehlt</option> is true.
                        </para>
                        <para>
                           See the description of <option>-pedestals</option>
                           above for more information about how to construct
                           this list.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-usellt</option> <replaceable>boolean</replaceable></term>
                     <listitem>
                        <para>
                           Enables or disables the low level threshold (sets or clears
                           the <literal>LT Enable</literal> bit in the control
                           register).  This is useful if
                           <option>-llt</option> has been used to program
                           low level thresholds and <option>-sparse</option>
                           has been set to true.
                       </para>
                       <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-usehlt</option> <replaceable>bool</replaceable></term>
                     <listitem>
                        <para>
                           Enables or disables the high level threshold (sets or
                           clears the <literal>UT Enable</literal> bit in the
                           module control register).  This is useful if
                           <option>-hlt</option> has been used to set the high
                           level thresholds and <option>-sparse</option> has
                           been set to true.
                        </para>
                       <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>, 
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-usepedestals</option> <replaceable>bool</replaceable></term>
                     <listitem>
                        <para>
                           Enables or disables per chanel pedestal subtraction.
                           This is most useful when <option>-pedestals</option>
                           has been used to program a set of pedestals into
                           the module.
                        </para>
                       <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
              </variablelist>
           </refsect1>
           <refsect1>
              <title>EXAMPLES</title>
              <para>
                  The example below creates a Phillips module named
                  <literal>adc1</literal> and programs all of the configuration
                  options.  Note that in many cases you won't need to do this
                  (e.g. for ADC's the high level thresholds usually can be left
                  up at <literal>4095</literal>
              </para>
              <example>
                  <title>Sample <command>ph7xxx</command> commands</title>
                  <programlisting>
ph7xxx create adc1 -slot 5
ph7xxx config adc1 -sparse enabled -readhits true -usellt true -usehlt false
ph7xxx config adc1 -usepedestals enabled
ph7xxx config adc1 -pedestals [list 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 ]
ph7xxx config adc1 -llt [list 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10]
ph7xxx config adc1 -hlt [list 3000 3000 3000 3000 3000 3000 3000 \
                              3000 3000 3000 3000 3000 3000 3000 3000 3000 ]
                  </programlisting>
              </example>
           </refsect1>

         </refentry>
         <refentry id="ccusb3-stack">
           <refmeta>
              <refentrytitle>stack</refentrytitle>
              <manvolnum>3ccusb</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>stack</refname>
              <refpurpose>Create and configure CC-USB stacks.</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>
             <cmdsynopsis>
         	<command>
stack create <replaceable>name</replaceable>

         	</command>
             </cmdsynopsis>
               <cmdsynopsis>
                   <command>
stack config <replaceable>name option value...</replaceable>
                   </command>
               </cmdsynopsis>
            <cmdsynopsis>
                <command>
stack cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
           
           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
         	Creates and configures CC-USB stacks.  Stacks are lists of
                CAMAC operations that are loaded into the CC-USB for autonomous
                execution.  There are two types of stacks; an
                <firstterm>event</firstterm> stack that is executed when
                a front panel trigger or a specified LAM is detected, and
                a <firstterm>scaler</firstterm> stack that can be periodically
                triggered.
              </para>
               <para>
                  Stacks contain lists of modules.  The modules themselves
                  determine the set of readout instructions that make up each
                  stack.  
               </para>
               <para>
                  The <command>create</command> subcommand creates a new stack.
                  The name of the new stack is <replaceable>name</replaceable>.
                  This <replaceable>name</replaceable> will be used to refer to
                  this stack in future configuration commands.
               </para>
               <para>
                  The <command>config</command> subcommand configures the stack
                  <replaceable>name</replaceable>.  The configuration is
                  specified as a set of option value pairs.  The options
                  are described in the section OPTIONS below.
               </para>
               <para>
                  The <command>cget</command> subcommand returns the configuration
                  of the stack <replaceable>name</replaceable> as its command value.
                  This subcommand is intended for advanced applications that may
                  analyze the configuration of the stack.  The configuration is
                  returned as a properly formatted Tcl list.  Each element of the list
                  is itself a two element sublist (pair).  The first element of each
                  pair is the name of a configuration parameter the second, that
                  configuration parameter's value.  Note that the value may itself
                  be a list.
               </para>
           </refsect1>
           <refsect1>
              <title>
         	OPTIONS
              </title>
               <para>
                  Options are used to configure the stack.  Each option has associated
                  with it a keyword that selects it and a value.  The option s supported
                  by the <command>stack</command> command are subdivided into three groups:
                  <orderedlist>
                     <listitem>
                        <para>Options used for both event and scaler stacks.</para>
                     </listitem>
                     <listitem>
                        <para>Options that are only used for event stacks and are ignored
                           for scaler stacks</para>
                     </listitem>
                     <listitem>
                        <para>Options that are only used for scaler stacks, and are
                           ignored for event stacks.
                        </para>
                     </listitem>
                  </orderedlist>
               </para>
               <formalpara>
                  <title>Options for all stack types</title>
                  <para>
                  </para>
               </formalpara>
               <variablelist>
                  <varlistentry>
         	     <term><option>-type</option> <replaceable>stack-type</replaceable></term>
         	     <listitem>
         		<para>
                           Defines the type of stack that is being used.  This
                           can be one of the keywords
                           <literal>event</literal> for event stacks or
                           <literal>scaler</literal> for scaler stacks.
                           The CC-USB only supports one scaler and one event stack.
                           The current version of the configuration engine allows
                           you to create more than one of each stack. In that case,
                           it is not well defined which stacks are actually loaded.
         		</para>
                        <para>
                           The default <option>-type</option> is <literal>event</literal>.
                        </para>
         	     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-modules</option> <replaceable>module-list</replaceable></term>
                     <listitem>
                        <para>
                           This option defines the set of modules that are added
                           to the stack.  <replaceable>module-list</replaceable> is a
                           properly formatted Tcl list of names of modules
                           (ph7xxx's in this implementation) that will be read
                           by this stack.  See the EXAMPLES section below
                           for more information.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
               <formalpara>
                  <title>Event stack options</title>
                  <para>
                  </para>
               </formalpara>
               <variablelist>
                  <varlistentry>
                     <term><option>-lams</option>   <replaceable>mask</replaceable></term>
                     <listitem>
                        <para>
                           Specifies the mask of LAMs that can trigger the list.
                           I suggest leaving this value at zero, and deriving a
                           trigger signal for the NIM IN1 input as the readout
                           trigger.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-lamtimeout</option> <replaceable>microseconds</replaceable></term>
                     <listitem>
                        <para>
                           The <command>ph7xxx</command> command delays the read
                           of the module until it is signalling a LAM.
                           <replaceable>microseconds</replaceable> specifies the
                           total number of microseconds the stack should wait for
                           this LAM.  The value should be on the order of the
                           conversion time of the module.  Defaults to zero.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-delay</option> <replaceable>microseconds</replaceable></term>
                     <listitem>
                        <para>
                           Delays the execution of the stack for <replaceable>microseconds</replaceable>
                           microseconds after the trigger condition is detected.
                           This can be used to ensure the digitization hardware
                           has sufficient time to complete its digitization prior
                           to stack execution. Defaults to zero.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
               <formalpara>
                  <title>Options only available for scalers stacks</title>
                  <para>
                     The options below are only legal for stacks of
                     <option>-type</option> <literal>scaler</literal>
                  </para>
               </formalpara>
               <variablelist>
                  <varlistentry>
                     <term><option>-period</option> <replaceable>seconds</replaceable></term>
                     <listitem>
                        <para>
                           Number of seconds between execution of the scaler stack.
                           This defaults to 2.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
            
           </refsect1>
           <refsect1>
               <title>EXAMPLES</title>
               <para>
                  The example below extends the example in the
                  <xref linkend="ccusb3-ph7xxx" /> command reference
                  reading the defined modules in an event stack:
               </para>
               <example>
                  <title>Example of the <command>stack</command> command.</title>
                  <programlisting>
ph7xxx create adc1 -slot 6
ph7xxx create adc2 -slot 7                                  <co id="defmodules" />


stack create events                                         <co id="stackdef" />
stack config events -type event -modules [list adc1 adc2]   <co id="typemods" />
stack config events -delay 10 -lamtimeout 8                 <co id ="timing" />
                  </programlisting>
               </example>
               <calloutlist>
                  <callout arearefs="defmodules">
                     <para>
                        These two lines define the modules that we will be using
                        for the experimental setup.
                     </para>
                  </callout>
                  <callout arearefs="stackdef">
                     <para>
                        Creates a new stack called <literal>events</literal>
                        In subsequent lines I'm going to configure this stack
                        to handle the event trigger.
                     </para>
                  </callout>
                  <callout arearefs="typemods">
                     <para>
                        The stack is configured to be the event stack, and
                        the two modules we created <literal>adc1</literal>
                        and <literal>adc2</literal> are added to the stack
                        in that order.  When the stack is loaded, it will
                        contain the instructions to read out these two modules.
                     </para>
                  </callout>
                  <callout arearefs="timing">
                     <para>
                        Configures the stack so that the CC-USB will start
                        stack execution 10 microseconds after the IN1 trigger.
                        Stack instructions that wait for a lam on their target
                        module will wait at most 8 microseconds.  Since the
                        <option>-lams</option> option is left to default to zero,
                        CAMAC lams will not be able to trigger the list.
                     </para>
                  </callout>
               </calloutlist>
               
                  
           </refsect1>
         </refentry>
      <refentry id="ccusb3-Module">
        <refmeta>
           <refentrytitle>Module</refentrytitle>
           <manvolnum>3ccusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Module</refname>
           <refpurpose>Create and manipulate slow control device instances</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
         <command>
Module create <replaceable>type name</replaceable>
          </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
Module config <replaceable>name options....</replaceable>
            </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
Module cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The Module command creates and manipulates instances of slow
            control devices.  It must appear in the control configuration script
            rather than the daq configuration script.  The <command>create</command>
            subcommand creates an object with the specified <parameter>type</parameter>
            and <parameter>name</parameter>.  Currently the following device types
            are supported:
            <variablelist>
                <varlistentry>
                    <term>caen894</term>
                    <listitem>
                        <para>
                            A CAEN C894 16 channel leading edge discriminator.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>ph7106</term>
                    <listitem>
                        <para>
                            A Phillips Ph7106 leading edge discriminator.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </para>
           <para>
            The <command>config</command> subcommand configures the named module.
            In most cases the configuration of a slow control module is pretty
            minimal as the assumption is that there is a slow control
            panel associated with the device.  Typical configuration consists
            of a <option>-slot</option> which provides the CAMAC slot in which
            the module is installed and a <option>-file</option> which provides
            the initial settings of the device (the file is usually maintained
            by the control panel).  Note that the <literal>ph7106</literal>
            currently only supports the <option>-slot</option> option.
            (This code was contributed by Lakshmi SoundaraPandian of the
            University of Massachussets Lowell).
           </para>
           <para>
                The <command>cget</command> subcommand retrieves the
                configuration of the named modules as a
                well formatted Tcl list of name
                value pairs where the name is an option name and the value is
                the value of that option. e.g.
                <informalexample>
                    <programlisting>
{ {-slot 5} {-file /user/fox/config.camac/led.settings}}
                    </programlisting>
                </informalexample>
            </para>
        </refsect1>

      </refentry>
      <refentry id="ccusb3-ControlProtocol">
        <refmeta>
           <refentrytitle>Slow controls protocol</refentrytitle>
           <manvolnum>3ccusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Slow controls protocol</refname>
           <refpurpose>TCP/IP slow control protocol</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
Update <replaceable>name</replaceable>               
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
Set <replaceable>name parameter value</replaceable>
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
Get <replaceable>name parameter</replaceable>
            </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The protocol which communicates with the slow control server is
            a set of commands that are submitted to a Tcl interpreter that
            is running in the server.  Three commands result in
            dispatch to slow controls drivers.  If the run is active, the dispatch
            to the driver functions is preceeded by pausing the run and
            succeeded by resuming the run.  This allows driver functions
            unimpeded access to the CCUSB.
           </para>
           <para>
            Each driver is assumed to implement a set of named parameters.
            These parameters have values which are passed to and from the
            driver without interpretation.  Commands that result errors return
            strings to the client that begin with the text <literal>ERROR - </literal>
            with an english error message appended to that prefix.
           </para>
        </refsect1>
        <refsect1>
           <title>
              SUBCOMMANDS
           </title>
           <variablelist>
                <varlistentry>
                    <term>Update <replaceable>name</replaceable></term>
                    <listitem>
                        <para>
                            Asks the driver for the instance <replaceable>name</replaceable>
                            to update any internal state it maintains from the
                            device or, alternatively, depending on the driver
                            refresh any device state from internal state.
                            Normally this is used for devices that have write-only
                            registers, for those devices, typically the driver
                            must retain some concept of what it believes the
                            state of the physical device is.  This command is
                            then used to ensure the actual state of the device
                            matches the believed state.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Set <replaceable>name parameter-name value</replaceable></term>
                    <listitem>
                        <para>
                            Note the capital S in <command>Set</command> to
                            distinguish it from the similar Tcl command.
                            This command is used by a client to alter
                            a parameter value.  <replaceable>name</replaceable>
                            is the name of a Module instance,
                            <replaceable>parameter-name</replaceable> is the
                            name of a parameter maintained by the driver for
                            that device and <replaceable>value</replaceable> is
                            the new requested value for the parameter.
                        </para>
                        <para>
                            On success the client is returned a line containing
                            the string <literal>OK</literal> otherwise
                            <literal>ERROR -</literal> along with a message
                            is returned as describedin DESCRIPTION above.
                        </para>
                        <para>
                            Note that the legal parameter names and their legal
                            values are soley determined by the device driver.
                            See the device specific sections below for
                            more information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Get <replaceable>name parameter-name</replaceable></term>
                    <listitem>
                        <para>
                            Returns the value of the parameter
                            <replaceable>parameter-name</replaceable> from
                            the Module instance <replaceable>name</replaceable>.
                            If this is successful, the value of the parameter
                            will be returned to the client.  Otherwise a line
                            beginnning with <literal>ERROR - </literal> will
                            be returned along with a textual error message.
                        </para>
                    </listitem>
                </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
            <title>PARAMETERS FOR SUPPORTED DEVICES</title>
            <refsect2>
                <title>ph7106</title>
                <para>
                    The following parameters are supported by the
                    driver for the Phillips PH7106 leading edge
                    discriminator.  As this device has read/write
                    registers, <command>Update</command> is a no-op
                    and the <command>Get</command> operation fetches
                    state directly from the device.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>threshold</literal></term>
                        <listitem>
                            <para>
                                Represents the single module threshold.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>mask</literal></term>
                        <listitem>
                            <para>
                                Represents the module mask parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>mode</literal></term>
                        <listitem>
                            <para>
                                Represents the control mode of the device.
                                this can be one of <literal>camac</literal>
                                or <literal>local</literal>.  This parameter
                                is read-only and represents the state of a
                                switch on the module front panel.
                                If the module is in <literal>local</literal>
                                mode, no changes can be made by CAMAC
                                operations.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
        
            </refsect2>
            <refsect2>
                <title>caen894</title>
                <para>
                    The following parameters are suppoerted by the
                    CAEN C894 device support.  These are all read/write
                    parameters, although Get accesses internal driver
                    memory of the last settings done as the actual
                    hardware is write-only.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>threshold</literal><replaceable>n</replaceable></term>
                        <listitem>
                            <para>
                                Represents the value of the threshold for
                                channel <replaceable>n</replaceable> e.g.
                                <literal>threshold10</literal> represents
                                the threshold value for channel 10.
                                Thresholds number from <literal>[0-15]</literal>
                                and have values between <literal>[0-255]</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>width</literal><replaceable>n</replaceable></term>
                        <listitem>
                            <para>
                                Represents the output width of channel
                                <replaceable>n</replaceable>.  Legal values
                                are in the range <literal>[0-255]</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>inhibits</literal></term>
                        <listitem>
                            <para>
                                Represents the module inhibits mask.
                                This 16 bit value has one bit for each channel.
                                The least significant bit represents channel 0
                                the most significant bit channel 15.
                                Set bits represent channnels that are inhibited.
                            </para>
                        </listitem>
                    </varlistentry> 
                    <varlistentry>
                        <term><literal>majority</literal></term>
                        <listitem>
                            <para>
                                Represents the majority level.  This value
                                is in the range <literal>[1-20]</literal>
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                </refsect2>
        </refsect1>
      </refentry>
         
	 <refentry id="ccusb3-CCCUSB">
       <refmeta>
          <refentrytitle>CCCUSB</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CCCUSB</refname>
          <refpurpose>Provide access to a CC-USB device.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <programlisting>
        <synopsis>
            class <ooclass><classname>CCCUSB</classname></ooclass> {
            <methodsynopsis>
                <modifier>static</modifier>
                <type>std::vector&lt;struct usb_device*&gt;</type>
                <methodname>enumerate</methodname>
                <void />
            </methodsynopsis>
            
            <methodsynopsis>
                <modifier>static</modifier>
                <type>std::string</type>
                <methodname>serialNo</methodname>
                <methodparam>
                    <type>struct usb_device*</type><parameter>dev</parameter>
                </methodparam>
            </methodsynopsis>
            
           <constructorsynopsis>
          <methodname>CCCUSB</methodname>
          <methodparam>
            <type>struct usb_device*</type><parameter>vmUsbDevice</parameter>
          </methodparam>
           </constructorsynopsis>
            <methodsynopsis>
              <type>void</type>
              <methodname>writeActionRegister</methodname>
              <methodparam>
                <type>uint16_t</type> <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <methodsynopsis>
              <type>CCCUSBReadoutList*</type>
              <methodname>createReadoutList</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
              <type>int</type>
              <methodname>simpleWrite16</methodname>
              <methodparam>
                <type>int</type><parameter>n</parameter>
              </methodparam>
              <methodparam>
                <type>int</type><parameter>a</parameter>
              </methodparam>
              <methodparam>
                <type>int</type><parameter>f</parameter>
              </methodparam>
              <methodparam>
                <type>uint16_t</type><parameter>data</parameter>
              </methodparam>
              <methodparam>
                <type>uint16_t&amp;</type><parameter>qx</parameter>
              </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleWrite24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleRead16</methodname>
                <methodparam>
                    <type>int</type><parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleRead24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t&amp;</type><parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleControl</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readFirmware</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readGlobalMode</methodname>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeGlobalMode</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDelays</methodname>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDelays</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>  <methodname>readScalerControl</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeScalerControl</methodname>
                <methodparam>
                    <type>uint32_t</type><parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readLedSelector</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeLedSelector</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readOutputSelector</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeOutputSelector</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDeviceSourceSelectors</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type><parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDeviceSourceSelectors</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDGGA</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDGGB</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDGGExt</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDGGA</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDGGB</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDGGExt</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readScalerA</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readScalerB</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readLamTriggers</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeLamTriggers</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readUSBBulkTransferSetup</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeUSBBulkTransferSetup</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>c</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>z</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>inhibit</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>uninhibit</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>executeList</methodname>
                <methodparam>
                    <type>CCCUSBReadoutList&amp;</type> <parameter>list</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type><parameter>pReadBuffer</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type><parameter>readBufferSize</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t*</type><parameter>bytesRead</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>loadList</methodname>
                <methodparam>
                    <type>uint8_t</type><parameter>listNumber</parameter>
                </methodparam>
                <methodparam>
                    <type>CCCUSBReadoutList&amp;</type><parameter>list</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>usbRead</methodname>
                <methodparam>
                    <type>void*</type> <parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>bufferSize</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t*</type><parameter> transferCount</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>timeout</parameter>
                    <initializer> 2000</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setDefaultTimeout</methodname>
                <methodparam>
                    <type>int</type> <parameter>ms</parameter>
                </methodparam>
            </methodsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::startDAQ</varname><initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::usbTrigger</varname><initializer>2</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::clear</varname><initializer>4</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::scalerDump</varname><initializer>0x10</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::revisionMask</varname>
                <initializer>0xff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::revisionShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::yearMask</varname>
                <initializer>0xf00</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::yearShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::monthMask</varname>
                <initializer>0xf000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::monthShift</varname><initializer> 12</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLenMask</varname>
                <initializer>0xf</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLenShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen4K</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen2K</varname>
                <initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen1K</varname>
                <initializer>2</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen512</varname>
                <initializer>3</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t </type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen256</varname>
                <initializer>4</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen128</varname>
                <initializer>5</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen64</varname>
                <initializer>6</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLenSingle</varname>
                <initializer>7</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::mixedBuffers</varname>
                <initializer>0x20</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::doubleHeader</varname>
                <initializer>0x100</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::enableSecondary</varname>
                <initializer>0x1000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::triggerDelayMask</varname>
                <initializer>0xff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::triggerDelayShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::lamTimeoutMask</varname>
                <initializer>0xff00</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::lamTimeoutShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::eventsCountMask</varname>
                <initializer>0xffff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::eventsCountShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::timeIntervalMask</varname>
                <initializer>0xff0000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::timeIntervalShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            
            <!--
   // Red LED: -->
            <fieldsynopsis>
                <modifier>static const</modifier>
                <type>uint32_t</type> <varname>CCCUSB::LedSourceRegister::redEventTrigger</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redBusy</varname>
                <initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redUSBOutFifoNotEmpty</varname>
                <initializer>2</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redUSBInFifoNotEmpty</varname>
                <initializer>3</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redInvert</varname>
                <initializer>0x10</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redLatch</varname>
                <initializer>0x20</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <!--
    // Green LED: -->
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenAcquire</varname>
                <initializer>(0 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenNimI1</varname>
                <initializer>(1 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenUSBInFifoNotEmpty</varname>
                <initializer>(2 &lt;&lt; greenShift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenUSBTrigger</varname>
                <initializer>(3 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenInvert</varname>
                <initializer>(0x10 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenLatch</varname>
                <initializer>(0x20 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <!--
    // Red LED: -->
        
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowShift</varname>
                <initializer>= 16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowNimI2</varname>
                <initializer>(0 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowNimI3</varname>
                <initializer>(1 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowBusy</varname>
                <initializer>(2 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowUsbInFifoNotEmpty</varname>
                <initializer>(3 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowInvert</varname>
                <initializer>(0x10 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowLatch</varname>
                <initializer>(0x20 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
    
            <!-- Output source selection register -->
            

<!--    // NIM O1 source: -->

            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Shift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Busy</varname>
                <initializer>(0 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Event</varname>
                <initializer>(1 &lt;&lt; nimO1Shift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1DGGA</varname>
                <initializer>(2 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1DGGB</varname>
                <initializer>(3 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Invert</varname>
                <initializer>(0x10 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Latch</varname>
                <initializer>(0x20 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>

 <!--   // NIM O2 source:   -->
 
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Shift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Acquire</varname>
                <initializer>(0 &lt;&lt;nimO2Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Event</varname>
                <initializer>(1 &lt;&lt; nimO2Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2DGGA</varname>
                <initializer>(2 &lt;&lt; nimO2Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2DGGB</varname>
                <initializer>3 &lt;&lt; nimO2Shift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Invert</varname>
                <initializer>(0x10 &lt;&lt; nimO2Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Latch</varname>
                <initializer>(0x20 &lt;&lt; nimO2Shift)</initializer>
            </fieldsynopsis>

<!--    // NIM O3 source:  -->

            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3Shift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>nimO3BusyEnd</varname>
                <initializer>(0 &lt;&lt; nimO3Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3Busy</varname>
                <initializer>(1 &lt;&lt; nimO3Shift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3DGGA</varname>
                <initializer>(2 &lt;&lt; nimO3Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3DGGB</varname>
                <initializer>(3 &lt;&lt; nimO3Shift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3Invert</varname>
                <initializer>(0x10 &lt;&lt; nimO3Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3Latch</varname>
                <initializer>(0x20 &lt;&lt; nimO3Shift)</initializer>
            </fieldsynopsis>         
    <!-- DeviceSourceSelectorsRegister - -->
    
   <!-- // Scaler A source/control -->
   
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAShift</varname>
                <initializer>0</initializer>
                </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADisabled</varname>
                <initializer>(0 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerANimI1</varname>
                <initializer>(1 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerANimI2</varname>
                <initializer>(2 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerANimI3</varname>
                <initializer>(3 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEvent</varname>
                <initializer>(4 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAScalerBCarry</varname>
                <initializer>(5 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier>
                <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGA</varname>
                <initializer>(6 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGB</varname>
                <initializer>(7 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEnable</varname>
                <initializer>(0x10 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAReset</varname>
                <initializer>(0x20 &lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAFreeze</varname>
                <initializer>(0x40 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            
            <!-- // Scaler B source/control -->
            
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>scalerBShift</varname><initializer> 8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDisabled</varname>
                <initializer>(0 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t </type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBNimI1</varname>
                <initializer>(1 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBNimI2</varname>
                <initializer>(2 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBNimI3</varname>
                <initializer>(3 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEvent</varname>
                <initializer>(4 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>int32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBScalerACarry</varname>
                <initializer>(5 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGA</varname>
                <initializer>(6 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGB </varname>
                <initializer>(7 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t </type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEnable</varname>
                <initializer>(0x10 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBReset</varname>
                <initializer>(0x20 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBFreeze</varname>
                <initializer>(0x40 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            
            <!-- // DGGA source -->
            
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGAShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGADisabled</varname>
                <initializer>(0 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGANimI1</varname>
                <initializer>(1 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGANimI2</varname>
                <initializer>(2 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGANimI3</varname>
                <initializer>(3 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGAEvent</varname>
                <initializer>(4 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGABusyEnd</varname>
                <initializer>(5 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGAUSBTrigger</varname>
                <initializer>(6 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGAPulser</varname>
                <initializer>(7 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>

            <!--  // DGGB source -->
            
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBShift</varname>
                <initializer>24</initializer>
                </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBDisabled </varname>
                <initializer>(0 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBNimI1</varname>
                <initializer>(1 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBNimI2</varname>
                <initializer>(2 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBNimI3</varname>
                <initializer>(3 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBEvent</varname>
                <initializer>(4 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBBusyEnd</varname>
                <initializer>(5 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBUSBTrigger</varname>
                <initializer>(6 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBPulser</varname>
                <initializer>(7 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>    



            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayMask</varname>
                <initializer>0xffff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthMask</varname>
                <initializer>0xffff0000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::ACoarseMask</varname>
                <initializer>xffff;</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::ACoarseShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::BCoarseMask</varname>
                <initializer>0xffff0000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::BCoarseShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCCUSB::TransferSetupRegister::multiBufferCountMask</varname>
                <initializer>0xff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t </type>
                <varname>CCCCUSB::TransferSetupRegister::multiBufferCountShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCCUSB::TransferSetupRegister::timeoutMask</varname>
                <initializer>0xf00</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCCUSB::TransferSetupRegister::timeoutShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::Q</varname>
                <initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::X</varname>
                <initializer>2</initializer>
            </fieldsynopsis>
            };
       </synopsis>
        </programlisting>   
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            The <classname>CCCUSB</classname> class represents a connection
            to a CC-USB controller.  The static members <methodname>enumerate</methodname>
            and <methodname>serialNo</methodname> allow programs to become
            aware of the set of interfaces that are currently plugged in
            and powered up, and to associated them with serial number strings.
          </para>
          <para>
            Constructing an object around a specific <classname>usb_device*</classname>
            allows you to interact with the device represented by that struct.
            The class exports a rich set of methods which are described in the
            METHODS section below.  Bits and bit fields are defined as class
            constants described in PUBLIC VARIABLES, TYPES and CONSTANTS below.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <para>
            In the functions listed below, any function that returns an <type>int</type>
            returns <literal>0</literal> on success, <literal>-1</literal> if
            the write operation to the device failed or <literal>-2</literal>
            if the read operation failed.  Negative values result in the
            <varname>errno</varname> variable set to the actual reason for the
            failure.
          </para>
            <variablelist>
                <varlistentry>
                    <term><methodsynopsis><modifier>static</modifier>
                    <type>std::vector&lt;struct usb_device*&gt;</type>
                    <methodname>enumerate</methodname>
                    <void /></methodsynopsis></term>
                    <listitem>
                        <para>
                            Enumerates the set of CC-USB devices that are attached
                            and powered up on the host.  The return value
                            is a vector of <classname>usb_device*</classname> pointers
                            each of which represents one of those devices.
                        </para>
                        <para>
                            You can use a <classname>usb_device*</classname> pointer
                            to construct a <classname>CCCUSB</classname> object
                            or to query the serial number of that device.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodsynopsis><modifier>static</modifier>
                        <type>std::string</type>
                        <methodname>serialNo</methodname>
                        <methodparam>
                            <type>struct usb_device*</type><parameter>dev</parameter>
                        </methodparam></methodsynopsis> </term>
                    <listitem>
                        <para>
                            Returns the serial number string for the CC-USB
                            represented by the <parameter>dev</parameter>
                            parameter.  <parameter>dev</parameter> should have
                            been gotten from a call to <function>CCCUSB::enumerate</function>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constructorsynopsis>
                    <methodname>CCCUSB</methodname>
                    <methodparam>
                      <type>struct usb_device*</type><parameter>vmUsbDevice</parameter>
                    </methodparam>
                     </constructorsynopsis></term>
                    <listitem>
                        <para>
                            Constructs a <classname>CCCUSB</classname> object.
                            The resulting object can be used to communicate
                            with the CC-USB represented by the
                            <parameter>vmUsbDevice</parameter> object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                        <type>void</type>
                        <methodname>writeActionRegister</methodname>
                        <methodparam>
                          <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                      </methodsynopsis></term>
                    <listitem>
                        <para>
                            Writes the CCUSB's action register. The class also
                            supplies symoblic definitions for bits in the action
                            register.  See the Action register section of 
                            PUBLIC VARIABLES, TYPES and CONSTANTS below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                         <type>CCCUSBReadoutList*</type>
                         <methodname>createReadoutList</methodname>
                         <void />
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates an empty readout list. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                         <type>int</type>
                         <methodname>simpleWrite16</methodname>
                         <methodparam>
                           <type>int</type><parameter>n</parameter>
                         </methodparam>
                         <methodparam>
                           <type>int</type><parameter>a</parameter>
                         </methodparam>
                         <methodparam>
                           <type>int</type><parameter>f</parameter>
                         </methodparam>
                         <methodparam>
                           <type>uint16_t</type><parameter>data</parameter>
                         </methodparam>
                         <methodparam>
                           <type>uint16_t&amp;</type><parameter>qx</parameter>
                         </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a CAMAC write operations with a
                            16 bit wide data transfer.
                            The parameters <parameter>n,a,f</parameter>
                            specify the slot, subaddress and function code
                            respectively while the <parameter>data</parameter>
                            parameter provides the data to write.  The
                            <parameter>qx</parameter> parameter receives a
                            bit encoding of the Q and X responses of the
                            operation.  See PUBLIC VARIABLES, TYPES and CONSTANTS
                            for the <varname>CCCUSB::Q</varname> and
                            <varname>CCCUSB::X</varname> bit field definitions.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>simpleWrite24</methodname>
                            <methodparam>
                                <type>int</type> <parameter>n</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>a</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>f</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t</type> <parameter>data</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>qx</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>simpleWrite16</methodname> above,
                            however the least significant 24 bits of
                            <parameter>data</parameter> are written.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                           <type>int</type> <methodname>simpleRead16</methodname>
                           <methodparam>
                               <type>int</type><parameter>n</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int</type> <parameter>a</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int</type><parameter>f</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint16_t&amp;</type> <parameter>data</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint16_t&amp;</type> <parameter>qx</parameter>
                           </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a 16 bit read from a CAMAC module.
                            <parameter>n,a,f</parameter> define the slot, subaddress and
                            function code respectively while <parameter>data</parameter>
                            will receive the data from the operation.
                            <parameter>qx</parameter> will contain a
                            bit encoding of the dataway Q and X responses.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                       <methodsynopsis>
                        <type>int</type> <methodname>simpleRead24</methodname>
                        <methodparam>
                            <type>int</type> <parameter>n</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int</type> <parameter>a</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int</type> <parameter>f</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t&amp;</type><parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint16_t&amp;</type> <parameter>qx</parameter>
                        </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>simpleRead16</methodname>, however the data
                            transfer is 24 bits.  These are placed in the least
                            significant 24 bits of <parameter>data</parameter>.
                            The top 8 bits are zeroed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>simpleControl</methodname>
                            <methodparam>
                                <type>int</type> <parameter>n</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>a</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type><parameter>f</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>qx</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs the non-data transfer operation (control
                            function) specified by <parameter>n,a,f</parameter>.
                            As usuall the dataway Q and X responses are stored
                            in the <parameter>qx</parameter> parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readFirmware</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the firmware id register storing it in the
                            <parameter>value</parameter> parameter.  This field
                            is bit encoded.  See the Firmware Register
                            subsection of PUBLIC VARIABLES, TYPES and CONSTANTS
                            below for symbols that allow you to extract the
                            firmware register fields.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readGlobalMode</methodname>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the global mode register of the CC-USB.
                            The value of that register is stored in the
                            <parameter>value</parameter> parameter.  The
                            global mode register consists of several bits and
                            bit fields.  See the Global Mode subsection of
                            PUBLIC VARIABLES, TYPES and CONSTANTS below for
                            symbolic definitions of those bits and bit fields.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeGlobalMode</methodname>
                            <methodparam>
                                <type>uint16_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes the global mode register so that it contains
                            <parameter>value</parameter>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDelays</methodname>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the delays register into <parameter>value</parameter>.
                            The delays register contains bit fields that control
                            the trigger delay and lam timeout of lam waits.
                            See the Delays Register section of
                            PUBLIC VARIABLES, TYPES and CONSTANTS below
                            for symbolic definitions of this register's contents.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type>
                        <methodname>writeDelays</methodname>
                        <methodparam>
                            <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            CC-USB's delays register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type>  <methodname>readScalerControl</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the CC-USB scaler control register into
                            <parameter>value</parameter>.  This regtister contains
                            bit fields that are defined in the
                            Scaler Control Register subsection of
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeScalerControl</methodname>
                            <methodparam>
                                <type>uint32_t</type><parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            scaler control register of the CC-USB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readLedSelector</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the value of the LED selector register
                            into <parameter>value</parameter>.  The
                            LED selector register defines the meaning of the
                            lights on the CC-USB front panel.  The bit field
                            definitions and values are described in
                            LED Selector Register below in
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeLedSelector</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            LED selector register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readOutputSelector</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Read the value of the Output Selector register
                            into <parameter>value</parameter>.  The
                            Output selector register determines the functions
                            of the NIM output connectors on the front panel
                            of the CC-USB.  The bit field and code definitions
                            of this register have symbolic definitions that are
                            described in Output Selector Register in
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeOutputSelector</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Write <parameter>value</parameter> into the
                            output selector register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDeviceSourceSelectors</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type><parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Read the device source selectors register into
                            <parameter>value</parameter>.  This register
                            determines the input sources for various CC-USB
                            onboard resources, specifically the two scalers
                            and two gate generators.  The bit fields in this
                            register are described in
                            Device Source Selector register in
                            PUBLIC VARIABLES, TYPES and CONSTANTS below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDeviceSourceSelectors</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            device source selector register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDGGA</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDGGB</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDGGExt</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These functions read registers that set up the
                            parameters that control the two gate and delay
                            generators in the CC-USB into the <parameter>value</parameter>
                            parameter.  The bit fields definitions for these
                            registers are described in Gate and Delay Generators
                            below in
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDGGA</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDGGB</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDGGExt</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            registers that control the two gate and delay
                            generators in the CC-USB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readScalerA</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>readScalerB</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the current value of scaler A or B internal
                            to the CC-USB into the <parameter>value</parameter>
                            parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readLamTriggers</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the contents of the lam trigger register
                            into <parameter>value</parameter>.
                            The LAM trigger register is a mask of LAMs which
                            if matched by the dataway LAM pattern will trigger
                            the event list.  If zero, readout is triggered by
                            front panel inputs.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeLamTriggers</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Write <parameter>value</parameter> to the LAM trigger
                            register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readUSBBulkTransferSetup</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the value of the USB Bulk transfer register
                            into <parameter>value</parameter>.  The bulk transfer
                            register contains two bit fields which are defined
                            in the USB Bulk Transfer Register under the
                            PUBLIC VARIABLES, TYPES and CONSTANTS section
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeUSBBulkTransferSetup</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            USB Bulk transfer register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>c</methodname>
                            <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a dataway C cycle.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                           <type>int</type> <methodname>z</methodname>
                           <void />
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a data way Z cycle.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>inhibit</methodname>
                            <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the dataway Inhibit line.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>uninhibit</methodname>
                            <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Unsets the dataway Inhibit line.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>executeList</methodname>
                            <methodparam>
                                <type>CCCUSBReadoutList&amp;</type> <parameter>list</parameter>
                            </methodparam>
                            <methodparam>
                                <type>void*</type><parameter>pReadBuffer</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t</type><parameter>readBufferSize</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t*</type><parameter>bytesRead</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a CAMAC list operation in immediate mode.
                            In order to do this data taking mode must not
                            be on.   The <parameter>list</parameter> is built up
                            by constructing a <classname>CCCUSBReadoutList</classname>
                            (see <xref linkend='ccusb3-CCCUSBReadoutList' />)
                            object and using its methods to add the appropriate
                            set of instructions to the list.
                        </para>
                        <para>
                            <parameter>pReadBuffer</parameter> is a pointer to
                            a buffer you have prepared to receive the results
                            of the read operations in the list.  This buffer
                            has <parameter>readBufferSize</parameter> bytes
                            of data.  On successful return,
                            <parameter>bytesRead</parameter> will contain the
                            actual number of bytes transferred into your buffer.
                            On failure (return value other than <literal>0</literal>),
                            the value of <parameter>bytesRead</parameter> is not
                            well defined.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                           <type>int</type> <methodname>loadList</methodname>
                           <methodparam>
                               <type>uint8_t</type><parameter>listNumber</parameter>
                           </methodparam>
                           <methodparam>
                               <type>CCCUSBReadoutList&amp;</type><parameter>list</parameter>
                           </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Loads a list into the CC-USB. The <parameter>listNumber</parameter>
                            must be 0 for the event list and 1 for the scaler list.
                            If it is any value other than this, the function
                            will return <literal>-4</literal>.
                            <parameter>list</parameter>   is the
                            <classname>CCCUSBReadoutList</classname> to load.
                            See <xref linkend='ccusb3-CCCUSBReadoutList' /> for
                            information about this parameter and how to build it.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>usbRead</methodname>
                            <methodparam>
                                <type>void*</type> <parameter>data</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t</type> <parameter>bufferSize</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t*</type><parameter> transferCount</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>timeout</parameter>
                                <initializer>2000</initializer>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pefroms a bulk read on the data transfer endpoint
                            of the CC-USB.  Normally this only needs to be called
                            by the CCUSBReadout framework when in data taking mode.
                            <parameter>data</parameter> is a buffer
                            into which data read should be transferred.
                            <parameter>bufferSize</parameter> is the number
                            of bytes that can be stored in <parameter>buffer</parameter>
                            <parameter>transferCount</parameter> points to a
                            buffer that will contain the number of bytes actually
                            transferred to the buffer. <parameter>timeout</parameter>
                            is the number of milliseconds to wait for the transfer
                            to complete before ending with a timeout condition.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>setDefaultTimeout</methodname>
                            <methodparam>
                                <type>int</type> <parameter>ms</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Most of the immediate operations require a write to the
                            CC-USB followed by a read to get status and/or data.
                            This function allows you to override the default
                            timeout for the read. <parameter>ms</parameter> is
                            the number of milliseconds in the new timeout.
                            Normally you will not need to call this.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>  
       </refsect1>
        <refsect1>
           <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
           <para>
                The <classname>CCCUSB</classname> class exports several
                public constants that provide symbolic constants that help you
                to build up the contents of CC-USB registers.  The subsections
                in this section describe these values for each register.
           </para>
           <refsect2>
            <title>Action Register</title>
            <para>
                The Action register is a write-only register. Setting bit
                patterns in the Action register cause the CC-USB to take
                specific actions.
            </para>
            <variablelist>
                    <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::ActionRegister::startDAQ</varname><initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            When this bit is set, the CC-USB enters data taking
                            mode.  In data taking mode the CC-USB responds to triggers
                            for the Event and Scaler stacks by executing them
                            and buffering their data for read via
                            <methodname>usbRead</methodname>.  Prior
                            to executing immediate actions you must clear this
                            bit and drain any buffered event data from the
                            module.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                           <modifier>static const</modifier> <type>uint16_t</type>
                           <varname>CCCUSB::ActionRegister::usbTrigger</varname><initializer>2</initializer>
                       </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Setting this bit performs a one-time trigger
                            of the event readout list.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::ActionRegister::clear</varname><initializer>4</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This bit is "intended primarily for use during
                            firmware debugging" it should not be set by
                            ordinary users like us.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::ActionRegister::scalerDump</varname><initializer>0x10</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Setting this bit triggers execution of the scaler
                            list.
                        </para>
                    </listitem>
                </varlistentry>    
            </variablelist>
            <para>
                Note that all bits except the <varname>startDAQ</varname> are
                one-shots that automatically reset after 150ns.
            </para>
           </refsect2>
           <refsect2>
            <title>Firmware Register</title>
            <para>
                This register contains the current revision of the device
                firmware.  This is a set of bit fields in a 32 bit word:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::revisionMask</varname>
                            <initializer>0xff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::revisionShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These two value define the revision field.
                            If <varname>d</varname> contains the
                            firmware revision register, you can extract
                            the revisionfield by performing:
                            <informalexample>
                                <programlisting>
uint32_t revision = (d &amp; CCCUSB::FirmwareRegister::revisionMask)
                    >> CCCUSB::FirmwareRegister::revisionShift;
                                </programlisting>
                            </informalexample>
                        </para>
                        <para>
                            The remaining fields are defined in this way,
                            by a mask and a shift count.  Analagous operations
                            can be used to extract  the value of the
                            field given the full firmware revision register
                            value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::yearMask</varname>
                            <initializer>0xf00</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::yearShift</varname>
                            <initializer>8</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the field that gives the year in which the
                            firmware version was finalized.
                            The manual does not define what a <literal>0</literal>
                            in this field means.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::monthMask</varname>
                            <initializer>0xf000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::monthShift</varname><initializer> 12</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the month field.  This field contains
                            the month in which the firmware was finalized.
                            Presumably this is a value between
                            <literal>[1..12]</literal>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Global Mode Register</title>
            <para>
                The global mode register is described in section 3.3.2 of the
                CC-USB manual.  This register can be built up by bitwise
                or-ing together the values described in this section.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLenMask</varname>
                            <initializer>0xf</initializer>
                        </fieldsynopsis>
                    </term>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLenShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These values define the field in the global mode
                            register that sets the lengt of the data buffer
                            produced by the CC-USB.
                        </para>
                        <para>
                            For actual values you can or into the register
                            see the fields bufferLenxx below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen4K</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects buffers that are <literal>4096</literal>
                            <classname>uint16_t</classname> units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen2K</varname>
                            <initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of <literal>2048</literal>
                            <classname>uint16_t</classname> units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen1K</varname>
                            <initializer>2</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of
                            <literal>1024</literal>   <classname>uint16_t</classname>
                            units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen512</varname>
                            <initializer>3</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of
                            <literal>512</literal> <classname>uint16_t</classname>
                            units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t </type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen256</varname>
                            <initializer>4</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of
                            <literal>256</literal> <classname>uint16_t</classname>
                            units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen128</varname>
                            <initializer>5</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use  a <literal>128</literal> <classname>uint16_t</classname>
                            unit large output buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen64</varname>
                            <initializer>6</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use a <literal>64</literal> <classname>uint16_t</classname>
                            unit large output buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLenSingle</varname>
                            <initializer>7</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use a buffer that holds only a single event.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::mixedBuffers</varname>
                            <initializer>0x20</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Mix scaler and event data together in the same scaler
                            buffer.  If zero, buffers are homogenous with respect
                            to the stack that contributes data to them.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::doubleHeader</varname>
                            <initializer>0x100</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If set the buffer header will include a second
                            word that contains the number of words in the
                            buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::enableSecondary</varname>
                            <initializer>0x1000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If set, CAMAC bus arbitration is enabled, allowing
                            the use of an Auxiliary crate controller.
                            In this case you must cable the Aux controller
                            to request mastership via RQ, GIN, and GOUT
                            signals on the front of the controller.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Delay Register</title>
            <para>
                This register has fields for controlling the delay between the trigger
                and stack execution as well as the LAM timeout interval.
                Both fields are in units of microseconds.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::triggerDelayMask</varname>
                            <initializer>0xff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::triggerDelayShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                           Mask and shift counts for the trigger delay field.
                           This field controls the amount of time between
                           the receipt of a trigger and execution of the
                           event stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::lamTimeoutMask</varname>
                            <initializer>0xff00</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::lamTimeoutShift</varname>
                            <initializer>8</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Mask and shift counts for the lam timeout field.
                            This field controls the number of microseconds
                            stack lines with the <literal>LM</literal> (lam
                            wait mode) bit set will wait for a LM from the
                            station specified.
                        </para>
                    </listitem>
                </varlistentry>     
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Scaler Control register</title>
            <para>
                The manual (3.3.4) refers to this as tyhe ACS control register,
                its function, however is to determine when the scaler
                (Auxilliary stack) is triggered.
                There are two fields. Both can be non-zero allowing for two
                trigger conditions.  One trigger condition allows scalers to
                be triggered after a fixed number of events have been read.
                The second condition allows readout of scalers at fixed time
                intervals.
            </para>
            <para>
                If a field is zero, that trigger condition is disabled.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::eventsCountMask</varname>
                            <initializer>0xffff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::eventsCountShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Define the field that controls scaler triggers
                            every fixed number of events.  If this field is
                            non zero, it specifies the number of events
                            between scaler reads.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type> uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::timeIntervalMask</varname>
                            <initializer>0xff0000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::timeIntervalShift</varname>
                            <initializer>16</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the field that sets up the time periodic
                            trigger.  If this is nonzero, it represents the
                            scaler readout period in 0.5second units.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>LED Source Register</title>
            <para>
                This register contains a set of bit fields that describe
                the signal source that lights each of the LEDs on the front
                panel.  Normally this register will be written with a logical
                or of values of one item from each bit field.  The fields
                are named after the colors of the LED each field controls.
            </para>
            <note>
                <title>Firmware changes</title>
                <para>
                    It appears that these definitions are for firmware
                    revisions &lt; 1.01.  These definitions will be updated
                    in the future to reflect the updated definitions.
                </para>
            </note>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>  <type> uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redEventTrigger</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The red LED will light on an event trigger.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redBusy</varname>
                            <initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The red led will light when the CC-USB is busy.
                            Busy means that the CC-USB is processing the event
                            or scaler stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redUSBTrigger</varname>
                            <initializer>2</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED when the software requests a USB
                            trigger of the event stack by writing the
                            <varname>CCCUSB::ActionRegister::usbTrigger</varname>
                            bit to the action register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redUSBOutFifoNotEmpty</varname>
                            <initializer>3</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED whenever the USB output fifo
                            is not empty.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redUSBInFifoNotFull</varname>
                            <initializer>4</initializer>
                        </fieldsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Lights the red led whenever the USB input fifo is not
                            ful.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redAcquire</varname>
                            <initializer>6;</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED when acquisition mode is turned on
                            (that is the last write to the action register
                            set the
                            <varname>CCCUSB::ActionRegister::startDAQ</varname> bit).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redCAMACF2</varname>
                            <initializer>7</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED whenever the 2's bit is set in the
                            current CAAMC function being performed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redInvert</varname>
                            <initializer>0x10</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the state of the read LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redLatch</varname>
                            <initializer>0x20</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            When the trigger condition for the led exists, latches the
                            led on until this bit is toggled off then on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenAcquire</varname>
                            <initializer>0x000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the green LED when data acquisition is enabled.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenCAMACF1</varname>
                            <initializer>0x100</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the green LED whe the F1 line is set on the last
                            CAMAC operation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenEventTrigger</varname>
                            <initializer>0x300</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Turns on the green LED whenever the event trigger is
                            being processed.
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname> CCCUSB::LedSourceRegister::greenCAMACN</varname>
                            <initializer>0x400</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the green LED whhen a CAMAC operation has occured.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenI1</varname>
                            <initializer>0x600</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the green LED if the I1 input has a NIM
                            true presented on it.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenUSBInFifoNotEmpty</varname>
                            <initializer>0x700</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the green LED if the input FIFO is not empty.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenInvert</varname>
                            <initializer>0x1000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Invert the sense of the green led.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenLatch</varname>
                            <initializer>0x2000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Latch the green led.  When the condition to light the
                            LED occurs, the led stays on until this bit is
                            toggled off (and then back on if the latch condition
                            should be re-established).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowI3</varname>
                            <initializer>0x00000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Light the yellow LED if the I3 input is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowBusy</varname>
                            <initializer>0x10000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Ligths the yellow  LED when the CC-USB is busy
                            executing one of the command stacks.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowI2</varname>
                            <initializer>0x20000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Light the Yellow LED when the I2 input is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowCAMACS1</varname>
                            <initializer>0x30000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the yellow LED when the S1 signal on the CAMAC
                            dataway is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowCAMACS2</varname>
                            <initializer>0x40000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the yellow LED when the CAMAC S2 dataway line
                            is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowUSBInFifoNotEmpty</varname>
                            <initializer>0x50000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the Yellow LED when the USB input FIFO
                            is not empty.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowScalerReadout</varname>
                            <initializer>0x60000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the Yellow led when the scaler stack is
                            being executed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowUSBTrigger</varname>
                            <initializer>0x70000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the yellow LED when event stack execution
                            has been requested by a USB write to the Action
                            register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowInvert</varname>
                            <initializer>0x100000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the sense of the Yellow LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowLatch</varname>
                            <initializer>0x200000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables latch mode for the yellow LED.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Output source selection register.</title>
            <para>
                This register has several coded bit fields that select
                which signals are presented at the module nim outputs
                O1, O2, and O3.
            </para>
            <note>
                <title>Firmware &lt; 1.01</title>
                <para>
                    Thie definitions shwon here are only valid for firmware
                    revisions &lt; 1.01.  This section and the header files
                    themselves must be updated to reflect the current
                    reduced set of output functionality.
                </para>
            </note>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1Busy</varname>
                            <initializer>0x000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 is asserted when the CC-USB is executing a stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1EventTrigger</varname>
                            <initializer>0x000001</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Ouptut 1 reflects that an event trigger has been
                            recently received.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1DGGA</varname>
                            <initializer>0x000002</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 reflets the output gate and delay generator A.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1DGGB</varname>
                            <initializer>0x000003</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 reflects the output of gate and delay generator
                            B.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1Latch</varname>
                            <initializer>0x000010M</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 is latched when set until this bit is toggled.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>    <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1Invert</varname>
                            <initializer>0x000020</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 is inverted relative to the code that selets its
                            output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Acquire</varname>
                            <initializer>0x000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Asserts O1 when acquisition mode is turned on via
                            the action register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>   <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Event</varname>
                            <initializer>0x000200</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Turns O2 on when an event trigger has been recently
                            received.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2DGGA</varname>
                            <initializer>0x000400</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reflects the output of gate and delay generator A
                            in the O2 output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2DGGB</varname>
                            <initializer>0x000600</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reflects the output of gate and delay generator B
                            to the O2 output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Latch</varname>
                            <initializer>0x001000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the O2 register in latching mode.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Invert</varname>
                            <initializer>0x002000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the sense of O2.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3EndOfBusy</varname>
                            <initializer>0x000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Asserts O3 when busy ends.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3Busy</varname>
                            <initializer>0x020000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Asserts O3 when the CC-USB is executing a stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3DGGA</varname>
                            <initializer>0x040000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O3 reflects the output of gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternim03DGGB</varname>
                            <initializer>0x060000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O3 reflects the state of gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3Latch</varname>
                            <initializer>0x100000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Latches the state of O3.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3Invert</varname>
                            <initializer>0x200000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the sense of the O3 output.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Device source register</title>
            <para>
                This register contains several fields that control the
                input sources to the scalers and gate and delay generators
                implemented in the CC-USB.  The register contains four fields
                which are called <literal>scalerA</literal>, <literal>scalerB</literal>
                <literal>dggA</literal>  and <literal>dggB</literal>. Typically
                you will bitwise or a code from each of the fields.  In the case
                of the scaler fields there are three bits, <literal>Enable</literal>,
                <literal>Reset</literal>, and <literal>FreezeReg</literal>
                that can also be ored into the codes.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Scale A has no input, effectively disabling it.
                            Note that if code is not use you will need
                            to set the enable bit as well to enable the scaler
                            to count.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI1</varname>
                            <initializer>0x00000001</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I1 as the input to Scaler A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI2</varname>
                            <initializer>0x00000002</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I2 as the input to scaler A.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI3</varname>
                            <initializer>0x00000003</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I3 to be the input to scalerA.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>   <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEvent</varname>
                            <initializer>0x00000004</initializer>
                        </fieldsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Selects the event trigger to be the source for
                            Scaler A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerACarryB</varname>
                            <initializer>0x00000005</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects the carry out of scalerB to increment
                            ScalerA  this allows you to gang ScalerB (LSBs)
                            and Scaler A (MSBs) into a single 48 bit scaler.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGA</varname>
                            <initializer>0x00000006</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Scaler A will count when DGGA snds an output pulse.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGB</varname>
                            <initializer>0x00000007</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Counts scaler A when when DGGB sends an output pulse.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const </modifier><type> uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEnable</varname>
                            <initializer>0x00000010</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables Scaler A to count.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAScalerAReset</varname>
                            <initializer>0x00000020</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Resets scaler A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAFreezReg</varname>
                            <initializer>0x00000040</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Any operation that writes this register with this
                            bit set will not modify the effective code for selecting
                            the inputs for scaler A.  This allows you to enable/disable/clear
                            scaler A without needing to know the actual
                            scaler source.  Note that since there is no
                            corresponding freeze bit for the dggA/B sources this
                            capability is of limited utility.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Directs to inputs to Scaler B.  Note that if another
                            input is used it's still necessary to also set
                            the <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEnable</varname>
                            bit to enable the scaler to count.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI1</varname>
                            <initializer>0x00000100</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            I1 is the input to ScalerB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI2</varname>
                            <initializer>0x00000200</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I2 as the input for Scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI3</varname>
                            <initializer>0x00000300</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selecst I3 as the input for Scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEvent</varname>
                            <initializer>0x00000400</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects the event trigger as the input for
                            scaler B.  Presumably using this allows the scaler
                            to count the number of events acquired.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBCarryA</varname>
                            <initializer>0x00000500</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects the carry from Scaler A as the input to
                            scalerB this enables the use of ScalerA/B as
                            a 48 bit scaler with the LSBs in ScalerA
                            and MSBs in ScalerB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGA</varname>
                            <initializer>0x00000600</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables the output of gate and delay generator A
                            to be the input to scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGB</varname>
                            <initializer>0x00000700</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables the output of gate and delay generator B
                            to be the input of scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEnable</varname>
                            <initializer>0x00001000</initializer>
                            </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This bit can be ored in with the selected Scaler B
                            code values.  It enables scaler B to count.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBReset</varname>
                            <initializer>0x00002000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Resets scaler B
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBFreezeReg</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Freezes the scaler B input selector field.  This
                            allows one to write Reset and Enable bits without
                            disturbing the event source.  Note that you still
                            must regenerate the DGGA and DGGB source selectors.
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggADisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Provides no input signal to Gate and delay generator
                            A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI1</varname>
                            <initializer>0x00010000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I1 front panel input to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI2</varname>
                            <initializer>0x00020000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I2 front panel input to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI3</varname>
                            <initializer>0x00030000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I3 front panel input to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAEvent</varname>
                            <initializer>0x00040000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the event trigger to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAEndOfEvent</varname>
                            <initializer>0x00050000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the inpt of gate and delay generator A when
                            event readout has completed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAUSBTrigger</varname>
                            <initializer>0x00060000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of gate and delay generator A
                            when a USB stack trigger is written to the
                            action register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAPulser</varname>
                            <initializer>0x00070000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of gate and delay generator A
                            from the output of the pulser.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBDisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Provides no input to gate and delay generator B.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI1</varname>
                            <initializer>0x01000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I1 input signal to the input of
                            Gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI2</varname>
                            <initializer>0x02000000</initializer>
                        </fieldsynopsis>
                   </term>
                    <listitem>
                        <para>
                            Routes the I2 input signal to the input of
                            Gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI3</varname>
                            <initializer>0x03000000</initializer>
                        </fieldsynopsis>
                   </term>
                    <listitem>
                        <para>
                            Routes the I3 input signal to the input of
                            Gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBEvent</varname>
                            <initializer>0x04000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Puses the input of gate and delay generator B
                            when an event trigger is processed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBEndOfTrigger</varname>
                            <initializer>0x05000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of DGGB at the end of processing
                            an event trigger.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBUSBTrigger</varname>
                            <initializer>0x06000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of gate and delay generator B
                            when a USB trigger is written to the Actino regsiter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBPulser</varname>
                            <initializer>0x07000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Connects the pulser output to the input of gate
                            and delay generator B
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Gate and delay generator and pulser set up registers.
            </title>
            <para>
                Several registers are used to set the timing of gate and
                delay registers.  The timing parameters for gate and delay
                generator A also determine the timing for the pulser as showin
                in section 3.3.7 of the CC-USB manual.
            </para>
            <para>
                This section describes the bit fields in these registers.
                Each field is descdribed as a mask and shift count.
                The mask removes all extraneous bits from the register except
                the desired field and the shift count, when used to shift the
                result right right justifies the field data.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayMask</varname>
                            <initializer>0xffff</initializer>
                        </fieldsynopsis>                            
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the fine delay field.  See the course delays
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthMask</varname>
                            <initializer>0xffff0000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthShift</varname>
                            <initializer>16</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the gate width field.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::ACoarseMask</varname>
                            <initializer>xffff;</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::ACoarseShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the course delay fields for the a pulser.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::BCoarseMask</varname>
                            <initializer>0xffff0000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::BCoarseShift</varname>
                            <initializer>16</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the B course delay field.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Transfer setup register</title>
            <para>
                This regiseter allows you to read several buffers from the
                CC-USB in a single read, as well as setting a time bound
                on how long before the CC-USB terminates a multibuffer read.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCCUSB::TransferSetupRegister::multiBufferCountMask</varname>
                            <initializer>0xff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type> uint32_t </type>
                            <varname>CCCCUSB::TransferSetupRegister::multiBufferCountShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the number of buffers that can be batched
                            into a single usb_bulk_read request.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type> uint32_t</type>
                            <varname>CCCCUSB::TransferSetupRegister::timeoutMask</varname>
                            <initializer>0xf00</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCCUSB::TransferSetupRegister::timeoutShift</varname>
                            <initializer>8</initializer>
                        </fieldsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Determines the number of seconds after which
                            the CC-USB will terminate a bulk transfer if not
                            all of the buffers determined by themultiBuffer
                            count have been transferred.
                            </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>X and Q</title>
            <para>
                The <parameter>qx</parameter> parameter on the simple
                CAMAC operations allow you access to the dataway
                Q and X lines.  The bit encoding of that parameter is:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::Q</varname>
                            <initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If this bit was set in the <parameter>qx</parameter>
                            parameter, the module asserted a Q on the dataway.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::X</varname>
                            <initializer>2</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If this bit is set in the <parameter>qx</parameter>
                            parameter, the module asserted an X on the dataway.
                        </para>
                    </listitem>
                    </varlistentry>
            </variablelist>
           </refsect2>    
        </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
                <xref linkend='ccusb3-CCCUSBReadoutList' />
            </para>
        </refsect1>
     </refentry>
         
	 <refentry id="ccusb3-CCCUSBReadoutList">
       <refmeta>
          <refentrytitle>CCCUSBReadoutList</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CCCUSBReadoutList</refname>
          <refpurpose>Create lists of CAMAC commands for CC-USB controllers.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            class <ooclass><classname>CCCUSBReadoutList</classname></ooclass> {          
           <constructorsynopsis>
          <methodname> CCCUSBReadoutList</methodname>
          <void />
           </constructorsynopsis>
           <constructorsynopsis>
            <methodname> CCCUSBReadoutList</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CCCUSBReadoutList&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
           </constructorsynopsis>
            <methodsynopsis>
                <type>std::vector&lt;uint16_t&gt;</type>
                <methodname>get</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>size</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>clear</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type><methodname>addWrite16</methodname>
                <methodparam>
                    <type>int</type><parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>data</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addWrite24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>data</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addRead16</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>           
            <methodsynopsis>
                <type>void</type> <methodname>addRead24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addControl</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addQStop</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>max</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addQStop24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>max</parameter>
                </methodparam>

                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addQScan</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>max</parameter>
                </methodparam>                
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addRepeat</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addMarker</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>value</parameter>
                </methodparam>
           </methodsynopsis>
           };
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <classname>CCCUSBReadoutList</classname> provides a class whose instances can
            build up lists (stacks) of CAMAC operations that can either be
            submitted to a CC-USB for direct execution via <methodname>CCCUSB::executeList</methodname>,
            or loaded as an event or scaler stack via <methodname>CCCUSB::loadStack</methodname>.
          </para>
       </refsect1>
       <refsect1>
          <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                       <methodname>CCCUSBReadoutList</methodname>
                       <void />
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a new readout list.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                         <methodname>CCCUSBReadoutList</methodname>
                         <methodparam>
                             <modifier>const</modifier> <type>CCCUSBReadoutList&amp;</type>
                             <parameter>rhs</parameter>
                         </methodparam>
                        </constructorsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Constructs a readout list that will be a duplicate
                            of the readout list in <parameter>rhs</parameter>
                            (Copy construction).
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>std::vector&lt;uint16_t&gt;</type>
                             <methodname>get</methodname>
                             <void /><modifier>const</modifier>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a <type>std::list&lt;uint16_t&gt;</type> where
                            each element of the list is a stack line that has
                            been built up so far.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>size_t</type> <methodname>size</methodname>
                             <void /><modifier>const</modifier>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the number of <type>uint16_t</type>
                            stack lines built so far.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>clear</methodname>
                             <void />
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Clears the stack.  Once this is performed, the object
                            represents an empty stack.
                            </para>
                        </listitem>
                </varlistentry>     
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type><methodname>addWrite16</methodname>
                             <methodparam>
                                 <type>int</type><parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>uint16_t</type> <parameter>data</parameter>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a 16 bit CAMAC write opearation to the list.
                            <parameter>n,a,f</parameter> specify the
                            slot, subaddress and function code respectively.
                            The <parameter>data</parameter> parameter is transferred
                            to the device when the command is executed.
                            Note that this method does not perform any CAMAC operations.
                            The specified operation is simply encoded as stack lines
                            in the object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addWrite24</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>uint32_t</type> <parameter>data</parameter>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>addWrite16</methodname> however
                            the least significant 24 bits of <parameter>data</parameter>
                            will be written when this stack line is executed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addRead16</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            A 16 bit read operation whose slot, subaddress
                            and function code are specified by <parameter>n,a,f</parameter>
                            is encoded as a stack line and added to the list.
                            If the stack line is executed in immediate mode
                            (via <methodname>CCCUSB::executeList</methodname>),
                            the data read will be put in the input buffer passed
                            to that method.  IF the stack line loaded as a scaler
                            or event stack asnd executed in response to the appropriate
                            trigger condition, the data are put in the event buffer.
                        </para>
                        <para>
                            If the <parameter>lamWait</parameter>  parameter is
                            <literal>true</literal> the stack will stall until
                            either the lam timeout period is reached or the
                            slot the operation is directed to signals its LAM.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addRead24</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>addRead16</methodname>, however a
                            <type>uint32_t</type>
                            is put in the buffer (event or buffer given to
                            <methodname>CCCUSB::executeStack</methodname> depending
                            on why the stack is being executed).  The format
                            of the uint32_t is shown in the figure just at the
                            end of chapter 4 of the CC-USB manual:
                            The bottom 24 bits are the data transferred from the
                            module.  Bit 24 is set if there was a Q response
                            and bit 25 is set if there was an X response
                            (bits are numbered from 0 least significant bit
                            is bit 0).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addControl</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a non data transfer operation to the stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addQStop</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a Q-stop block transfer to the stack.  Q-stop
                            operations perform the same <parameter>n,a,f</parameter>
                            read operation until either the module does not
                            return a Q response or until the <parameter>max</parameter>
                            number of transfers specified have been performed.
                            The <parameter>lamWait</parameter> parameter allows
                            you to wait for a LAM from the targe module before
                            doing the transfer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addQStop24</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>addQStop</methodname> except
                            that 24 bits of data are transferred on each
                            operation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addQScan</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a Q-scan (sometimes called an address
                            scan) operation.  <parameter>n,a,f</parameter>
                            specify a starting slot, subaddress and function code.
                            After each operation a is incremented.   The CC-USB
                            documentation does not make it clear if this is a
                            full Q-Scan (ACA) operation as defined by the ESONE
                            block transfer specification.  If this operation is
                            a full address scan, then after each operation, the
                            subaddress is incremented.  If A was 15 or a Q=0
                            response occured, the
                            subaddress should be set to 0 and the slot incremented.
                            This continues until either <parameter>max</parameter>
                            transfers have occured or both Q and X are zero.
                        </para>
                        <para>
                            The documentation only describes the subadress as
                            being incremented so that may be all you can count on
                            for this opertaion.  It also does not provide a statement
                            about what happens when Q=0 or X=0.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addRepeat</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>                             
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a block repeat operation.  The specified
                            CAMAC operation is performed <parameter>max</parameter>
                            times regardless of the X/Q responses.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addMarker</methodname>
                             <methodparam>
                                 <type>uint16_t</type> <parameter>value</parameter>
                             </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The literal word <parameter>value</parameter> is
                            written to the output buffer.
                        </para>
                    </listitem>
                </varlistentry>             

            </variablelist>
       </refsect1>
        <refsect1>
           <title>SEE ALSO</title>
           <para>
            <xref linkend='ccusb3-CCCUSB' />
            </para>
        </refsect1>
    </refentry>
         
    <refentry id="ccusb3-CConfigurableObject">
       <refmeta>
          <refentrytitle>CConfigurableObject</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CConfigurableObject</refname>
          <refpurpose>base class for devices that have a configuration</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            class <ooclass><classname>CConfigurableObject</classname></ooclass> {
           <constructorsynopsis>
          <methodname>CConfigurableObject</methodname>
          <methodparam>
            <type>std::string</type> <parameter>name</parameter>    
          </methodparam>
        </constructorsynopsis>
        <methodsynopsis>
            <type>std::string </type> <methodname>getName</methodname>
            <void /><modifier> const</modifier>
            </methodsynopsis>
        <methodsynopsis>
            <type>std::string</type> <methodname>cget</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>ConfigurationArray</type> <methodname>cget</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>getIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type><parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>unsigned int</type> <methodname> getUnsignedParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>bool</type> <methodname>getBoolParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>double</type> <methodname>getFloatParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>std::vector&lt;int&gt;</type><methodname>getIntegerList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addParameter</methodname>
            <methodparam>
                <type>std::string</type><parameter> name</parameter>
            </methodparam>
            <methodparam>
                <type>typeChecker</type> <parameter>checker</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>clearConfiguration</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>configure</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>low</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>high</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
                </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addBooleanParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer> true</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type><methodname>addEnumParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <modifier>const</modifier> <type>char**</type>
                <parameter>pValues</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type><methodname>addBoolListParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type><parameter>size</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type>   <parameter> defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
            </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addBoolListParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>minLength</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>maxLength</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter> defaultSize</parameter>
                <initializer>-1</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntListParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>size</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
            </methodparam>
            </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntListParameter</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>minlength</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>maxLength</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultSize</parameter>
                <initializer>-1</initializer>
            </methodparam>
            </methodsynopsis>
        <methodsynopsis>
            <type>void</type><methodname>addBooleanParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addEnumParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <modifier>const</modifier> <type>char**</type>
                <parameter>pValues</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addBoolListParameter</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>size</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
         <type> void</type> <methodname>addBoolListParameter</methodname>
         <methodparam>
           <type>std::string</type> <parameter>name</parameter>
         </methodparam>
         <methodparam>
           <type>unsigned</type> <parameter>minLength</parameter>
         </methodparam>
         <methodparam>
           <type>unsigned</type> <parameter>maxLength</parameter>
         </methodparam>
         <methodparam>
            <type>bool</type> <parameter>defaultVal</parameter> 
            <initializer>true</initializer>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultSize</parameter>
            <initializer>-1</initializer>
         </methodparam>
       </methodsynopsis>
       <methodsynopsis>
         <type>void</type> <methodname>addIntListParameter</methodname>
         <methodparam>
            <type>std::string</type> <parameter>name</parameter>
         </methodparam>
         <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
            <initializer>0</initializer>
         </methodparam>
      </methodsynopsis>
      <methodsynopsis>
         <type>void</type> <methodname>addIntListParameter</methodname>
         <methodparam>
            <type>std::string</type> <parameter>name</parameter>
         </methodparam>
         <methodparam>
            <type>unsigned</type> <parameter>minlength</parameter>
         </methodparam>
         <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
            <initializer>0</initializer>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultSize</parameter> 
            <initializer>-1</initializer>
         </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <type>void</type> <methodname>addStringListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultVal</parameter>
            <initializer>""</initializer>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <type>void</type> <methodname>addStringListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>minLength</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultVal</parameter>
            <initializer>""</initializer>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultLength</parameter>
            <initializer>-1</initializer>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isInteger</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>arg</parameter>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isBool</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isEnum</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isBoolList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isIntList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isStringList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>isEnumParameter</type>
        <methodname>makeEnumSet</methodname>
        <methodparam>
            <modifier>const</modifier> <type>char**</type><parameter>values</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>strToBool</methodname>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier> <type>std::pair&lt;typeChecker, void*&gt;</type>
        <varname>TypeCheckInfo</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier>
        <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;</type>
        <varname>ConfigurationArray</varname>
    </fieldsynopsis>
    

      struct  <type>limit</type> {
      <fieldsynopsis>
          <type>bool</type>   <varname>s_checkMe</varname>
      </fieldsynopsis>
      <fieldsynopsis>
          <type>long</type> <varname>s_value</varname>
      </fieldsynopsis>
      <constructorsynopsis>
          <methodname>limit</methodname>
          <void />
      </constructorsynopsis>
      <constructorsynopsis>
          <methodname>limit</methodname>
          <methodparam>
              <type>long</type>    <parameter>value</parameter>
          </methodparam>
      </constructorsynopsis>
    } ;
    <fieldsynopsis>
        <modifier>typedef</modifier>
        <type>std::pair&lt;limit, limit&gt;</type><varname>Limits</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier>
        <type>std::set&lt;std::string&gt;</type> <varname>isEnumParameter</varname>
    </fieldsynopsis>
    typedef struct <type>_ListSizeConstraint</type> {
        <fieldsynopsis>
            <type>limit</type> <varname>s_atLeast</varname>
        </fieldsynopsis>
        <fieldsynopsis>
            <type>limit</type> <varname>s_atMost</varname>
        </fieldsynopsis>
    } <type>ListSizeConstraint</type>
    typedef struct <type>_isListParameter</type> {
      <fieldsynopsis>
        <type>ListSizeConstraint</type> <varname>s_allowedSize</varname>
      </fieldsynopsis>
      <fieldsynopsis>
        <type>TypeCheckInfo</type> <varname>s_checker</varname>
      </fieldsynopsis>
    } <type>isListParameter</type>;
    <fieldsynopsis>
        <modifier>typedef</modifier>
            <type>void</type><varname>(*ConstraintFreer)(void*)</varname>
    </fieldsynopsis>

     typedef struct <type>_DynamicConstraint</type> { 
      <fieldsynopsis>
        <type>ConstraintFreer</type> <varname>s_Releaser</varname>
      </fieldsynopsis>
      <fieldsynopsis>
        <type>void*</type> <varname>s_pObject</varname>
      </fieldsynopsis>
    } <type>DynamicConstraint</type>, <type>*pDynamicConstraint</type>;
  
    struct  <type>flimit</type> {
      <fieldsynopsis>
        <type>bool</type>   <varname>s_checkMe</varname>
      </fieldsynopsis>
      <fieldsynopsis>
        <type>float</type> <varname>s_value</varname>
      </fieldsynopsis>
      <constructorsynopsis>
        <methodname>flimit</methodname><void />
      </constructorsynopsis>    
      <constructorsynopsis>
        <methodname>flimit</methodname>
        <methodparam>
            <type>float</type> <parameter>value</parameter>
        </methodparam>
      </constructorsynopsis>    
    };
    <fieldsynopsis>
        <modifier>typedef</modifier> <type>std::pair&lt;flimit, flimit&gt;</type>
        <varname>FloatingLimits</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier> <type>std::vector&lt;isEnumParameter*&gt;</type>
        <varname>EnumCheckers</varname>
    </fieldsynopsis>

};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This class is the ultimate base class of the <classname>CReadoutModule</classname>
            object passed to device driver <methodname>onAttach</methodname> methods.
            It manages the configuration database of a configurable object.
          </para>
          <para>
            The interaction of a configurable object or an object that embeds
            configuration via delegation is:
            <orderedlist>
                <listitem>
                    <para>
                        The object defines a configuration that consists of
                        a set of named parameters and initial values.  Each
                        configuration value can have a constraint function
                        attached to it that is called prior to allowing the
                        value to assume a new value.
                    </para>
                    <para>
                        Through these constraint functions parameter values can'
                        be very strongly typed (e.g. not just parameter
                        must be an integer but parameter must be an integer
                        in this range).
                    </para>
                    <para>
                        Pre packaged constraint functions and convenience functions
                        make it easy to set up most types of constraints, however
                        if something special is required client code can implement
                        a special constraint.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        At some point in the lifetime of a configurable object,
                        the object is configured.  This is usually done by creating
                        (the CCUSB framework does this for you) a command or
                        command ensemble that accepts configuration name/value
                        pairs and passes them to the <methodname>configure</methodname>
                        method.  This method will invoke the constraint checker
                        and, if successful, modify the value of the configuration
                        parameter.  If the new value fails the constraint, a
                        <type>std::string</type> exception is thrown and should
                        be caught and reported at some level by the caller.
                    </para>
                    <para>
                        Again for CCUSB device drivers this is transparent.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Configurable objects can query their configuration.
                        The constraint checkers ensure that each value has
                        the type and range constraints required of that parameter.
                        Semantics, however must be enforced and applied
                        by the object that
                        uses the configuration.
                    </para>
                    <para>
                        It is always possible to get a stringified value for
                        each configuration item (in fact configuration items
                        are stored as strings).  Convenience methods allow
                        for clients to fetch conversions of those strings to
                        a rich set of types.
                    </para>
                    <para>
                        CCUSB device drivers normally fetch and process their
                        configurations when their
                        <methodname>Initialize</methodname>
                        and <methodname>addReadoutList</methodname> methods
                        are invoked.
                    </para>
                </listitem>
            </orderedlist>
          </para>
          <para>
            For the full set of methods see the METHODS section below.  The
            pre-defined constraint checkers additionally make use of
            several data types which are described in
            PUBLIC VARIABLES, TYPES and CONSTANTS further below.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                   <methodname>CConfigurableObject</methodname>
                   <methodparam>
                     <type>std::string</type> <parameter>name</parameter>    
                   </methodparam>
                 </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a configurable object.  CCUSB device
                        drivers have this construction performed for them.
                        Configurable objects have names to allow them to be
                        placed in some sort of configuration dictionary by the
                        application. the <parameter>name</parameter>
                        parameter supplies the configuration name.
                    </para>
                    <para>
                        If names are used, it's likely a good thing to ensure
                        that unique names are chose for each configuration
                        namespace the application maintains.  This is not
                        enforced by the constructor, however.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>std::string </type> <methodname>getName</methodname>
                     <void /><modifier> const</modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the name of the configuration. This is the
                        value of the parameter passed to the constructor.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>std::string</type> <methodname>cget</methodname>
                     <methodparam>
                         <type>std::string</type>  <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string value of the configuration parameter
                        <parameter>name</parameter>.  If the parameter was
                        not defined a string exception is thrown.
                    </para>
                    <para>
                        In situations where you don't know the set of configuration
                        parameters that have been defined, see the overloaded
                        <methodname>cget</methodname> method described next.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>CConfigurableObject::ConfigurationArray</type>
                     <methodname>cget</methodname>
                     <void />
                 </methodsynopsis>
                 </term>
                 <listitem>
                    <para>
                        Gets the entire configuration of the module as name
                        value pairs.
                        <type>CConfigurableObject::ConfigurationArray</type> is
                        described fully in PUBLIC VARIABLES, TYPES and CONSTANTS
                        below, however you can think iof it as a vector of
                        <type>std::string</type> pairs of configuration
                        parameter name and value.
                    </para>
                 </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>int</type> <methodname>getIntegerParameter</methodname>
                     <methodparam>
                         <type>std::string</type><parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Invokes <methodname>cget</methodname> on the
                        <parameter>name</parameter> configuration parameter.
                        The resulting string is converted to an integer and
                        returned, if possible.  If the string is not a valid integer,
                        a string exception is thrown.
                    </para>
                    <para>
                        Note that this and other convenience methods for
                        getting parameter values converted to specific data
                        types pass any exceptions from <methodname>cget</methodname>
                        on up to the caller.
                    </para>
                </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>unsigned int</type> <methodname> getUnsignedParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                         </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as <methodname>getIntegerParameter</methodname>,
                        however the conversion to an unsigned value is attempted.
                        This is recommended for e.g. base addresses.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>bool</type> <methodname>getBoolParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Invokes <methodname>cget</methodname> and attempts
                        to convert the resulting string to a <type>bool</type>
                        value which is returned if successful.   A rather
                        rich set of values can be converted to bools.
                    </para>
                    <informaltable>
                        <tgroup cols="2">
                        <colspec colname='string' /> <colspec colname='value' />
                        <thead>
                            <row>
                                <entry>String</entry>
                                <entry>Bool Value</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>true</entry><entry>true</entry>
                            </row>
                            <row>
                                <entry>yes</entry><entry>true</entry>
                            </row>
                            <row><entry>1</entry><entry>true</entry></row>
                            <row><entry>on</entry><entry>true</entry></row>
                            <row><entry>enabled</entry><entry>true</entry></row>
                            <row><entry>false</entry><entry>false</entry></row>
                            <row><entry>no</entry><entry>false</entry></row>
                            <row><entry>0</entry><entry>false</entry></row>
                            <row><entry>off</entry><entry>false</entry></row>
                            <row><entry>disabled</entry><entry>false</entry></row>
                        </tbody>
                        </tgroup>
                    </informaltable>
                    <para>
                        Failure to convert to a <type>bool</type> throws
                        a string exception.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>double</type> <methodname>getFloatParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Uses <methodname>cget</methodname> to retrieve the
                        value of the <parameter>name</parameter> configuration
                        parameter.  The string is converted to a
                        <type>float</type> and
                        returned.  If the string is not a valid
                        <type>float</type>, a string exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>std::vector&lt;int&gt;</type><methodname>getIntegerList</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Uses the <methodname>cget</methodname> method to
                        obtain the configuration parameter <parameter>name</parameter>.
                        The string is treated as a Tcl list which is composed
                        entirely of integers.  If this assumption is correct,
                        a <type>std::vector</type> of the integers that made
                        up the list is returned.  If the string is either
                        an invalid list or not entirely composed of elements
                        that can be converted to <type>int</type>,
                        a string exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addParameter</methodname>
                     <methodparam>
                         <type>std::string</type><parameter> name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>typeChecker</type> <parameter>checker</parameter>
                     </methodparam>
                     <methodparam>
                         <type>void*</type> <parameter>arg</parameter>
                     </methodparam>
                     <methodparam>
                         <type>std::string</type> <parameter>defaultValue</parameter>
                         <initializer>std::string("")</initializer>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is the base mechanism for defining a configuration
                        parameter. See the convenience methods below before using
                        this as they may be easier to use.
                    </para>
                    <para>
                        <parameter>name</parameter>  is the name of the parameter
                        being added.  By convention, this starts with the
                        <literal>-</literal> character (like options in Tk).
                        For example a module slot might be defined as a
                        <literal>-slot</literal> configuration parameter.
                    </para>
                    <para>
                        <parameter>checker</parameter> is a pointer to the
                        constraint checking function.  If no constraint checking
                        is required (e.g. the paramter is a pure string), pass
                        <literal>NULL</literal> for this parameter.
                    </para>
                    <para>
                        <parameter>arg</parameter>  is a parameter that is passed
                        without interpretation to the constraint checker.
                        See CONSTRAINT CHECKING below for more about how
                        constraint checkers are defined and called.
                        See also the descriptions of the built in constraint
                        checkers that are static members of this class, documented
                        later in this section.
                    </para>
                    <para>
                        <parameter>defaultValue</parameter> is the initial
                        value supplied to the parameter.  Note that this is
                        <emphasis>not</emphasis> constraint checked.  This is
                        intentional as it allows you to require a parameter
                        setting by providing an invalid initial parameter
                        value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>clearConfiguration</methodname>
                     <void />
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Clear the configuration.  This removes any parameter
                        definitions as well as their value from the configuration
                        database.  In most cases this function is not necessary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>configure</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>std::string</type> <parameter>value</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Attempts to configure a parameter <parameter>name</parameter>
                        should be a configuration parameter name that has been
                        defined by <methodname>addParameter</methodname> or its
                        convenience methods. <parameter>value</parameter>
                        is the new proposed value of the parameter.
                        The constraint checker, if any, is called for that parameter
                        and if it fails a string exception is thrown.  Otherwise,
                        the new parameter value replaces the old one.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntegerParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                     </methodparam>
                 </methodsynopsis>
                 </term>
                <listitem>
                    <para>
                        Convenience method to add an parameter
                        <parameter>name</parameter>  which is constrained
                        to be an integer parameter that has no range
                        requirements.  The initial value of this parameter
                        will be <parameter>defaultVal</parameter>
                        </para>
                    </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntegerParameter</methodname>
                     <methodparam>
                         <type>std::string</type>  <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>low</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>high</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                         </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Convenience methos that creates a parameter
                        (<parameter>name</parameter>) that is constrained
                        to be an integer in the range
                        [<parameter>low</parameter>..<parameter>high</parameter>].
                    </para>
                    <para>
                        The initial value of the parameters is set to
                        <parameter>defaultVal</parameter> which is not
                        checked against the limits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addBooleanParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>bool</type> <parameter>defaultVal</parameter>
                         <initializer> true</initializer>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a parameter <parameter>name</parameter> to the
                        configuration database which is contrained to be
                        a string that converts to a <type>bool</type>.
                        The initial value of the parameter will be
                        <parameter>defaultVal</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type><methodname>addEnumParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const</modifier> <type>char**</type>
                         <parameter>pValues</parameter>
                     </methodparam>
                     <methodparam>
                         <type>std::string</type> <parameter>defaultValue</parameter>
                         <initializer>std::string("")</initializer>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a parameter <parameter>name</parameter>   that is
                        constrained to be one of the values pointed to by the
                        <parameter>pValues</parameter> array.
                        The initial value is <parameter>defaultValue</parameter>
                    </para>
                    <para>
                        The <parameter>pValues</parameter> parameter should
                        be a pointer to a null terminated set of character pointers.
                        This sounds much harder than it is:
                        <informalexample>
                            <programlisting>
const char* enumValues[] = {"red", "green", "blue", NULL};
                            </programlisting>
                        </informalexample>
                        In the code fragment above, <varname>enumValues</varname>
                        can be passed in as the <parameter>pValues</parameter>
                        argument and will constrain the values of the configuration
                        parameter to be in the set
                        {<literal>red</literal>, <literal>greeen</literal>, <literal>blue</literal>}.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type><methodname>addBoolListParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type><parameter>size</parameter>
                     </methodparam>
                     <methodparam>
                         <type>bool</type>   <parameter> defaultVal</parameter>
                         <initializer>true</initializer>
                     </methodparam>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new configuration parameter
                        <parameter>name</parameter> that is constrained to be
                        a valid Tcl list of <type>bool</type> strings of
                        exactly <parameter>size</parameter> elements long.
                    </para>
                    <para>
                        The initial value will be set to <parameter>size</parameter>
                        elements of <parameter>defaultVal</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addBoolListParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>minLength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>maxLength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>bool</type> <parameter>defaultVal</parameter>
                         <initializer>true</initializer>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter> defaultSize</parameter>
                         <initializer>-1</initializer>
                     </methodparam>
                 </methodsynopsis>
                 </term>
                <listitem>
                    <para>
                        Same as the previous method, however the
                        list size is constrained to be at least
                        <parameter>minLength</parameter> and at most
                        <parameter>maxLength</parameter> elements long.
                        The initial value is <parameter>defaultSize</parameter>
                        elements of <parameter>defaultVal</parameter>
                        If <parameter>defaultSize</parameter> is outside
                        the length limits, it is forced to the closest limit.
                    </para>
                </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntListParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>size</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                     </methodparam>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a parameter that is constrained to be  a fixed
                        length Tcl list of <parameter>size</parameter>
                        integer values.
                        The initial value of the list is <parameter>size</parameter>
                        copies of <parameter>defaultValue</parameter>
                        </para>
                    <para>
                        The range of values in the list is unconstrained.
                        See the overloads below however.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntListParameter</methodname>
                     <methodparam>
                         <type>std::string</type>  <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>minlength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>maxLength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultSize</parameter>
                         <initializer>-1</initializer>
                     </methodparam>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as the previous method however the list can
                        have a size in the range
                        [<parameter>minlength</parameter>..<parameter>maxLength</parameter>].
                        the initial value of the list is <parameter>defaultSize</parameter>
                        elements of <parameter>defaultVal</parameter>.
                    </para>
                    <para>
                        As for <methodname>addBoolListParameter</methodname>,
                        if the <parameter>defaultSize</parameter> parameter
                        is outside the range of valid list length it is forced
                        to the closest value.  Thus the default value really
                        creates <parameter>minlength</parameter> elements.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isInteger</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type><parameter>arg</parameter>
                      </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is a static method that can be used as a constraint
                        checker for integer parameters.  When it is used,
                        the constraint parameter shoule be <literal>NULL</literal>
                        if no range checking is desired or a pointer to a
                        <type>Limits</type> struct as described in
                        PUBLIC VARIABLES, TYPES and CONSTANTS to describe
                        which limits are desired and their values.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isBool</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is a static method that can be used as a constraint
                        checker for boolean parameters.  When used, the
                        constraint parameter should be <literal>NULL</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isEnum</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                    </term>
                <listitem>
                    <para>
                        Constriaint checker fora n enumerated type.
                        When used, the constraint parameter should be
                        a pointer to an <type>std::set&lt;string&gt;</type>
                        which  has elements for each valid enumerator value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        General constraint checker for a parameter that must
                        look like a Tcl list.  The constraint parameter
                        is a pointer to an <type>isListParameter</type>
                        struct as defined in PUBLIC VARIABLES, TYPES and CONSTANTS
                        This structure should be filled in to provide limits on
                        the number of list elements the list can have.  A constraint
                        checker that is applied to each list element can also be
                        supplied.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isBoolList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Constraint checker for a Tcl formatted list of
                        booleans.  The constraint parameter shouild be a
                        pointer to a <type>ListSizeConstraint</type>
                        described in PUBLIC VARIABLES, TYPES and CONSTANTS.
                        This should set limits on the size of the list.
                        <methodname>isBoolList</methodname> will ensure
                        that the elements of the list are booleans.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isIntList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Constraint checker for a list of integers. The constraint
                        parameter should be a <type>ListSizeConstraint</type>
                        that describes the allowed list sizes.  The
                        checker will ensure that the elements fo the list are
                        all valid integers. At present, this checker does not
                        support checking the values of the list elemeents against
                        range limits.
                    </para>
                    <para>
                        You could manually construct the <type>isListParameter</type>
                        structure to do this and use <methodname>isList</methodname>
                        if required.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isStringList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Constraint checker for lists of strings.   The
                        constraint parametr is a <type>ListSizeConstraint</type>
                        that defines the allowed sizes of the list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>isEnumParameter</type>
                      <methodname>makeEnumSet</methodname>
                      <methodparam>
                          <modifier>const</modifier> <type>char**</type><parameter>values</parameter>
                      </methodparam>
                  </methodsynopsis>
                  </term>
                <listitem>
                    <para>
                        Helper function that converts a null terminated array
                        of pointers to strings into a
                        <type>isEnumParameter</type> constraint parameter.
                    </para>
                </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>strToBool</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Convenience function that converts a string to a boolean
                        or throws an exception if the resulting string cannot
                        be converted.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
       </refsect1>
        <refsect1>
           <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
           <para>
                The class definition in the SYNOPSIS section above shows a
                large number of type definitions for this class.
                Almost all of these types are structures used by the
                built in constraint checkers.In most cases,
                if you use the convenience functions to define your parameters
                you won't need to know the details of these types.
           </para>
           <para>
                The remainder of this section describes these types and the
                constraint checkers they belong to.
            </para>
            <variablelist>
                <varlistentry>    
                    <term>
                        <fieldsynopsis>
                            <modifier>typedef</modifier>
                            <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;</type>
                            <varname>ConfigurationArray</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <type>ConfigurationArray</type> is returned from
                            one of the overloads of the <methodname>cget</methodname>
                            method.  This type is a vector of pair.  The first element of each pair
                            is the name of a parameter while the second element is it's current
                            value.
                        </para>
                        <para>
                            The following fragment of code shows how to use this
                            to dump the current configuration of a configurable
                            object pointed to by <varname>pConfig</varname>
                        </para>
                        <informalexample>
                            <programlisting>
ConfigurationArray config = pConfig-&gt;cget();
for (int i = 0; i &lt; config.size(); i++) {
   cout &lt;&lt; config[i].first &lt;&lt; " is set to " &lt;&lt; config[i].second &lt;&lt; endl;
}
                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        struct  <type>limit</type> {
                        <fieldsynopsis>
                            <type>bool</type>   <varname>s_checkMe</varname>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <type>long</type> <varname>s_value</varname>
                        </fieldsynopsis>
                        <constructorsynopsis>
                            <methodname>limit</methodname>
                            <void />
                        </constructorsynopsis>
                        <constructorsynopsis>
                            <methodname>limit</methodname>
                            <methodparam>
                                <type>long</type>    <parameter>value</parameter>
                            </methodparam>
                        </constructorsynopsis>
                      } ;
                    </term>
                    <term>
                      <fieldsynopsis>
                          <modifier>typedef</modifier>
                          <type>std::pair&lt;limit, limit&gt;</type><varname>Limits</varname>
                      </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These data types are used with the
                            <methodname>isInteger</methodname> constraint
                            checker.  Each <type>limit</type> data type
                            represents a range limit that may or may  not be
                            checked according to the state of its
                            <varname>s_checkMe</varname> flag.
                        </para>
                        <para>
                            <type>Limits</type> is a pair of <type>limit</type>
                            structs where the first one represents the lower
                            limit and the second one the upper limit.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>                      
                        <fieldsynopsis>
                            <modifier>typedef</modifier>
                            <type>std::set&lt;std::string&gt;</type>
                            <varname>isEnumParameter</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <type>isEnumParameter</type> is used by the
                            <methodname>isEnum</methodname> method
                            to validate parameters that are enumerate parameter.
                            The actual type is a set of the character strings
                            that are allowed to be assigned to the parameter value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>typedef</modifier> <type>std::pair&lt;typeChecker, void*&gt;</type>
                            <varname>TypeCheckInfo</varname>
                        </fieldsynopsis>
                    </term> 
                    <term>
                        typedef struct <type>_ListSizeConstraint</type> {
                            <fieldsynopsis>
                                <type>limit</type> <varname>s_atLeast</varname>
                            </fieldsynopsis>
                            <fieldsynopsis>
                                <type>limit</type> <varname>s_atMost</varname>
                            </fieldsynopsis>
                        } <type>ListSizeConstraint</type>
                    </term>
                    <term>
                        typedef struct <type>_isListParameter</type> {
                          <fieldsynopsis>
                            <type>ListSizeConstraint</type> <varname>s_allowedSize</varname>
                          </fieldsynopsis>
                          <fieldsynopsis>
                            <type>TypeCheckInfo</type> <varname>s_checker</varname>
                          </fieldsynopsis>
                        } <type>isListParameter</type>;
                    </term>
                    <listitem>
                        <para>
                            This set of types are used to validate lists.
                            The <type>isListParameter</type>
                            is what is used to validate lists.  This consists
                            of two chunks;
                        </para>
                        <para>
                            <varname>s_allowedSize</varname> is used
                            to validate the size of a list.  It is a
                            <type>ListSizeConstraint</type> which allows you to
                            specify minimum and maximum list sizes.  The list
                            size limits are inclusive so you can specify a
                            fixed size list by setting both
                            <varname>s_atLeast</varname> and <varname>s_atMost</varname>
                            to be the same.
                        </para>
                        <para>
                            <varname>s_checker</varname> is a constraint
                            checker and its parameter used to validate each
                            item in the list.  This is applied after the
                            string is determined to be a valid list and
                            after the size of the list has been checked against
                            the limits defined by <varname>s_allowedSize</varname>
                            <varname>s_checker</varname>
                            <type>TypeCheckInfo</type> which is a pair whose
                            first element is a pointer to the actual constraint
                            checking function and whose second is a pointer to data
                            passed to the constraint checker without
                            interpretation. For more information about how
                            constratin checkers work see
                            CONSTRAINT CHECKING below.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>  
                        struct  <type>flimit</type> {
                          <fieldsynopsis>
                            <type>bool</type>   <varname>s_checkMe</varname>
                          </fieldsynopsis>
                          <fieldsynopsis>
                            <type>float</type> <varname>s_value</varname>
                          </fieldsynopsis>
                          <constructorsynopsis>
                            <methodname>flimit</methodname><void />
                          </constructorsynopsis>    
                          <constructorsynopsis>
                            <methodname>flimit</methodname>
                            <methodparam>
                                <type>float</type> <parameter>value</parameter>
                            </methodparam>
                          </constructorsynopsis>    
                        };
                    </term>
                    <term>
                        <fieldsynopsis>
                            <modifier>typedef</modifier> <type>std::pair&lt;flimit, flimit&gt;</type>
                            <varname>FloatingLimits</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These types specify floating point limits in a
                            mannger analgous to integer limits.
                            </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>           
        </refsect1>
        <refsect1>
            <title>CONSTRAINT CHECKING</title>
            <para>
                Constraint checking is the <classname>CConfigurableObject</classname>
                class's way to enforce type safety and other constraints on
                the values of configuration parameters.
                When a parameter is created with <methodname>addParameter</methodname>,
                The caller has an option to provide a constraint checker and
                a parameter that provides extra information to the constraint
                checker that can parameterize the constraints it checks.
            </para>
            <para>
                A constraint checker is just a function of the form:
                <informalexample>
                    <programlisting>
bool myConstraintChecker(std::string name, std::string newValue,
                        void* pClientData);
                    </programlisting>
                </informalexample>
            </para>
            <para>
                When the <methodname>configure</methodname> method is called
                for a parameter name that has a constraint checker
                attached to it, that checker is called and passed the parameters
                shown in the code fragment above:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <parameter>name</parameter>
                    </term>
                    <listitem><para>
                        Is the name of the parameter being configured.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <parameter>newValue</parameter>
                    </term>
                    <listitem>
                        <para>Is the proposed new value for the parameter.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <parameter>pClientData</parameter>
                    </term>
                    <listitem>
                        <para>
                            Is the constraint parameter passed to
                            <methodname>addParameter</methodname>
                            passed without interpretation or modification.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The constraint checker is expected to return
                <literal>true</literal> if the proposed <parameter>newValue</parameter>
                is acceptable by the constraint checker and <literal>false</literal>
                if not.  If <literal>true</literal> is returned the parameter
                value is modified to <parameter>newValue</parameter> otherwise
                a string exception is thrown and the parameter value is not
                modified.
            </para>
            <para>
                The CCUSB framework catches string exceptions thrown by
                <classname>CConfigurableObject</classname> and converts those
                into configuration file processing error messages.  Any configuration
                file processing error is reported and aborts the start of the
                run that caused it.
            </para>
        </refsect1>
     </refentry>
       <refentry id="ccusb3-cccusb">
         <refmeta>
            <refentrytitle>cccusb</refentrytitle>
            <manvolnum>3ccusb</manvolnum>
         </refmeta>
         <refnamediv>
            <refname>cccusb</refname>
            <refpurpose>Swig wrapping of the CCCUSB C++ class.</refpurpose>
         </refnamediv>
         
         <refsynopsisdiv>
            <cmdsynopsis>
                <command>
cccusb::CCCUSB_enumerate
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
cccusb::usb_device_vector_get  <replaceable>CCCUSB-enumeration  index</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
cccusb::usb_device_vector_size <replaceable>CCUSB-enumeration</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::CCCUSB <replaceable>name</replaceable> <replaceable>usb-device</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::CCCUSB <replaceable>-args usb-device</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::CCCUSB <replaceable>?name?</replaceable> -this <replaceable>ptrName</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> c
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> executeList <replaceable>readout-list maxread</replaceable>                
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> inhibit
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> loadList <replaceable>listNum readout-list</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDGGA
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDGGB
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDGGExt
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDelays
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDeviceSourceSelectors
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readFirmware
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>readGlobalMode
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readLamTriggers
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readLedSelector
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readOutputSelector
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readScalerA
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readScalerB
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readScalerControl
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readUSBBulkTransferSetup
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
cccusb::CCCUSB_serialNo <replaceable>usb-device</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> setDefaultTimeout <replaceable>ms</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleControl <replaceable>n a f</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleRead16 <replaceable>n a f</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleRead24 <replaceable>n a f</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleWrite16 <replaceable>n a f d</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleWrite24 <replaceable>n a f d</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> uninhibit
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeActionRegister <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> createReadoutList
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDGGA <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDGGB <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>

            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDGGExt <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDelays <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDeviceSourceSelectors <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeGlobalMode <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeLamTriggers <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeLedSelector <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeOutputSelector <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeScalerControl <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeUSBBulkTransferSetup <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> Z
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> -delete
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
cccusb::string_to_char <replaceable>string-object</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::uint16_vector_get <replaceable>vector-object index</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::uint16_vector_size <replaceable>vector-object</replaceable>
                </command>
            </cmdsynopsis>
         </refsynopsisdiv>
         <refsect1>
            <title>DESCRIPTION</title>
            <para>
                This set of commands is a Tcl wrapper around the
                CCCUSB C++ class (see <xref linkend='ccusb3-CCCUSB' />.  The
                interface consists of several static methods and object sub
                commands.
            </para>
            <para>
                The static methods include methods that support
                device enumeration and construction.  Enumeration returns
                data types that require additional static methods to
                unpack.  See DEVICE ENUMERATION below.
            </para>
            <para>
                Command lists (see <xref linkend='ccusb3-cccusbreadoutlist' />)
                can be executed in immediate mode or loaded.  At present
                the usb bulk read function is not supported so a pure Tcl
                data taking system cannot yet be written.  If you want support
                for that, request it as that can be added easily enough.
            </para>
            <para>
                Immediate list execution also produces data types that require
                additional static member functions to unpack.  See
                LIST EXECUTION below for more information.
            </para>
         </refsect1>
         <refsect1>
            <title>COMMAND DETAILS</title>
            <variablelist>
                <varlistentry>
                    <term><command>cccusb::CCCUSB_enumerate</command></term>
                    <listitem>
                        <para>
                            Produces an enumeration of the powered up CC-USB
                            devices attached to the host.  The result of this
                            command is a wrapped std::vector&lt;usb_device*&gt;
                            See DEVICE ENUMERATION for recipes for using
                            this result.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>cccusb::usb_device_vector_get  <replaceable>CCCUSB-enumeration  index</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Gets a specific element of the return value from
                            <command>cccusb::CCCUSB_enumerate</command>.
                            <parameter>CCCUSB-enumeration</parameter> is the
                            value returned from that command.
                            <parameter>index</parameter>
                            is the index into the vector.
                            Indices start from 0.  See DEVICE ENUMERATION
                            below for some enumeration recipes.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>cccusb::usb_device_vector_size <replaceable>CCUSB-enumeration</replaceable></command></term>
                    <listitem>
                        <para>
                            Returns the size of the enumeration vector
                            <parameter>CCCUSB-enumeration</parameter>.
                            This parameter is a value returned from
                            <command>cccusb::CCCUSB_enumerate</command>
                        </para>
                        <para>
                            See DEVICE ENUMERATION below for some device enumeration
                            recipes.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::CCCUSB <replaceable>name</replaceable> <replaceable>usb-device</replaceable>
                    </command></term>
                    <listitem>
                        <para>
                            Constructs a CCCUSB object whose command will be
                            <parameter>name</parameter>.
                            <parameter>usb-device</parameter> is an element
                            from a device enumeration that was gotten
                            from <command>cccusb::CCCUSB_enumerate</command>.
                        </para>
                        <para>
                            For recipes involving device enumeration and
                            construction see DEVICE ENUMERATION below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::CCCUSB <replaceable>-args usb-device</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Constructs a CCCUSB object with a unique
                            object instance command name chosen
                            by the constructor.  <parameter>usb-device</parameter>
                            is an element of an enumeration returned from
                            <command>cccusb::CCCUSB_enumerate</command>.
                        </para>
                        <para>
                            Normally this is used in constructs like e.g:
                        </para>
                        <informalexample>
                            <programlisting>
set controller [cccusb::CCCUSB -args $device]
$controller c
$controller z
                            </programlisting>
                        </informalexample>
                        <para>
                            For more enumeration and construction recipes
                            see DEVICE ENUMERATION below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::CCCUSB <replaceable>?name?</replaceable>
                    -this <replaceable>ptrName</replaceable></command></term>
                    <listitem>
                        <para>
                            Constructs  CCCUSB object from an object pointer
                            <parameter>ptrName</parameter>.
                            Object pointers are gotten either by requesting
                            the <option>-this</option> from another object or,
                            in the CCUSBReadout framework by being passed in
                            from the framework to a Tcl driver.
                        </para>
                        <para>
                            If the optional <parameter>name</parameter>
                            is provided it will be the object instance command.
                            If not the object instance command will be the
                            value of <parameter>ptrName</parameter>
                        </para>
                        <para>
                            For example.
                        </para>
                        <informalexample>
                            <programlisting>
proc example pointer {
   cccusb::CCCUSB controller -this $pointer
   controller c
   
   cccusb::CCCUSB -this $pointer
   $pointer z
}
                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> c </command></term>
                    <listitem>
                        <para>
                            Performs a C cyle on the dataway connected to
                            <parameter>object</parameter>.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> executeList
                    <replaceable>readout-list maxread</replaceable></command></term>
                    <listitem>
                        <para>
                            Executes a <classname>cccusbreadoutlist::CCCUSBReadoutList</classname>
                            (see <xref linkend='ccusb3-cccusbreadoutlist' />).
                            <parameter>readout-list</parameter> is the name
                            of the list and <parameter>maxread</parameter>
                            the maximum number of 16 bit words that can
                            be read by this list (written data is inline in the
                            list).  <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                        <para>
                            The return value is the name of an
                            encapsulated std::vector&lt;uint16_t&gt;.
                            See EXECUTING LISTS for recipes for executing lists
                            and getting data from the result.
                            See as well <command>cccusb::uint16_vector_get</command>,
                            <command>cccusb::uint16_vector_size</command>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> inhibit</command></term>
                    <listitem>
                        <para>
                            Sets the inhibit line on the CAMAC crate controlled
                            by <parameter>object</parameter>.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> loadList
                    <replaceable>listNum readout-list</replaceable></command>
                    </term>
                    <listitem>
                        <para>Loads a <classname>cccusbreadoutlist::CCCUSBReadoutList</classname>
                        object for later execution in response to an event or
                        scaler trigger.
                        </para>
                        <para>
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                            <parameter>listNum</parameter> is the number of the
                            list to be loaded.  The list numbers is either
                            <literal>0</literal> for the event list or
                            <literal>1</literal> for the scaler list.
                        </para>
                        <para>
                            <parameter>readout-list</parameter> is a
                            <classname>cccusbreadoutlist::CCUSBReadoutList</classname>
                            object instance name.  See
                            <xref linkend='ccusb3-cccusbreadoutlist' /> for
                            information about how to create these.
                        </para>
                        <para>
                            The command returns
                            <literal>0</literal> on successful completion,
                            a negative number is returned on failure.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDGGA</command></term>
                    <listitem>
                        <para>
                            Reads the DGGA register of the CC-USB module
                            represented by <parameter>object</parameter>.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                            The DGGA register controls the width and
                            delay of one of the CC-USB's gate and delay generators.
                            See section 3.3.7 of the CC-USB manual for
                            more information about this register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDGGB</command></term>
                    <listitem>
                        <para>
                            Same as <command>readDGGA</command> but reads the
                            B gate and delay register control register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDGGExt</command></term>
                    <listitem>
                        <para>
                            Reads the CC-USB Gate and delay generated extended
                            range register.  See Section 3.3.7 of the CC-USB
                            manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDelays</command></term>
                    <listitem>
                        <para>
                            Reads the delays register of the CC-USB.  See
                            Section 3.3.3 of the CC-USB manual for a
                            description of this register.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDeviceSourceSelectors</command></term>
                    <listitem>
                        <para>
                            Reads the CCUSB device source selectors register.
                            This is described in section 3.3.6 of the CC-USB
                            manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readFirmware</command></term>
                    <listitem>
                        <para>
                            Reads the CC-USB firmware id register.
                            The bit fields of this register are described by
                            section 3.3.1 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>readGlobalMode</command></term>
                    <listitem>
                        <para>
                            Reads the CC-USB global mode register.  This register
                            iis described in section 3.3.2 of the CC-USB
                            manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readLamTriggers</command>
                    </term>
                    <listitem>
                        <para>
                            Reads the LAM trigger register.  The CC-USB
                            manual calls this register the LAM Mask register
                            and describes it in section 3.3.9.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readLedSelector</command>
                    </term>
                    <listitem>
                        <para>
                            Reads the LED Selector register.   This register is
                            descsribed in section 3.3.5 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readOutputSelector</command>
                    </term>
                    <listitem>
                        <para>
                            Reads the output selector register.   This register
                            is described in section 3.3.5 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readScalerA</command></term>
                    <listitem>
                        <para>
                            Read the counts in Scaler A.  The scalers are
                            described in Section 3.3.8 of the CC-USB manual
                            with how to define what makes them count described
                            in section 3.3.6.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readScalerB
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>readScalerA</command> however
                            the B scaler is read.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readScalerControl
                        </command>
                        </term>
                    <listitem>
                        <para>
                            Read the Scaler readout control register.
                            The CC-USB manual refers to this as the
                            ACS (Auxiliary Camac Stack) register in some places
                            and the Scaler Readout Control register in others.
                            It is described in section 3.3.4 of the manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readUSBBulkTransferSetup</command>
                    </term>
                    <listitem>
                        <para>
                            Reads the USB Bulk transfer setup register.  This
                            is described in section 3.3.10 of the CC-USB
                            manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>cccusb::CCCUSB_serialNo <replaceable>usb-device</replaceable></command></term>
                    <listitem>
                        <para>
                            Reads the serial number of the device selected by
                            <parameter>usb-device</parameter>.  <parameter>usb-device</parameter>
                            is a usb device object that comes from one of the elements
                            of the enumerator returned by
                            <command>cccusb::CCCUSB_enumerate</command>.  The
                            serial number is returned as a string object handle
                            that must be converte via <command>cccusb::string_to_char</command>.
                            For more information about device enumeration and serial
                            number strings see DEVICE ENUMERATION below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> setDefaultTimeout <replaceable>ms</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Most CC-USB operations require a USB bulk transfer to
                            the CC-USB and a transfder from the CC-USB.  These
                            transfers are done with a timeout so that if
                            the target does not respond, the request eventually
                            does terminate. This sets the timeout for
                            those requests to be <parameter>ms</parameter>
                            milliseconds.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleControl
                        <replaceable>n a f</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Performs a non-data transfer operation.
                            <parameter>n</parameter> specifies the CAMAC slot
                            that will be the target of this operation.
                            <parameter>a</parameter> specifies the subaddress
                            and <parameter>f</parameter> specifies the
                            function code.  The function code must be in one
                            of the ranges: <literal>[8..15] [24..31]</literal>.
                            The command returns a mask of the Q and X
                            responses from the dataway.  See VARIABLES below
                            for the Q and X bits in this mask.
                        </para>
                        <para>
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleRead16
                        <replaceable>n a f</replaceable> </command>
                    </term>
                    <listitem>
                        <para>
                            Performs a 16 bit read from the module and sub
                            address specified by <parameter>n</parameter> and
                            <parameter>a</parameter>.  The CAMAC function
                            code <parameter>f</parameter> must be in the range
                            <literal>[0..7]</literal>.
                        </para>
                        <para>
                            The command returns the data in the lower 16 bits
                            of the value and the Q/X resonse in the upper byte
                            (bits 24 through 31).  Thus to extract the Q/X:    
                            <informalexample>
                                <programlisting>
set data [c simpleRead16 1 0 0]
set qx [expr {$data >> 24}]
set data [expr {$data &amp; 0xffff}]
                                </programlisting>
                            </informalexample>
                            See VARIABLES below for information about the
                            how to extract the Q and X bits from the
                            <varname>qx</varname> variable in the example
                            above.
                        </para>
                        <para>
                           <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleRead24
                        <replaceable>n a f</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>simpleRead16</command> above,
                            however the data transferred is 24 bits wide.
                            The Q/X response is still in bits 24 through 31.
                            The example below shows how to extract the data
                            and the Q/X resopnse:
                            <informalexample>
                                <programlisting>
set data [c simpleRead16 1 0 0]
set qx [expr {$data >> 24}]
set data [expr {$data &amp; 0xffffff}]
                                </programlisting>
                            </informalexample>
                        </para>
                        <para>
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleWrite16
                        <replaceable>n a f d</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Performs a write of the 16 bit data <parameter>d</parameter>
                            to the module and subaddress specified by
                            <parameter>n</parameter> and <parameter>a</parameter>
                            via the CAMAC function code <parameter>f</parameter>.
                            <parameter>f</parameter> must be in the range
                            <literal>[16..23]</literal>.  The command returns
                            the Q and X mask. See VARIABLES below for information
                            about which bits are Q and which X.
                        </para>
                        <para>
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleWrite24
                        <replaceable>n a f d</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>simpleWrite16</command> however
                            the bottom 24 bits of <parameter>d</parameter>
                            are transferred.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> uninhibit</command></term>
                    <listitem>
                        <para>
                            Removes the dataway inhibit.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeActionRegister
                        <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes the CC-USB action register.
                            This register is described in section 3.2.1
                            of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeDGGA
                        <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter>
                            to the control register for Gate and Delay
                            A.  This register is described in section
                            3.3.7 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeDGGB
                        <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>writeDGGA</command> however the
                            control register for gate and delay generator B
                            is written.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeDGGExt
                        <replaceable>value</replaceable></command></term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to
                            the gate and delay extended delay register.
                            See section 3.3.7 of the CC-USB manual for a description
                            of this registers.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeDelays
                    <replaceable>value</replaceable></command></term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the delays
                            register.  This register is described in section
                            3.3.3 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeDeviceSourceSelectors <replaceable>value</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the
                            device source selector register.  This
                            register is described in section 3.3.6 of the
                            CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeGlobalMode <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the global
                            mode register. See section 3.3.2 of the CC-USB
                            manual for a description of this register.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeLamTriggers <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the LAM
                            triggers register.  The CC-USB manual refers
                            to this register as the LAM Maks register
                            and describes it in section 3.3.9
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeLedSelector <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to
                            the LED selector register. This register
                            is described in section 3.3.5 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                      writeOutputSelector <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the
                            output selectors register of the CC-USB.
                            This register is described in section 3.3.5 of
                            the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeScalerControl <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to
                            the scaler control register/ACS Control
                            register.  This register is described in section
                            3.3.4 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeUSBBulkTransferSetup <replaceable>value</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the USB
                            bulk transfer setup register. Section 3.3.10 of
                            the CC-USB manual describes this register.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        Z</command>
                    </term>
                    <listitem>
                        <para>
                            Performs a Z cycle on the camac dataway.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> -delete</command></term>
                    <listitem>
                        <para>
                            Deletes a swig wrapper for a <classname>CCCUSB</classname>
                            wrapper.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>cccusb::string_to_char <replaceable>string-object</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Returns a Tcl string equivalent of a
                            std::string object identifier
                            <parameter>string-objecdt</parameter>.
                            std::string
                            object identifiers are returned from the
                            <command>serialNo</command> method. See
                            DEVICE ENUMERATION below for more information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::uint16_vector_get
                        <replaceable>vector-object index</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Returns  element
                            <parameter>index</parameter>
                            of <parameter>vector-object</parameter>
                            where that is an object identifier for a
                            <type>std::vector&lt;uint16_t&gt;</type>.
                            This is required to fetch items out of the data
                            that comes back from the <command>executeList</command>
                            command.  For more information see EXECUTING LISTS
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::uint16_vector_size
                        <replaceable>vector-object</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Returns the size of <parameter>vector-object</parameter>
                            where <parameter>vector-object</parameter> is an
                            object identifier for a
                            <type>std::vector&lt;uint16_t&gt;</type>.  This
                            is typically used when processing data from running
                            a list.  See EXECUTING LISTS Below for more information.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
         </refsect1>
         <refsect1>
            <title>DEVICE ENUMERATION</title>
            <para>
                The USB bus is a hotplug bus.  Device enumeration is the
                process of determining the set of devices plugged into the USB
                bus at a point in time.  The goal of device enumeration is normally
                to access a specific device of the desired device type.
                In our case we are interested in creating a CCCUSB object
                connected to  CC-USB with a specific serial number.
            </para>
            <para>
                If you are using the CCUSBReadout framework, you normally don't
                need to do this.   The framework has already enumerated and
                opened the device and is passes you the appropriate object id.
                If you are writing a pure Tcl CC-USB application, you will need
                to read and understand this section.
            </para>
            <para>
                The starting point of device enumeration is the
                <command>cccusb::CCCUSB_enumerate</command>  command.
                This returns an object id for a
                <type>std::vector&lt;usb_device*&gt;</type>. This is unfortunately
                not directly accessible in Tcl.
            </para>
            <para>
                the cccusb package provides two commands to tear apart the
                return from a call to <command>cccusb::CCCUSB_enumerate</command>:
            </para>
            <variablelist>
                <varlistentry>
                    <term><command>cccusb::usb_device_vector_size</command></term>
                    <listitem><para>
                        which returns the size of the returned vector
                        </para></listitem>
                    </varlistentry>
                <varlistentry>
                    <term><command>cccusb::usb_device_vector_get</command></term>
                    <listitem><para>Which fetches a specific
                        <type>usb_device</type> pointer object id.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Once you have a <type>usb_device</type> pointer object id
                you can do two things with it.  You can obtain the serial
                number string of the associated CC-USB controller or create
                a CCCUSB object with which you can perform operations on the
                controller and the CAMAC modules in its crate.
            </para>
            <para>
                Normally you want to do both, you want to enumerate the
                controllers and either match them against a desired serial
                number or display them for the user to choose.
                The example below enumerates the CC-USB's and displays
                their serial numbers on stdout:
            </para>
            <example>
                <title>Listing CC-USB Serial numbers (Tcl).</title>
                <programlisting>
lappend auto_path /usr/opt/daq/10.1/lib
package require cccusb

set e [cccusb::CCCUSB_enumerate]

set ccount [cccusb::usb_device_vector_size $e]
for {set i 0} {$i &lt; $ccount} {incr i} {
    set usbdev [cccusb::usb_device_vector_get $e $i]
    set serial [cccusb::string_to_char [cccusb::CCCUSB_serialNo $usbdev]]
    puts $serial
}
                </programlisting>
            </example>
            <para>
                Note how <command>cccusb::usb_device_vector_size</command>
                and <command>cccusb::usb_device_vector_get</command> are used
                to get <type>usb_device*</type> object ids.
                Note as well how a specific object id is then passed to
                <command>cccusb::CCCUBS_serialNo</command> and the output of
                that converted to a Tcl string via
                <command>cccusb::string_to_char</command>
           </para>
            <para>
                The next example demonstrates a Tcl proc that returns
                a CCCUSB object command name that is connected to a specific
                CC-USB specified by serial number or generates an error
                if that serial number does not exist.
            </para>
            <example>
                <title>Creating a CCCUSB object by serial number (Tcl).</title>
                <programlisting>
lappend auto_path /usr/opt/daq/10.1/lib
package require cccusb
...
proc openCamac serialNo {
    set e [cccusb::CCCUSB_enumerate]
    set ccount [cccusb::usb_device_vector_size $e]
    for {set i 0} {$i &lt; $ccount} {incr i} {
        set usbdev [cccusb::usb_device_vector_get $e $i]
        set serial [cccusb::string_to_char [cccusb::CCCUSB_serialNo $usbdev]]
        if {$serial eq $serialNo} {
            return [cccusb::CCCUSB -args $usbdev]
        }
    }
    error "No CC-USB with serial number $serialNo is available"
 
}
                </programlisting>
            </example>
            <para>
                The pattern of this code follows the pattern of the previous
                example.  The only difference is that when the serial number
                matches the requested <varname>serialNo</varname> parameter,
                a CCCUSB object is created.  SWIG is allowed to choose the
                object command (the <option>-args</option> option does that),
                which is returned to the caller.
            </para>
         </refsect1>
         <refsect1>
            <title>EXECUTING LISTS</title>
            <para>
                The CC-USB has the ability to execute list of camac instructions.
                Immediate list execution is supported by the cccusb package
                via the <command>executeList</command> command.  Lists can also
                be downloaded to CC-USB memory for execution in data acquisition
                mode in response to event and scaler triggers.  This is supported
                via the <command>loadList</command> command.
            </para>
            <para>
                This section describes how to use <command>executeList</command>
                and how to access any data read by those lists (written data
                is stored in the list itself).  Please refer to
                <xref linkend='ccusb3-CCCUSBReadoutList'/> for reference
                material on the Tcl package for constructing these lists.
            </para>
            <para>
                In order to execute a list on an existing CCCUSB class/command
                you must
            </para>
            <itemizedlist>
                <listitem>
                    <para>Construct the list of operations to perform</para>
                </listitem>
                <listitem>
                    <para>
                        Use <command>executeList</command> to perform the
                        operations in the list, specifying a maximum number of
                        16 bit words of data to be read by the list.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The value of the <command>executeList</command>
                        command is an object id for a
                        <type>std::vector&lt;uint16_t&gt;</type>.
                        Use the <command>cccusb::uint16_vector_size</command>
                        command to determine how many words were actually read.
                        Use the <command>cccusb::uint16_vector_get</command>
                        command to fetch elements of that vector.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                The code fragment below shows how to extract data from the
                returned data.  In it, assume that the variable
                <varname>c</varname> holds a
                CCCUSB object command and the variable <varname>l</varname>
                holds the object command of a CCCUSBReadoutList object.
                The creates a hexadecimal dump of the returned words:
            </para>
            <informalexample>
                <programlisting>
set result [$c executeList $l 1000];   # No more than 1000 wds to read.
set nRead [cccusb::uint16_vector_size $result]
for {set i 0} {$i &lt; $nRead} {incr i} {
     puts [format %x [cccusb::uint16_vector_get $result $i]]
}
                </programlisting>
                
            </informalexample>
            <para>
                Note that the <command>executeList</command> requires
                a number which is the maximum number of <type>uint16_t</type>
                values that will be read by the list.  This is used to allocate
                the read buffer.  The actual count of the words read is then
                used to fill the vector returned by that command.
            </para>
        </refsect1>
        <refsect1>
            <title>VARIABLES</title>
            <para>
                The cccusb package exports the following variables:
            </para>
            <variablelist>
                <varlistentry>
                    <term><varname>cccusb::CCCUSB_X</varname></term>
                    <listitem>
                        <para>
                            Contains the mask of the X response in a
                            Q/X word.   For the simple control and write
                            operations,
                            you can directly test these bits against the
                            command return value.  For simple read operations,
                            you need to take the return value and shift
                            right 24 bits before checking for this bit.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><varname>cccusb::CCCUSB_Q</varname></term>
                    <listitem>
                        <para>
                            Contain the max of the Q response.  See above
                            for how to use it to check for Q responses in operations.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
                <xref linkend='ccusb3-CCCUSB' />
                <xref linkend='ccusb3-cccusbreadoutlist' />
                <xref linkend='ccusb3-CCCUSBReadoutList'/>
            </para>
        </refsect1>
       </refentry>
       <refentry id="ccusb3-cccusbreadoutlist">
         <refmeta>
            <refentrytitle>cccusbreadoutlist</refentrytitle>
            <manvolnum>3ccusb</manvolnum>
         </refmeta>
         <refnamediv>
            <refname>cccusbreadoutlist</refname>
            <refpurpose>Tcl wrapping of <classname>CCCUSBReadoutList</classname></refpurpose>
         </refnamediv>
         
         <refsynopsisdiv>
            <cmdsynopsis>
                <command>
::cccusbreadoutlist::CCCUSBReadoutList <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusbreadoutlist::CCCUSBReadoutList -args
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusbreadoutlist::CCCUSBReadoutList <replaceable>?name?</replaceable> -this <replaceable>ptr</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> -delete              
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> get
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  size
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  clear
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite16 <replaceable>n a f d </replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  addWrite24 <replaceable>n a f d </replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead16 <replaceable>n a f ?lamwait?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  addRead24 <replaceable>n a f ?lamwait</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addControl <replaceable>n a f</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addQStop <replaceable>n a f max ?lamwait?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addQStop24 <replaceable>n a f max ?lamwait? </replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  addQScan <replaceable>n a f max ?lamwait?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRepeat <replaceable>n a f count ?lamwait?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMarker <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>

         </refsynopsisdiv>
         <refsect1>
            <title>DESCRIPTION</title>
            <para>
                This Tcl package is a SWIG wrapper around the
                <classname>CCCUSBReadoutList</classname> C++ package.
                The purpose of this class is to construct list of CC-USB
                operations which can either be executed immediately or
                loaded for execution in response to an event or scaler trigger
                in data taking mode.
            </para>
            <para>
                This extension is an object oriented package.  Users construct
                lists, they stock them with commands, execute or load them and
                then destroy the list.
            </para>
         </refsect1>
         <refsect1>
            <title>
               COMMAND DETAILS
            </title>
            <variablelist>
                <varlistentry>
                    <term><command>::cccusbreadoutlist::CCCUSBReadoutList
                        <replaceable>name</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Constructs a new readout list giving it the object
                            name/id <parameter>name</parameter>. The command
                            returns a wrapped pointer to the underlying
                            <classname>CCCUSBReadoutList</classname> object.
                        </para>
                    </listitem>
                </varlistentry>
               <varlistentry>
                    <term><command>::cccusbreadoutlist::CCCUSBReadoutList -args
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Creates a new readout list allowing SWIG to choose
                            the name of the command bound to it.  The
                            return value of the command is the object command e.g.:
                        </para>
                        <informalexample>
                            <programlisting>
...
set l [cccusbreadoutlist::CCCUSBReadoutList -args]
$l addWrite16 $n $a $f $d
...
                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusbreadoutlist::CCCUSBReadoutList
                        <replaceable>?name?</replaceable> -this <replaceable>ptr</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Wraps a SWIG object id for a readout list in a new
                            object.  If the optional <parameter>name</parameter>
                            parameter is supplied it specifies the object command
                            name, otherwise the object pointer will be the
                            name of the object command.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> -delete</command>
                    </term>
                    <listitem>
                        <para>
                            Destroys a CCCUSBReadoutList SWIG object.
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> get</command>
                    </term>
                    <listitem>
                        <para>
                            Returns an object id for a
                            <type>std::vector&lt;uint16_t&gt;</type> that
                            contains the values of the list.  The elements
                            of this vector can gotten by using
                            <command>ccccusb::uint16_vector get</command>
                            See <xref linkend='ccusb3-cccusb' /> for more
                            information about that command.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> size</command>
                    </term>
                    <listitem>
                        <para>
                            Returns the number of 16 bit words currently in the list
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> clear</command></term>
                    <listitem>
                        <para>
                            Clears the list making it emtpy.
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addWrite16 <replaceable>n a f d </replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Adds a 16 bit CAMAC write of <parameter>d</parameter>
                            to a list.
                            <parameter>n</parameter> and <parameter>
                            a</parameter> determine the module and subaddress
                            targeted by this opertion.  <parameter>f</parameter>
                            specifies the function code which must be in the range
                            <literal>[16..23]</literal>
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addWrite24 <replaceable>n a f d </replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>addWrite16</command> but adds a
                            16 bit write to the list.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addRead16 <replaceable>n a f ?lamwait?</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Adds a 16 bit read to the list.  The CAMAC read is
                            specified by <parameter>n</parameter> (slot),
                            <parameter>a</parameter> (subaddress) and
                            <parameter>f</parameter> (function code). Valid read
                            function codes must be in the range
                            <literal>[0..7]</literal>.
                            If the optional <parameter>lamwait</parameter>
                            parameter is present and true (nonzero)
                            it specifies that the CC-USB
                            should stall until either the module's slot signals
                            a LAM or the LAM times out.  This should not be true
                            for lists that are executed in immediate mode, but only
                            for lists that execute in data acquisition mode.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addRead24 <replaceable>n a f ?lamwait</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>addRead16</command> above, however
                            24 bits of data and the Q, X will be transferred as
                            shown in section 4.6 of the CC-USB manual. Note that
                            the CCUSB Readout Framework will remove those bits
                            from data in the Scaler stack as it is assumed that
                            all of those transfers are 24 bits and that the
                            scaler stack will eventually be passed off to
                            scaler display programs that won't know the
                            Q/X bits are present.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addControl <replaceable>n a f</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Adds a CAMAC non data transfer (control) operation
                            to the list.  <parameter>n</parameter> and
                            <parameter>a</parameter> identify the module
                            slot and subaddress targeted by the operation and
                            <parameter>f</parameter> is the CAMAC function
                            code to be performed.  <parameter>f</parameter>
                            by CAMAC standard must be in the ranges
                            <literal>[8..15], [24..31]</literal>.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addQStop <replaceable>n a f max ?lamwait?</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Adds a Q-stop operation to the list.  Q-Stop operations
                            are block transfers that perform the Same operation
                            at the same target until a transfer count
                            is exhausted or an operation does not result in a
                            Q response from the module.
                        </para>
                        <para>
                            <parameter>n</parameter>, and <parameter>a</parameter>
                            identify the slot and subaddress to which the
                            function code <parameter>f</parameter> is addressed.
                            The assumption is that the operation is a
                            read, that is <parameter>f</parameter> is in the
                            range <literal>[0..7]</literal>.  <parameter>max</parameter>
                            is the maximum number of transfers allowed.
                            If the optional <parameter>lamwait</parameter> parameter
                            is true (default is false), the CC-USB will wait for
                            the module to signal a LAM (or LAM timeout) prior to
                            performing the operation.
                            <parameter>lamwait</parameter> should not be set to
                            true on lists performed in via <command>executeList</command>.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addQStop24 <replaceable>n a f max ?lamwait? </replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>addQStop</command> above but the
                            data transfers are 24 bits wide rather than 16 bits
                            wide.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addQScan <replaceable>n a f max ?lamwait?</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>addQStop</command> however the
                            operation is a Q-Scan.  In a Q-Scan, after each
                            operation the subaddress is incremented.
                            If the subaddress would be <literal>16</literal>
                            the slot is incremented and the subaddress
                            reset to zero.
                        </para>
                        <para>
                            If there is no Q response, the sub address is
                            reset to zero and the slot incremented.  The
                            transfer terminates if either <parameter>max</parameter>
                            operations have taken place or if a transfer
                            results in a false X response (indicating the
                            scan advanced to an empty slot).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addRepeat <replaceable>n a f count ?lamwait?</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            This is the same as <command>addQStop</command>
                            however <parameter>count</parameter> operations
                            are unconditionally performed.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addMarker <replaceable>value</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Writes the 16 bit literal 
                            <parameter>value</parameter> to the output
                            buffer.  For immediate operations this is the
                            buffer of data returned by the <command>executeList</command>
                            operation.  For data acquisition lists, this is the
                            event buffer.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
         </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
                <xref linkend='ccusb3-cccusb' />
                <xref linkend='ccusb3-CCCUSB' />
                <xref linkend='ccusb3-CCCUSBReadoutList' />
            </para>
        </refsect1>
       </refentry>
 
<!-- /manpage -->




<!-- chapter libraries -->
    
<chapter>
    <title>SBS VME Module level device support software</title>
        <para>
            This section of the reference manual describes C++ support for
            electronics (VME and CAMAC) that is used at the NSCL.
            All of this software is in the <emphasis>DeviceSupport</emphasis>
            library.  With the exception of the base CAMAC support, all devices
            have C++ class level support.  base CAMAC support is provided as a set
            of macros.
        </para>
        <para>
            Each page of the manual describes the required header file.  To incorporate any
            of the device suppor modules described in this part, you must link to the
            device support library.  If <replaceable>$DAQROOT</replaceable> is the
            top level of the nsclDAQ installation (/usr/opt/daq/<replaceable>version</replaceable>
            for version <replaceable>version</replaceable> at the NSCL), link by adding the following
            command switches:
            <screen>
<command>-L$DAQROOT/lib -lDeviceSupport -lException $(VMELIBS) -Wl,"-rpath=$DAQROOT/lib"</command>
            </screen>
            The <command>-Wl,"-rpath=$DAQROOT/lib"</command> ensures that at run time, the shared libraries
            that make up the device support software will be located and loaded.
            <command>$(VMELIBS)</command> is
            the set of library switches needed to link the VME support software described in
            the previous part.
        </para>

</chapter>

<!-- /chapter -->

<!-- manpage 3daq -->

        <refentry id="CADC2530">
          <refmeta>
             <refentrytitle>CADC2530</refentrytitle>
             <manvolnum>3DeviceSupport</manvolnum>
          </refmeta>
          <refnamediv>
             <refname>CADC2530</refname>
    	 <refpurpose>Support the Hytec NADC 2530 Peak sensing ADC.</refpurpose>
          </refnamediv>
          
          <refsynopsisdiv>
             <programlisting>
    #include &lt;CADC2530.h&gt;
             </programlisting>
             <classsynopsis>
                <ooclass><classname>CADC2530</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CADC2530</methodname>
                    <methodparam>
                        <type>int</type> <parameter>crateNum</parameter><initializer>0</initializer>
                    </methodparam>
                    <methodparam>
                        <type>long</type> <parameter>nBase</parameter> <initializer>0</initializer>
                    </methodparam>
                </constructorsynopsis>
                <destructorsynopsis>
                    <methodname>~CADC2530</methodname>
                    <void />
                </destructorsynopsis>
                <methodsynopsis>
                    <modifier>static</modifier>
                    <type>bool</type>
                    <methodname>checkCard</methodname>
                    <methodparam>
                        <type>int</type> <parameter>nCrate</parameter>
                    </methodparam>
                    <methodparam>
                        <type>long</type> <parameter>nBase</parameter>
                    </methodparam>
                    <methodparam>
                        <type>unsigned short&amp;</type> <parameter>devType</parameter>
                    </methodparam>
                    <methodparam>
                        <type>unsigned short&amp;</type> <parameter>mfgId</parameter>
                    </methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <modifier>static</modifier> <type>unsigned short</type>
                    <methodname>volt2lld</methodname>
                    <methodparam>
                        <type>double</type> <parameter>volts</parameter>
                    </methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <modifier>static</modifier> <type>unsigned short</type>
                    <methodname>volt2uld</methodname>
                    <methodparam>
                        <type>double</type> <parameter>volts</parameter>
                    </methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>int</type> <methodname>readListEvents</methodname>
                    <methodparam>
                        <type>void*</type> <parameter>buffer</parameter>
                    </methodparam>
                    <methodparam>
                        <type>int&amp;</type> <parameter>nEvents</parameter>
                    </methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>int</type> <methodname>readHistogramChannel</methodname>
                    <methodparam>
                        <type>void*</type> <parameter>buffer</parameter>
                    </methodparam>
                    <methodparam>
                        <type>int</type> <parameter>channel</parameter>
                    </methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>clearHistogramMemory</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>resetCard</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>clearListAddress</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>getListAddress</methodname>
                                              <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>arm</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>disarm</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isArmed</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>modeHistogram</methodname>
                    <methodparam>
                        <type>bool</type> <parameter>individualGates</parameter>
                    </methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>modeGate</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>dataReady</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>enableGate</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>disableGate</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>enableZeroCnv</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>disableZeroCnv</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>dataReadyOnEvent</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>dataReadyOnFullness</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>setLLD</methodname>
                    <methodparam>
                        <type>unsigned short</type> <parameter>register</parameter>
                    </methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned short</type> <methodname>getLLD</methodname>
                                                <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>setULD</methodname>
                    <methodparam>
                        <type>unsigned short</type> <parameter>register</parameter>
                    </methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned short</type> <methodname>getULD</methodname>
                                                <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>clearFullnessFlags</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isChannelFull</methodname>
                    <methodparam>
                        <type>unsigned short</type> <parameter>channel</parameter>
                    </methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>channelHasData</methodname>
                    <methodparam>
                        <type>unsigned short</type> <parameter>channel</parameter>
                    </methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isListFull</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isListHalfFull</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>getEventCounter</methodname>
                                              <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>clearEventCounter</methodname>
                                      <void />
                </methodsynopsis>
             </classsynopsis>
          </refsynopsisdiv>
          <refsect1>
             <title>Description</title>
             <para>
                The Hytec NADC 2530 is an 8 channel high resolution ADC.
                The area of application is intended to be high resolution
                gamma spectroscopy.  This class provides support for this module.
                While the target for this support is the NSCLDAQ readout frameworks,
                support is general and does not assume it will be used within
                NSCLDAQ.
             </para>
             <para>
                The NADC 2530 can produce either list mode (event by event) data
                or it can be programmed to produce full resolution histograms.
                The <classname>CADC2530</classname>
                class supports both modes of operation.
             </para>  
          </refsect1>
          <refsect1>
             <title>
                Public member functions
             </title>
            <constructorsynopsis>
                <methodname>CADC2530</methodname>
                <methodparam>
                    <type>int</type> <parameter>crateNum</parameter><initializer>0</initializer>
                </methodparam>
                <methodparam>
                    <type>long</type> <parameter>nBase</parameter> <initializer>0</initializer>
                </methodparam>
            </constructorsynopsis>
            <para>
                Constructs an instance of a
                <classname>CADC2530</classname>
                class.  The object created allows you to manipulate a single
                module.
                <parameter>crateNum</parameter> is the VME crate in which the
                module lives.  For single crate systems, this is
                <literal>0</literal> for multi-crate systems, use the
                <application>cratelocator</application> application to
                determine which crate is which.
                <parameter>nBase</parameter>
                is the base address that has been assigned to the module via
                it's addressing jumper block.
            </para>
            <para>
                It is an error, which results in an
                <classname>std::string</classname>
                exception being thrown for the crate and base address to
                not correspond to an NADC 2530 module.
            </para>
            <destructorsynopsis>
                <methodname>~CADC2530</methodname>
                <void />
            </destructorsynopsis>
            <para>
                Releases all mapping and memory resources associated with a
                previously constructed
                <classname>CADC2530</classname> module.
            </para>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type>
                <methodname>checkCard</methodname>
                <methodparam>
                    <type>int</type> <parameter>nCrate</parameter>
                </methodparam>
                <methodparam>
                    <type>long</type> <parameter>nBase</parameter>
                </methodparam>
                <methodparam>
                    <type>unsigned short&amp;</type> <parameter>devType</parameter>
                </methodparam>
                <methodparam>
                    <type>unsigned short&amp;</type> <parameter>mfgId</parameter>
                </methodparam>
            </methodsynopsis>
           <para>
                Determines if the base address
                <parameter>nBase</parameter>
                in VME crate
                <parameter>nCrate</parameter>
                corresponds to an NADC 2530 module.
                If it does, <literal>true</literal>
                is returned, otherwise
                <literal>false</literal>
            </para>
            <para>
                The <parameter>devType</parameter> and
                <parameter>mfgId</parameter> parameters are output parameters
                that will be filled in with the module's device and manufacturer
                id's respectively.
            </para>
            <methodsynopsis>
                <modifier>static</modifier> <type>unsigned short</type>
                <methodname>volt2lld</methodname>
                <methodparam>
                    <type>double</type> <parameter>volts</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                The NADC 2530 module can constrain converted channels to lie
                between a lower and upper leve threshold.  This threshold
                is common across all channels in the module.  The relationship
                between voltage and the value of the register is a non-linear
                formula described in the NADC2530 manual.
            </para>
            <para>
                This method converts floating point voltages into a value
                that can be passed to the
                <methodname>setLLD</methodname> function of a specific
                module object.
            </para>
            <methodsynopsis>
                <modifier>static</modifier> <type>unsigned short</type>
                <methodname>volt2uld</methodname>
                <methodparam>
                    <type>double</type> <parameter>volts</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                The NADC 2530 module can constrain converted channels to lie
                between a lower and upper leve threshold.  This threshold
                is common across all channels in the module.  The relationship
                between voltage and the value of the register is a non-linear
                formula described in the NADC2530 manual.
            </para>
            <para>
                This method converts floating point voltages into a value
                that can be passed to the
                <methodname>setULD</methodname> function of a specific
                module object.
            </para>
            <methodsynopsis>
                <type>int</type> <methodname>readListEvents</methodname>
                <methodparam>
                    <type>void*</type> <parameter>buffer</parameter>
                </methodparam>
                <methodparam>
                    <type>int&amp;</type> <parameter>nEvents</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Reads at most <parameter>nEvents</parameter> complete events
                from the module's list memory to the memory pointed to by
                <parameter>buffer</parameter>.
                The <parameter>buffer</parameter>
                should be at least <literal>40*nEvents</literal> bytes long
                to be able to accomodate the worst case data needs.
            </para>
            <para>
                On return,
                <parameter>nEvents</parameter>
                is modified to be the number of events actually read.
                The function returns the number of bytes of data read.
                For this to make sense, the module must be in
                list mode rather than histogram mode.  If the module is in
                histogram mode, undefined, bad things will happen.
            </para>
            <methodsynopsis>
                <type>int</type> <methodname>readHistogramChannel</methodname>
                <methodparam>
                    <type>void*</type> <parameter>buffer</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>channel</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Reads the channels of a histogram.   The module must be in
                histogram mode.
            </para>
            <para>
                The histogram is read into the storage pointed to by
                <parameter>buffer</parameter>.
                <parameter>channel</parameter> selects which channel,
                <literal>1</literal> through <literal>8</literal> is transferred.
            </para>
            <para>
                <parameter>buffer</parameter>
                must be at least 8192 <type>uint32_t</type> long.  Each channel
                of the histogram occupies one longword of <parameter>buffer</parameter>.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>clearHistogramMemory</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Clears all the channels of all of the histograms in the module.
                The module should be in histogram mode.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>resetCard</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Resets the card to its factory default mode.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>clearListAddress</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                In list mode, the module contains list memory.  The list address
                is the offset to this memor in which the next event will be stored.
                invoking this member function resets that offset to zero.
            </para>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>getListAddress</methodname>
                                          <void />
            </methodsynopsis>
            <para>
                Returns the current value of the list offset.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>arm</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Arms the module.  Arming the module is what starts it taking data,
                or histogramming, depending on the mode.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>disarm</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Disarms the module.  Disarming the module stops data taking
                or histogramming.
            </para>
            <methodsynopsis>
                <type>bool</type> <methodname>isArmed</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Returns <literal>true</literal> if the module is armed.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>modeHistogram</methodname>
                <methodparam>
                    <type>bool</type> <parameter>individualGates</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Sets the module in histogramming mode.  If
                <parameter>individualGatse</parameter> is
                <literal>true</literal>, adc channels
                digitize when their associated gate input tells them to.
                If  <literal>false</literal> the adcs self trigger.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>modeGate</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                This method is only useful in list mode.  It informs the module
                to take data when the common gate is strobed.
            </para>
            <methodsynopsis>
                <type>bool</type> <methodname>dataReady</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Returns
                <literal>true</literal>
                if the module is in list mode and has at least one event ready
                to be read from list memory.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>enableGate</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Enables the front panel master gate.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>disableGate</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Disables the front panel master gate.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>enableZeroCnv</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Enables the inclusion of conversions below the low level
                discriminator in the list mode data.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>disableZeroCnv</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Disables the inclusion of conversions below the low level
                discriminator setting in  list mode data (enables zero supression).
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>dataReadyOnEvent</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Enables the setting of the data ready condition when the first
                event is stored.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>dataReadyOnFullness</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Enables the setting of data ready only when either a histogram
                channel overflows (histogram mode), or when the list mode
                memory is full.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>setLLD</methodname>
                <methodparam>
                    <type>unsigned short</type> <parameter>register</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Sets the value of the lower level discriminator for the ADC.
                <parameter>register</parameter> should be a value returned from
                <methodname>volt2lld</methodname>.
            </para>
            <methodsynopsis>
                <type>unsigned short</type> <methodname>getLLD</methodname>
                                            <void />
            </methodsynopsis>
            <para>
                Returns the low level discriminator value.  This is the computed
                DAC value for the LLD, not the voltage.  The DAC value is
                related to the voltage as follows:
                <literal>
                    <![CDATA[DAC = (((V/3.2764)/(0.25/4095)) <<2)&0x3ffc]]>
                </literal>
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>setULD</methodname>
                <methodparam>
                    <type>unsigned short</type> <parameter>register</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Sets the DAC of the upper level discriminator.
                <parameter>register</parameter>
                should be a value returned from
                <methodname>volt2uld</methodname>.
            </para>
            <methodsynopsis>
                <type>unsigned short</type> <methodname>getULD</methodname>
                                            <void />
            </methodsynopsis>
            <para>
                Returns the value of the upper level discriminator DAC register.
                This is related to the voltage as follows:
                <literal>
                    <![CDATA[DAC = ((((V/3.2764)-2)/(0.25/4095))<<2)&0x3FFC]]>
                </literal>
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>clearFullnessFlags</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Clears any fullness condition.
            </para>
            <methodsynopsis>
                <type>bool</type> <methodname>isChannelFull</methodname>
                <methodparam>
                    <type>unsigned short</type> <parameter>channel</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Returns
                <literal>true</literal>
                if the histogram for the specified
                <parameter>channel</parameter>
                has overflowed.
            </para>
            <methodsynopsis>
                <type>bool</type> <methodname>channelHasData</methodname>
                <methodparam>
                    <type>unsigned short</type> <parameter>channel</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Returns <literal>true</literal> if the histogram for the
                specified <parameter>channel</parameter>
                has at least one channel with 1/2 full scale counts.
            </para>
            <methodsynopsis>
                <type>bool</type> <methodname>isListFull</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Returns <literal>true</literal> if the list mode memory
                is full.  Current firmware will actually set the state to full
                if the memory has insufficient room for the worst case event
                (40 bytes/10 32 bit longwords).  This ensures that the
                list memory will only contain complete events.
            </para>
            <methodsynopsis>
                <type>bool</type> <methodname>isListHalfFull</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Returns <literal>true</literal> if the module is in listmode
                and the list memory is more than 1/2 full.
            </para>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>getEventCounter</methodname>
                                          <void />
            </methodsynopsis>
            <para>
                Returns the number of events that have been acquired since the
                last clear.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>clearEventCounter</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Clears the event counter.
            </para>
          </refsect1>
       </refentry>
    
    <refentry id="CAENcard">
        
        <refmeta>
            <refentrytitle>CAENcard</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CAENcard</refname>
            <refpurpose>Support for the CAEN 32 bit digitizers</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
        <programlisting>
#include &lt;CAENcard.h&gt;
        </programlisting>
        <classsynopsis language="c++">
            <ooclass><classname>CAENcard</classname></ooclass>
            <constructorsynopsis>
                <methodname>CAENcard</methodname>
                <methodparam><type>int</type> <parameter>slotNum</parameter><initializer>-1</initializer></methodparam>
                <methodparam><type>int</type> <parameter>crateNum</parameter><initializer>0</initializer></methodparam>
                <methodparam><type>bool</type> <parameter>fGeo</parameter><initializer>true</initializer></methodparam>
                <methodparam><type>long</type> <parameter>nBase</parameter><initializer>0</initializer></methodparam> 
            </constructorsynopsis>
            <methodsynopsis>
                <type>int</type>
                    <methodname>getPhysicalCrate</methodname>
                    <void />
                    <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>getSlot</methodname>
                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type>
                <methodname>isGeo</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>unsigned long</type>
                <methodname>getBase</methodname>
                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>getSerial</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>getHardwareRev</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>cardType</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>getFirmware</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>getCrate</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <void />
                <methodname>setCrate</methodname>
                <methodparam><type>int</type> <parameter>crateNum</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <void />
                <methodname>setThreshold</methodname>
                <methodparam><type>int</type> <parameter>ch</parameter></methodparam>
                <methodparam><type>int</type> <parameter>threshold</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <void />
                <methodname>keepUnderThresholdData()</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <void /><methodname>discardUnderThresholdData</methodname><void />
            </methodsynopsis>
            <methodsynopsis>
                <void /><methodname>keepOverflowData</methodname><void />
            </methodsynopsis>
            <methodsynopsis>
                <void /><methodname>discardOverflowData</methodname><void />
            </methodsynopsis>
            <methodsynopsis>
                <void /><methodname>keepInvalidData</methodname><void />
            </methodsynopsis>
            <methodsynopsis>
                <void /><methodname>discardInvalidData</methodname><void />
            </methodsynopsis>
            <methodsynopsis>
                <void /><methodname>commonStart</methodname><void />
            </methodsynopsis>
            <methodsynopsis>
                <void /><methodname>commonStop</methodname><void />
            </methodsynopsis>
            <methodsynopsis>
                <void />
                <methodname>setRange</methodname>
                <methodparam><type>int</type> <parameter>range</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <void />
                <methodname>setPedestalCurrent</methodname>
                <methodparam><type>int</type> <parameter>ped</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <void /><methodname>cardOff</methodname><void />
            </methodsynopsis>
            <methodsynopsis>
                <void /><methodname>cardOn</methodname><void />
            </methodsynopsis>
            <methodsynopsis>
                <void /><methodname>channelOff</methodname>
                <methodparam><type>int</type> <parameter>ch</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <void />
                <methodname>channelOn</methodname>
                <methodparam><type>int</type> <parameter>ch</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <void />
                <methodname>resetEventCounter</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <void />
                <methodname>clearData</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <void />
                <methodname>reset</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <void />
                <methodname>dataPresent</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type>
                <methodname>gdataPresent</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type>
                <methodname>Busy</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type>
                <methodname>gBusy</methodname>
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type>
                <methodname>MEBFull</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type>
                <methodname>MEBEmpty</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>readEvent</methodname>
                <methodparam><type>void*</type> <parameter>buf</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>readEvent</methodname>
                <methodparam><type>DAQWordBuffer&amp;</type> <parameter>wbuf</parameter></methodparam>
                <methodparam><type>int</type> <parameter>offset</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>readEvent</methodname>
                <methodparam><type>DAQWordBufferPtr&amp;</type> <parameter>wp</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>getIped</methodname>
            </methodsynopsis>
            <methodsynopsis>
                <void />
                <methodname>setFastClearWindow</methodname>
                <methodparam><type>int</type> <parameter>n</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <void />
                <methodname>enableSmallThresholds</methodname>
                <void/>
            </methodsynopsis>
            <methodsynopsis>
                <void />
                <methodname>disableSmallThresholds</methodname><void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>EventCount</methodname>
            </methodsynopsis>
        </classsynopsis>
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                This class provides support for several 32 channel CAEN VME digitizers.
                The CAEN V775, V785, V792, V862, 11785 are essentially software compatible (they
                are all based on the same base board of a 32 channel peak sensing ADC with differing
                daughter board front ends.
            </para>
            <para>
                These modules have both 16 and 32 channel versions.  The 16 channel versions look
                exactly like the 32 channel versions except that only the even channels
                have been populated.
            </para>
            <para>
                Some modules are capable of <firstterm>geographic addressing</firstterm>.
                In this mode, the base address of the module is determined by the VME slot
                in which it is installed.  To be used in geographical addressing mode, the
                module must have three connectors to the backplane as must the backplane as the
                slot number is encoded on the middle connector of the backplane.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                        <funcdef> <function>CAENcard</function></funcdef>
                        <paramdef><type>int</type> <parameter>slotNum</parameter>=-1</paramdef>
                        <paramdef><type>int</type> <parameter>crateNum</parameter>=0</paramdef>
                        <paramdef><type>bool</type> <parameter>fGeo</parameter>=true</paramdef>
                        <paramdef><type>long</type> <parameter>nBase</parameter>=0</paramdef>
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Constructs a CAENcard object to communicate with a digitizer.
                                <parameter>slotNum</parameter> is the geographical address of the
                                module, <parameter>fGeo</parameter> is true, this is the slot the
                                module is installed.  If not, this is the geographical address
                                that is assigned to the module in software (virtual slot).
                            </para>
                            <para>
                                <parameter>crateNum</parameter> is the VME crate number.  If
                                omitted, this is assumed to be 0, which is suitable for a single
                                crate system. See the reference page for <command>cratelocator</command>
                                for information about how to determine which crate is which
                            </para>
                            <para>
                                If <parameter>fGeo</parameter> is false, the module requires a
                                <parameter>nBase</parameter> parameter to specify the base address
                                set in the rotary switches of the module.  Otherwise, the
                                module's bases address is gotten from the physical slot of the
                                crate.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>int</type> <function>getPhysicalCrate</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returnst the crate number the module is specified to be installed in.
                                This is the <parameter>crateNum</parameter> parameter passed to
                                the constructor.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>int</type> <function>getSlot</function></funcdef>
                                <void />    
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the module virtual slot number.  This is just the value of
                                the <parameter>slotNum</parameter> parameter given to the
                                constructor for this module.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>bool</type> <function>isGeo</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the module was constructed via
                                a geograhpical address. <literal>false</literal> is returned if
                                base addressing was used to construct the module.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                           <funcsynopsis><funcprototype>
                                <funcdef><type>unsigned long</type> <function>getBase</function></funcdef>
                                <void />
                           </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the module base address.  This value is only well defined
                                if geographical addressing was <emphasis>not</emphasis>
                                used to construct the module.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>int</type> <function>getSerial</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                        <para>
                            Returns the serial number of the module.  This is the same as the number
                            stamped on the serial number tag on the faceplate of the module.
                        </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>int</type> <function>getHardwareRev</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the hardware version register from the module PROM.
                                It is not clear to me what this is or what the format is.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>int</type>  <function>cardType</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>               
                        </term>
                        <listitem>
                            <para>
                                Returns the model number of the card, e.g. <literal>785</literal>
                                for a V785 peak sensing adc.  Submodel information (e.g. N for NIM) is
                                not returned by this function.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                           <funcsynopsis><funcprototype>
                                <funcdef><type>int</type>  <function>getFirmware</function></funcdef>
                                <void />
                           </funcprototype></funcsynopsis> 
                        </term>
                        <listitem>
                            <para>
                                Returns the firmware revision of the module.  This is the version
                                of the firmware chip plugged into the lower left hand side of
                                the module as you hold it connectors facing to the left. The
                                firmware is returned as a 16 bit number with the top byte the major
                                version (the part to the left of the decimal point), the bottom byte
                                the minor version.  So a return value of 0x0901 corresponds to
                                firmware revision 9.01.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>int</type>  <function>getCrate</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the value of the crate register of the module.  At construction
                                time, this is programmed to be the physical crate number.
                                Calling <function>setCrate</function>, however can change the
                                value of this register making it a virtual crate number.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>setCrate</function></funcdef>
                                <paramdef><type>int</type> <parameter>crateNum</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the crate register of the module to <parameter>crateNum</parameter>
                                This value will be reported as the module crate number in the
                                data returned from the module.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                           <funcsynopsis><funcprototype>
                               <funcdef><type>void</type> <function>setThreshold</function></funcdef>
                               <paramdef><type>int</type> <parameter>ch</parameter></paramdef>
                               <paramdef><type>int</type> <parameter>threshold</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the threshold of one or all channels to <parameter>threshold</parameter>.
                                What this means depends on whether small or large thresholds are
                                enabled (the default is large thresholds). If small thresholds are
                                enabled, the threshold value is multiplied by 2 and applied to the
                                incoming data.  Large threshold multiply this value by
                                16.
                            </para>
                            <para>
                                If the <parameter>ch</parameter> value is not <literal>-1</literal>,
                                it designates the channel to program (remember that a 16 channel
                                module only uses the even numbered channels of the digitizer so
                                ignore the front panel numbering).  If <literal>-1</literal>
                                all threshold registers are set to the common value
                                <parameter>threshold</parameter>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                               <funcdef><type>void</type> <function>keepUnderThresholdData</function></funcdef>
                               <void />
                            </funcprototype></funcsynopsis>   
                        </term>
                        <listitem>
                            <para>
                                If called, the module will not supress data that is under the
                                threshold.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                               <funcdef><type>void</type> <function>discardUnderThresholdData</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                If called the module will supress data that is under the threshold
                                value.  A key to getting this module to work efficiently is to
                                set appropriate threshold values and then to call this function. If
                                this is not done, you will get 34 longwords of data from this
                                module for each event, rather than only receiving channels that
                                have useful data.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                               <funcdef><type>void</type> <function>keepOverflowData</function></funcdef>
                               <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                If called, the module will retain data that has overflowed.
                                This is usually important for a TDC.  Overflow data indicates a
                                channel did not have an input and over-ranged.  
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>discardOverflowData</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                If this is called, the module will discard data that has overflowed.
                                This is mostly useful for TDC modules, to discard overranged times.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>keepInvalidData</function></funcdef>
                                <void />
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                I'm not 100% sure what effect this has on the module. If data
                                are <firstterm>invalid</firstterm> (whatever that means), they
                                will nonetheless appear in the data stream from the module
                                (presumably with the valid bit clear).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis><funcprototype>
                            <funcdef><type>void</type> <function>discardInvalidData</function></funcdef>
                            <void />
                                 </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Again see above.  If data are <firstterm>invalid</firstterm> they
                                will be discarded from the data stream.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>commonStart</function></funcdef>
                                <void />
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                If the module is a TDC it is set in common start mode.
                                The gate input is a start and the individual channel
                                inputs stop that channel.  If the module is not a TDC,
                                a <classname>std::string</classname> exception will be thrown
                                explaining this fact.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>commonStop</function></funcdef>
                                <void />
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                If the module is a TDC, it is set to common stop mode.
                                Individual channel inputs are individual starts while the
                                common stop is the module Gate input.  If the module is not a TDC,
                                this function throws a <classname>std:string</classname> exception.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>setRange</function></funcdef>
                                <paramdef><type>int</type> <parameter>range</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the range of the module if it is a TDC.   See the CAEN module
                                hardware book for more information about this parameter which is
                                programmed without interpretation into the range register.
                                If the module is not a TDC, a <classname>std::string</classname>
                                exception will be thrown.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>setPedestalCurrent</function></funcdef>
                                <paramdef><type>int</type> <parameter>ped</parameter></paramdef>
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This sets the pedestal compensation current for QDC modules.
                                If the module is not a QDC a <classname>std::string</classname>
                                exception is thrown.  QDC's operate by integrating charge on a
                                capacitor.  As the charge is integrating during the gate,
                                it is also  leaking, as capacitors are imperfect.  For sufficiently
                                long gate times it is possible to distort the charge integration
                                unless an initial charge is injected to compensate for the leakage.
                                This function sets the amount of charge initially injected.
                                The value should be larger for longer gates, and smaller for
                                smaller gates.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>cardOff</function></funcdef>
                                <void />
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This function disables the module completely.  The action is the
                                same as setting all channels to disabled.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>cardOn</function></funcdef>
                                <void />
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This function re-enables a card that has been disabled by a call
                                to <function>cardOff</function>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>channelOff</function></funcdef>
                                <paramdef><type>int</type> <parameter>ch</parameter></paramdef>
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Turns off channel <parameter>ch</parameter>.  The specified channel
                                will no longer contribute data.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>channelOn</function></funcdef>
                                <paramdef><type>int</type> <parameter>ch</parameter></paramdef>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Enables the channel specified by <parameter>ch</parameter> if it
                                has previously been disabled by a call to
                                <function>channelOff</function>
                                                                 </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis><funcprototype>
                            <funcdef><type>void</type> <function>resetEventCounter</function></funcdef>
                            <void />
                                      </funcprototype>
                        </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Reset the module's event counter.  The event counter can be read via
                                <function>EventCount</function>.  The event counter is also
                                placed in the trailer longword of each event that contributes data
                                to the output stream.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>clearData</function>
                                </funcdef>
                                 <void />
                                 </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Clears any buffered events from the module.  Remember that the
                                module is a multievent digiitizer.  If you are attempting to
                                run it in single event mode, you need to clear the data between
                                each event to ensure that any events that have <emphasis>leaked</emphasis>
                                in your dead time have been cleared from the system.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>reset</function></funcdef>
                                <void />
                                           </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Perform a soft reset on the module.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>bool</type> <function>dataPresent</function></funcdef>
                                <void />
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the module's data buffer is
                                not empty (that is there is at least one complete event int he buffer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis>
                                <funcprototype>
                                    <funcdef><type>bool</type> <function>gdataPresent</function></funcdef>
                                    <void />
                                </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                If the control bus of several modules is bussed together, this
                                function returns <literal>true</literal> if any of the modules
                                on that bus has data.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>bool</type> <function>Busy</function></funcdef>
                                <void />
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the module is busy.
                                The module can be busy either because it is actively digitizing
                                an event (6microseconds), or because the multi event buffer is full
                                (until at least one event is read out or the module is cleared).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type> bool</type> <function>gBusy</function></funcdef>
                                <void />
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the gBusy pin on the external
                                control bus is asserted.  If the control bus is bussed with other
                                modules, this is true if any module in the control bus is busy.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>bool</type> <function>MEBFull</function></funcdef>
                                <void />
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the multiple event buffer int he module is full.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>bool</type> <function>MEBEmpty</function></funcdef>
                                <void />
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the module's multi-event
                                buffer is empty.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>int</type> <function>readEvent</function></funcdef>
                                <paramdef><type>void*</type> <parameter>buf</parameter></paramdef>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Reads a single event from the module into the buffer pointed to
                                by <parameter>buf</parameter>.  The buffer must be at least
                                34 longwords long.  The return value is the number of bytes
                                that were placed in the buffer.  This could be zero.
                                   </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>int</type> <function>readEvent</function></funcdef>
                                <paramdef><type>DAQWordBuffer&amp;</type> <parameter>wbuf</parameter></paramdef>
                                <paramdef><type>int</type> <parameter>offset</parameter></paramdef>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Reads an event in to the spectrodaq buffer <parameter>wbuf</parameter>
                                The event is placed at word offset <parameter>offset</parameter>
                                from the start of the buffer.  The return value is the number of
                                16 bit words read to the buffer.  This could be 0.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>int</type> <function>getIped</function></funcdef>
                                <void />
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the value of the pedestal injection current register
                                for QDC modules.  Throws a <classname>std::string</classname>
                                exception for non QDCs.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>setFastClearWindow</function></funcdef>
                                <paramdef><type>int</type> <parameter>n</parameter></paramdef>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the module fast clear register value to <parameter>n</parameter>.
                                This register determines how long after the gate input the
                                module may be cleared without providing data.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>enableSmallThresholds</function></funcdef>
                                <void />
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Turns on small threshold mode.  The values programmed into the
                                channel thresholds will be multiplied by 2 and then applied as
                                the threshold for a valid conversion.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>disableSmallThresholds</function></funcdef>
                                <void />
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Turns off small threhodls.  Threshold values for each channel
                                will be multiplied by 16 before being applied.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </refsect1>
        <refsect1>
            <title>Types and public data</title>
            <para>
                The following data types defined in <literal>&lt;spectrodaq.h&gt;</literal>
                are used by this module:
                <variablelist>
                    <varlistentry>
                        <term><type>DAQWordBuffer</type></term>
                        <listitem>
                            <para>
                                A spectrodaq buffer of word wide items.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>DAQWordBufferPtr</type></term>
                        <listitem>
                            <para>
                                A pointer like object into a <type>DAQWordBuffer</type>
                                object.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
            <para>
                The following constants are defined in the header that are useful
                when treating data from the digitizers:
                <variablelist>
                    <varlistentry>
                        <term><varname>CAEN_DATUM_TYPE</varname></term>
                        <listitem>
                            <para>
                                A mask of the bits in data from the digitizer that
                                isolates the data word type field.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>CAEN_HEADER</varname></term>
                        <listitem>
                            <para>
                                Data type field value for event headers.
                                If <code>(datum &amp; CAEN_DATUM_TYPE) == CAEN_HEADER</code>
                                then <varname>datum</varname> is a CAEN module event header.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>CAEN_DATA</varname></term>
                        <listitem>
                            <para>
                                Data type field value for channel data.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>CAEN_FOOTER</varname></term>
                        <listitem>
                        <para>
                            Data type field value for end of event data footer longwords.
                        </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>CAEN_INVALID</varname></term>
                        <listitem>
                            <para>Data type field value for longwords returned when
                                reading an event buffer that has no data.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </refsect1>
        <refsect1>
            <title>Exceptions</title>
            <para>
                Many functions throw <classname>std::string</classname> exceptions.
            </para>
        </refsect1>
        <refsect1>
            <title>Examples</title>
            <para>
                Create a <classname>CAENcard</classname> module in
                geographical mode:
                <example>
                    <title>Creating a CAENcard geographically</title>
                    <programlisting language="c++">
#include &lt;CAENcard.h&gt;
&hellip;
   CAENcard* pCard = new CAENcard(5);
&hellip;
                    </programlisting>
                </example>
            </para>
            <para>
                <example>
                    <title>Setting a TDC to common stop mode</title>
                    <programlisting language="c++">
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;CAENcard.h&gt;
&hellip;
    CAENcard* pCard;
&hellip;
    try {
      pCard->commonStart();
    }
    catch (string msg) {
      cerr &lt;&lt; "Failed to set module  in common start mode";
      cerr &lt;&lt; " module type: V" &lt;&lt; pCard->cardType() &lt;&lt; endl;
      cerr &lt;&lt; "Message: " &lt;&lt; msg &lt;&lt;; endl;
      cerr.flush();
      throw;
    }   
&hellip;
                    </programlisting>
                </example>
        </para>
        <para>
            <example>
                <title>Reading out a CAEN 785 e.g.</title>
                <programlisting language="c++">
#include &lt;CAENcard.h&gt;
#include &lt;spectrodaq.h&gt;
#define CAENTIMEOUT 50
&hellip;
   CAENcard* pModule;
&hellip;
   for(int i =0; i &lt; CAENTIMEOUT; i++) {
     if (pModule-&gt;dataPresent()) {
       break;
     }
   }
   if (pModule-&gt;dataPresent()) {
      pModule-&gt;readEvent(bufpt);
   }    
&hellip;
                </programlisting>
            </example>
        </para>
        </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
The relevant CAEN hardware module documentation, <ulink url="http://www.caen.it" />
has current online versions of most of their manuals.  An old V785 manual is online
at the NSCL at <ulink url="http://groups.nscl.msu.edu/nscl_library/manuals/caen/MOD.V785.pdf" />
            </para>
        </refsect1>
    </refentry>
    <refentry id="CBD8210">
        
        <refmeta>
            <refentrytitle>CBD8210</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CBD8210</refname>
            <refpurpose>CES CBD 8210 CAMAC branch highway driver (obsolete)</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
       <programlisting language="c++">
#include &lt;CBD8201.h&gt;
       </programlisting>
       <classsynopsis language="c++">
            <ooclass><classname>CBD8210 : public CCamacModule</classname></ooclass>
            <constructorsynopsis>
                <methodname>CBD8210</methodname>
                <methodparam><type>int</type> <parameter>branch</parameter></methodparam>
            </constructorsynopsis>
            <methodsynopsis>
                <type>bool</type>
                    <methodname>Xtest</methodname>
                    <void />
                    <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type> <methodname>Qtest</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type> <methodname>TimedOut</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type> <methodname>BranchDemand</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>MNoX</methodname>
                <methodparam><type>bool</type> <parameter>fSet</parameter><initializer>true</initializer></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>MTo</methodname>
                <methodparam><type>bool</type> <parameter>fSet</parameter><initializer>true</initializer></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>MLAM</methodname>
                <methodparam><type>bool</type> <parameter>fSet</parameter><initializer>true</initializer></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>MIT2</methodname>
                <methodparam><type>bool</type> <parameter>fSet</parameter><initializer>true</initializer></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>MIT4</methodname>
                <methodparam><type>bool</type> <parameter>fSet</parameter><initializer>true</initializer></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>MIT4</methodname>
                <methodparam><type>bool</type> <parameter>fSet</parameter><initializer>true</initializer></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type> <methodname>IT2</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type> <methodname>IT4</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>unsigned short</type> <methodname>ReadCsr</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>WriteCsr</methodname>
                <methodparam><type>unsigned short</type> <parameter>nMask</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>WriteIFR</methodname>
                <methodparam><type>unsigned short</type> <parameter>nMask</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>unsigned short</type> <methodname>ReadBTB</methodname>
                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>unsigned long</type> <methodname>ReadGl</methodname>
                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>  <methodname>InitBranch</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            </classsynopsis>
        </refsynopsisdiv>
        <refsect1>
            <title>DESCRIPTION</title>
            <para>
                The <classname>CBD8210</classname> class encapsulates the
                functions offered by the register set of the CES CBD8210 VME CAMAC parallel
                branch driver module.  This module is an obsolete module.  Newer applications
                should use the Wiener VC32/CC32 module pair, or better yet, phase out of CAMAC
                altogether.
            </para>
            <para>
                Since this class is derived from legacy support where only a single VME crate was
                allowed, multiple VME crate support is a bit whacky.  Each VME crate can have up
                to 8 branches.  The branch number is determined by:
                <literal>vme_crate*8 + branch_selector</literal>  where
                <varname>vme_crate</varname> is the VME crate number the CES CBD8210 is
                installed in and <varname>branch_selector</varname> is the branch number
                selected on the module's front panel. 
            </para>  
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <para>
                <variablelist>
                    <varlistentry>
                       <term>
                            <funcsynopsis><funcprototype>
                        <funcdef> <function>CBD8210</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>b</parameter></paramdef>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Constructor, creates a new CBD8210 module for
                                branch number <parameter>b</parameter>.  See
                                DESCRIPTION above for more information about the branch number.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>bool</type> <function>Xtest</function></funcdef>
                                <void /><modifier>const</modifier>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Tests the <literal>X</literal> response of the last
                                operaration on this branch.  An X response is true if the
                                addressed module has accepted the function.  Usually this
                                is the case if there is a live module at the addressed location.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>bool</type> <function>Qtest</function></funcdef>
                                <void /><modifier>const</modifier>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Checks the <literal>Q</literal> response of the last
                                operation.  The Q response is used for two purposes in general.
                                If the operation is not a test, the Q indicates successful
                                completion of the operation, otherwise it indicates the result of
                                the test.  For example, a module may not accept some functions
                                int the <firstterm>busy</firstterm> state.  Q may be <literal>false</literal>
                                if one such
                                function was attempted and the module was busy.  For example:
                                most modules have function codes for testing their <firstterm>LAM</firstterm>
                                (Look At Me). These functions will return Q
                                <literal>true</literal>
                                if the LAM is active, and <literal>false</literal> otherwise.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>bool</type> <function>TimedOut</function></funcdef>
                                <void /><modifier>const</modifier>
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the last operation on this
                                branch timed out.  In general this can only happen if the
                                CAMAC crate being addressed was off, or unplugged from the
                                branch highway, or has a failing controller.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>bool</type> <function>BranchDemand</function></funcdef>
                                <void /><modifier>const</modifier>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if there's a branch demand present.
                                Branch demands are used to indicate the presence of a LAM
                                in a CAMAC crate on the branch that has its LAM added to the
                                set of graded LAM demands.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>MNoX</function></funcdef>
                                <paramdef><type>bool</type> <parameter>fSet</parameter>=true</paramdef>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets/clears the controller's <literal>MNOX</literal> bit in the
                                control/status
                                register according to the value of <parameter>fSet</parameter>.
                                Normally, the branch highway driver will  interrupt
                                if an operation is performed and an X is not present.  Setting
                                this bit prevents that interrupt.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>MTo</function></funcdef>
                                <paramdef><type>bool</type> <parameter>fSet</parameter>=true</paramdef>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This sets or clears the <literal>MTO</literal> bit in the
                                control/status register of the module.  When MTO is clear,
                                branch timeouts result in an interrupt, when set, this interrupt
                                is inhibited.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>MLAM</function></funcdef>
                                <paramdef><type>bool</type> <parameter>fSet</parameter>=true</paramdef>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets or clears the <literal>MLAM</literal> bit in the
                                module's control/status register.
                                according to the value of <parameter>fSet</parameter>.
                                If this bit is clear,
                                Branch Demands (LAMs from a crate) will result in a VME bus
                                interrupt.  If set, interrupts will not occur.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>MIT2</function></funcdef>
                                <paramdef><type>bool</type> <parameter>fSet</parameter>=true</paramdef>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets or clears the <literal>MIT2</literal> bit in the
                                module control/status register according to the value of
                                <parameter>fSet</parameter>.
                                If the bit is clear, a NIM pulse on the IT2 input of the module
                                results in a VME interrupt.  If set, no interrupt is generated.
                                Note that the pulse latches a status bit which can be read
                                via <function>IT2</function>.
                                </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>MIT4</function></funcdef>
                                <paramdef><type>bool</type> <parameter>fSet</parameter>=true</paramdef>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets or clears the control status register's <literal>MIT4</literal>
                                bit according to the state of <parameter>fSet</parameter>
                                When clear, the IT4 input causes an interrupt. When set, IT4
                                does not cause an interrupt, but latches a status bit that can
                                be read via the <function>IT4</function> function.
                                                              </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>bool</type> <function>IT4</function></funcdef>
                                <void /><modifier>const</modifier>
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Tests the state of the IT4 bit in the interrupt status register.
                                If an IT4 input has been latched this will return
                                <literal>true</literal> otherwise <literal>false</literal>.
                                To clear the latched IT4 status, you must write the IT4 bit
                                to the IFR (see <function>WriteIFR</function>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>unsigned short</type> <function>ReadCsr</function></funcdef>
                                <void /> <modifier>const</modifier>
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Reads the contents of the module control status register.
                                See the manual for the CBD 8210 for information about the
                                layout of this register.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>WriteCsr</function></funcdef>
                                <paramdef><type>unsigned short</type> <parameter>nMask</parameter></paramdef>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Writes <parameter>nMask</parameter> to the module control status
                                register.  See the hardware manual for the module for more information
                                about the layout of this register.
                                       </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>WriteIFR</function></funcdef>
                                <paramdef><type>unsigned short</type> <parameter>nMask</parameter></paramdef>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Writes the <parameter>nMask</parameter> parameter to the module's
                                <literal>IFR</literal> register.  The layout of this register
                                is documented in the CES CBD8210 hardware manual.  Note, however
                                that this register is used to clear latched <literal>IT2</literal>
                                and <literal>IT4</literal> inputs.
                                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>unsigned short</type> <function>ReadBTB</function></funcdef>
                                <void /><modifier>const</modifier>
        
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Reads the branch timing register from the module.  The BTB register
                                is a bit mask with a bit for each crate.  It allows you to
                                determine which crates are on/offline.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>unsigned long</type> <function>ReadGl</function></funcdef>
                                <void /><modifier>const</modifier>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Reads the graded LAM mask for the branch. See the
                                CES CBD8210 manual for more information about graded lams
                                and the layout of this register.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>InitBranch</function></funcdef>
                                <void /> <modifier>const</modifier>
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Performs a Branch Zero (<literal>BZ</literal>) on the branch.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </refsect1>
        <refsect1>
            <title>Examples</title>
            <para>
                The example below access branch 0, and does a <literal>BZ</literal>:
                <example>
                    <title>Initializing branch 0</title>
                    <programlisting>
#include &lt;CBD8210.h&gt;
&hellip;
   CBD8210 branch0(0);
   branch.InitBranch();
&hellip;
                    </programlisting>
                </example>
            </para>
        </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
                The CES CBD 8210 hardware manual (online at the NSCL at:
                <ulink url="http://groups.nscl.msu.edu/nscl_library/manuals/ces/8210_v20.pdf" />
            </para>
        </refsect1>
    </refentry>
        <refentry id="CCAENV1x90">
            
            <refmeta>
                <refentrytitle>CCAENV1x90</refentrytitle>
                <manvolnum>3DeviceSupport</manvolnum>
            </refmeta>
            
            <refnamediv>
                <refname>CCAENV1x90</refname>
                <refpurpose>Support for the CAEN V1190 and V1290
                    multihit, complicated TDC.</refpurpose>
            </refnamediv>
            
            <refsynopsisdiv>
            <programlisting language="c++">
#include &lt;CCAENV1x90.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CCAENV1x90</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CCAENV1x90</methodname>
                    <methodparam><type>unsigned int</type> <parameter>nSlot</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>nCrate</parameter></methodparam>
                    <methodparam><type>unsigned long</type> <parameter>nBase</parameter></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>getModel</methodname>
                    <void /><modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned char</type> <methodname>getVersion</methodname>
                    <void /><modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>getSerialNumber</methodname>
                    <void /><modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>getChipCount</methodname>
                    <void /><modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>getChannelCount</methodname>
                    <void /><modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned short</type> <methodname>SR</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isSetSR</methodname>
                    <methodparam><type>unsigned short</type> <parameter>bitnum</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned short</type> <methodname>ReadCR</methodname>
                                                <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isSetCR</methodname>
                    <methodparam><type>unsigned short</type> <parameter>bitnum</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Terminate</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Unterminate</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>TerminateWithSwitch</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>EnableTriggerTagTime</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>DisableTriggerTagTime</methodname>
                                     <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>DataReady</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type>
                    <methodname>AlmostFull</methodname><void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type>
                    <methodname>isFull</methodname><void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type>
                    <methodname>isTriggerMatching</methodname> <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isHeaderEnabled</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isTerminated</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type>
                    <methodname>HadError</methodname>
                    <methodparam><type>unsigned int</type> <parameter>nChip</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>int</type>  <methodname>ReadResolution</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isPairMode</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type>
                    <methodname>WereTriggersLost</methodname> <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>SetGeographicalID</methodname>
                    <methodparam><type>unsigned short</type> <parameter>int</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned short</type>
                    <methodname>GetGeographicalID</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>Reset</methodname><void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>Clear</methodname><void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>EventReset</methodname><void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>Trigger</methodname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned long</type>
                    <methodname>TriggerCount</methodname><void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned short</type>
                    <methodname>EventCount</methodname><void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>SetAlmostFullLevel</methodname>
                    <methodparam><type>unsigned int</type> <parameter>nWords)</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned short</type>
                    <methodname>GetAlmostFullLevel</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>DefineECLOutput</methodname>
                    <methodparam><type>ECLOutputSelect</type> <parameter>signal</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>ECLOutputSelect</type>
                    <methodname>GetECLOutputDefinition</methodname><void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned short</type>
                    <methodname>EventFIFOCount</methodname><void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned long</type>
                    <methodname>ReadEventFIFO</methodname><void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type>  <methodname>isEventFIFOReady</methodname><void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type>   <methodname>isEventFIFOFull</methodname><void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned short</type>
                    <methodname>FIFOEventNumber</methodname>
                    <methodparam><type>unsigned long</type> <parameter>fifoentry</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned short</type>
                    <methodname>FIFOWordCount</methodname>
                    <methodparam><type>unsigned long</type> <parameter>fifoentry</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>TriggerMatchMode</methodname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>ContinuousStorageMode</methodname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>TransferUntilDone</methodname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>TransferOneAtATime</methodname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>LoadDefaultConfig</methodname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>SaveUserConfig</methodname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>LoadUserConfig</methodname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>AutoLoadUserConfig</methodname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>AutoLoadDefaultConfig</methodname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>SetWindowWidth</methodname>
                    <methodparam><type>unsigned int</type> <parameter>nWidth</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>SetWindowOffset</methodname>
                    <methodparam><type>int</type> <parameter>nOffset</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>SetExtraSearchMargin</methodname>
                    <methodparam><type>unsigned int</type> <parameter>nMargin</parameter>
                    </methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetRejectMargin</methodname>
                    <methodparam><type>unsigned int</type> <parameter>Margin</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>EnableTriggerTimeSubtraction</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>DisableTriggerTimeSubtraction</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>TriggerConfiguration</type>
                    <methodname>GetTriggerConfiguration()</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type>
                    <methodname>GetMatchWindow</methodname>
                    <methodparam><type>TriggerConfiguration</type> <parameter>config</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>int</type> <methodname>GetWindowOffset</methodname>
                    <methodparam><type>TriggerConfiguration</type> <parameter>config</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type>
                    <methodname>GetExtraSearchMargin</methodname>
                    <methodparam><type>TriggerConfiguration</type> <parameter>config</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type>
                    <methodname>GetRejectMargin</methodname>
                    <methodparam><type>TriggerConfiguration</type> <parameter>config</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type>
                    <methodname>isTriggerTimeSubtracted</methodname>
                    <methodparam><type>TriggerConfiguration</type> <parameter>config</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>SetEdgeDetectMode</methodname>
                    <methodparam><type>EdgeMode</type> <parameter>nEdgeMode</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>EdgeMode</type> <methodname>GetEdgeDetectMode</methodname>
                                          <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>SetIndividualLSB</methodname>
                    <methodparam><type>Resolution</type> <parameter>nResolution</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>SetPairResolutions</methodname>
                    <methodparam><type>LEResolution</type> <parameter>nLeadingEdge</parameter></methodparam>
                    <methodparam><type>PWResolution</type> <parameter>nPulseWidth</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned short</type>
                    <methodname>GetResolution</methodname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>Resolution</type>
                    <methodname>InterpretEdgeResolution</methodname>
                    <methodparam><type>unsigned short</type> <parameter>nResolution</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>LEResolution</type>
                    <methodname>InterpretLEResolution</methodname>
                    <methodparam><type>unsigned short</type> <parameter>nResolution</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>PWResolution</type>
                    <methodname>InterpretWidthResolution</methodname>
                    <methodparam><type>unsigned short</type> <parameter>nResolution</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>SetDoubleHitResolution</methodname>
                    <methodparam><type>DeadTime</type> <parameter>nDead</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>DeadTime</type>
                    <methodname>GetDoubleHitResolution</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>EnableTDCEncapsulation</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>DisableTDCEncapsulation</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type>
                    <methodname>isTDCEncapsulationOn</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>SetMaxHitsPerEvent</methodname>
                    <methodparam><type>HitMax</type> <parameter>nHits</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>HitMax</type>
                    <methodname>GetMaxHitsPerEvent</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>EnableErrorMark</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>DisableErrorMark</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>EnableBypassOnError</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>DisableBypassOnError</methodname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>SetErrorEnables</methodname>
                    <methodparam><type>unsigned short</type> <parameter>nErrors</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned short</type>
                    <methodname>GetErrorEnables</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>SetL1Size</methodname>
                    <methodparam><type>L1Size</type> <parameter>nL1Size</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>L1Size</type>
                    <methodname>GetL1Size</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>EnableChannel</methodname>
                    <methodparam><type>unsigned short</type> <parameter>nChannel</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>DisableChannel</methodname>
                    <methodparam><type>unsigned short</type>
                                 <parameter>nChannel</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>EnableAllChannels</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>DisableAllChannels</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>SetChannelEnables</methodname>
                    <methodparam><type>std::vector&lt;unsigned short&gt;</type> <parameter>masks</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>
                    <methodname>GetChannelEnables</methodname>
                    <methodparam><type>std::vector&lt;unsigned short&gt;&amp;</type>
                                 <parameter>masks</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetChipEnables</methodname>
                    <methodparam><type>unsignedshort</type> <parameter>nChip</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>nMask</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>GetChipEnables</methodname>
                    <methodparam><type>unsigned short</type> <parameter>nChip</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>GetChipId</methodname>
                    <methodparam><type>unsigned short</type> <parameter>nChip</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>GetuCFirmwareInfo</methodname>
                    <methodparam><type>unsigned short&amp;</type> <parameter>nRevision</parameter></methodparam>
                    <methodparam><type>unsigned short&amp;</type> <parameter>nDay</parameter></methodparam>
                    <methodparam><type>unsigned short&amp;</type> <parameter>nMonth</parameter></methodparam>
                    <methodparam><type>unsigned short&amp;</type> <parameter>nYear</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned short</type> <methodname>GetChipErrors</methodname>
                    <methodparam><type>unsigned short</type> <parameter>nChip</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>ReadData</methodname>
                    <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>nMaxLongs</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>ReadPacket</methodname>
                    <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>nMaxLongs</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis><type>unsigned int</type> <methodname>ReadValid</methodname>
                    <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>nMaxLongs</parameter></methodparam>
                </methodsynopsis>
            </classsynopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>Description</title>
                <para>
                    This very complex class provides support for the very complex CAEN V1190 and
                    CAEN V1290 multhit TDCs and their variants.  Be sure you have read the
                    manual on this TDC thoroughly before you attempt to program the device.
                    While there are models of this device that are capable of geographical addressing,
                    We have not purchased them.  The software is  written only to support base addressing.
                </para>
                <para>
                    The TDC is essentially a free running time digitizer.  When used in trigger matching
                    mode, it can simulate a common stop or commnon start multihit TDC.
                    One important point is
                    that times relative to the trigger will jitter by the module's FPGA clock. If you
                    use this module you must digitize the gate time in one channel as well so that you
                    can compute gate relativel timing by digital subtraction.  Only in this way will
                    you get the full time resolution offered by the TDC.
                </para>
            </refsect1>
            <refsect1>
                <title>Public member functions</title>
                <para>
                    For the data types specific to the module support code, see the section
                    <literal>Types and pulbic data</literal> below.
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                            <funcdef><function>CCAENV1x90</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>nSlot</parameter></paramdef>
                        <paramdef><type>unsigned int</type> <parameter>nCrate</parameter></paramdef>
                        <paramdef><type>unsigned long</type> <parameter>nBase</parameter></paramdef>
                        
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Called when a CAENV1x90 object is created to initialize the object
                                and, provisionally, the module represented by the object.
                                <parameter>nSlot</parameter> is the geographical address that
                                will be assigned to the module.
                                <parameter>nCrate</parameter> and <parameter>nBase</parameter>
                                define the location of the module in VME space in terms of a VME
                                crate number and an <literal>A32</literal> base address withihn that
                                crate.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                            <term>
                        <funcsynopsis><funcprototype><funcdef>
                        <type>unsigned int</type> <function>getModel</function></funcdef>
                        <void /><modifier>const</modifier>
                                      </funcprototype></funcsynopsis>
                            </term>
                            <listitem>
                                <para>
                                    Returns the model number of the device.  This will be either
                                    <literal>1190</literal> or <literal>1290</literal>
                                </para>
                            </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <funcsynopsis><funcprototype><funcdef>
                            <type>unsigned char</type> <function>getVersion</function></funcdef>
                            <void /><modifier>const</modifier>
                        </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the sub model of the device.  This is the single letter
                                that follows the device model number and currently can be one of
                                <literal>N</literal>, <literal>'A'</literal>, or
                                <literal>'B'</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>                  
                                <type>unsigned int</type> <function>getSerialNumber</function></funcdef>
                                <void /><modifier>const</modifier>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Return the serial number of the device.  This serial number is also
                                stamped on the small metal tag at the bottom of the module front panel.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned int</type> <function>getChipCount</function></funcdef>
                                <void /><modifier>const</modifier>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the number of TDC chips on the board.  Some of the models,
                                like the 1290N only have 2 TDC chips on board while most others
                                have 4.  As some functions require you to supply a TDC number,
                                this function can be called to determine how high the TDC number
                                is allowed to go.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned int</type> <function>getChannelCount</function></funcdef>
                                <void /><modifier>const</modifier>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the number of TDC channels supported by the board.  This
                                is a function of whether or not the module is an 1190, 1290 and
                                whether it has the N suffix after its model number.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned short</type> <function>SR</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the contents of the board's status register.  Normally
                                you will not need to call this function.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>bool</type> <function>isSetSR</function></funcdef>
                                <paramdef><type>unsigned short</type> <parameter>bitnum</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns true if the bit numbered <parameter>bitnum</parameter> is set
                                in the board status register.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned short</type> <function>ReadCR</function></funcdef>
                                                            <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the current value of the control register.  Normall you
                                will not need to invoke this function.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>bool</type> <function>isSetCR</function></funcdef>
                                <paramdef><type>unsigned short</type> <parameter>bitnum</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the bit numbered
                                <parameter>bitnum</parameter> is set in the control register.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type> <function>Terminate</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Enables the on board termination of the module inputs.
                                See <function>Unterminate</function> and
                                <function>TerminateWithSwitch</function> for other alternatives.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type> <function>Unterminate</function></funcdef>
                                                  <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Disable on board termination of the module's inputs.
                                See <function>Terminate</function>
                                and <function>TerminateWithSwitch</function> for other options.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type> <function>TerminateWithSwitch</function></funcdef>
                                                  <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Set the module so that it's slide switch enables or disables termination.
                                See <function>Terminate</function>
                                and <function>Unterminate</function> for alternatives to this.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type> <function>EnableTriggerTagTime</function></funcdef>
                                                  <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Tells the module to place the time of the trigger input in the
                                buffer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type> <function>DisableTriggerTagTime</function></funcdef>
                                                 <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Tells the module not to place the time of the trigger input in the
                                buffer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>bool</type> <function>DataReady</function></funcdef>
                                                  <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if data can be read from the
                                TDC module (the data buffer has some data).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>bool</type>
                                <function>AlmostFull</function></funcdef><void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the amount of data in the module
                                exceeds the <firstterm>almost full</firstterm> threshold
                                programmed into it.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>bool</type>
                                <function>isFull</function></funcdef><void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns
                                <literal>true</literal> of the data buffer for the module is full.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>bool</type>
                                <function>isTriggerMatching</function></funcdef> <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the module has been set to trigger
                                matching mode. In trigger matching mode, times are collected into events
                                that occur within some defined time window of the trigger.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>bool</type> <function>isHeaderEnabled</function></funcdef>
                                                  <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the module has been told to insert
                                event header information in the data stream.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>bool</type> <function>isTerminated</function></funcdef>
                                                  <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the module inputs are terminated.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>bool</type>
                                <function>HadError</function></funcdef>
                                <paramdef><type>unsigned int</type> <parameter>nChip</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the module reported an error.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>int</type>  <function>ReadResolution</function></funcdef>
                                                  <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Return the resolution code from the module.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>bool</type> <function>isPairMode</function></funcdef>
                                                  <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the module has been programmed in
                                pair mode.  Pair mode measures the times between pulse pairs, rather
                                than the timing of individual pulses.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>bool</type>
                                <function>WereTriggersLost</function></funcdef> <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the board missed triggers
                                due to rate conditions.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>SetGeographicalID</function></funcdef>
                                <paramdef><type>unsigned short</type> <parameter>int</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the geographical ID of the module.  The geographical Id is a
                                virtual slot number that is presented in the data stream from the module
                                to identify where the data came from.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned short</type>
                                <function>GetGeographicalID</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the module's geographical id.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>Reset</function></funcdef><void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Does a soft reset on the module.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>Clear</function></funcdef><void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Clears any data the module may have stored in its fifo buffer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                              <type>void</type>
                              <function>EventReset</function></funcdef><void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Resets the event counter to zero .
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>Trigger</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Peforms a software trigger.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned long</type>
                                <function>TriggerCount</function></funcdef><void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the number of events the module has had since
                                the last event count reset.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned short</type>
                                <function>EventCount</function></funcdef><void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the number of events that resulted in data stored in the buffer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>SetAlmostFullLevel</function></funcdef>
                                <paramdef><type>unsigned int</type> <parameter>nWords)</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Defines the FIFO almost full level.  If there are more than
                                <parameter>nWords</parameter> longowrds of data in the FIFO,
                                the board is considered to be  almost full of data and
                                calls to <function>AlmostFull</function> will result in
                                <literal>true</literal>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned short</type>
                                <function>GetAlmostFullLevel</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the number of longwords that define the FIFO almost full
                                condition.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>DefineECLOutput</function></funcdef>
                                <paramdef><type>ECLOutputSelect</type> <parameter>signal</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Selects the meaning of the ECL user output of the module. See
                                the section "Types and Public Data" for a definition of
                                <type>ECLOutputSelect</type> the legal values it can take and
                                what they mean.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>ECLOutputSelect</type>
                                <function>GetECLOutputDefinition</function></funcdef><void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the meaning of the ECL user output.  See the section
                                Types and Public Data" for a definition of
                                <type>ECLOutputSelect</type> the legal values it can take and
                                what they mean.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned short</type>
                                <function>EventFIFOCount</function></funcdef><void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the number of events stored in the module FIFO.
                                This is done by reading the <firstterm>Event FIFO Stored Register</firstterm>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned long</type>
                                <function>ReadEventFIFO</function></funcdef><void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Reads the event FIFO.  This a destructive read, in the sense
                                that once read the datum read cannot be reread.  The Event
                                FIFO is a longword.  The lower 16 bits are the number of
                                words in an event, while the upper 16 bits are the event number
                                of an event.  You can use this to determine how many words to read
                                from the module event FIFO for an event.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>bool</type>  <function>isEventFIFOReady</function></funcdef><void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the Event FIFO is not empty.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>bool</type>   <function>isEventFIFOFull</function></funcdef><void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal>  if the event FIFO is true.  The event FIFO can
                                only hold 1024 longwords.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned short</type>
                                <function>FIFOEventNumber</function></funcdef>
                                <paramdef><type>unsigned long</type> <parameter>fifoentry</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the event number field from the <parameter>fifoentry</parameter>
                                which was returned via  <function>ReadEventFIFO</function>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned short</type>
                                <function>FIFOWordCount</function></funcdef>
                                <paramdef><type>unsigned long</type> <parameter>fifoentry</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Given a <parameter>fifoentry</parameter> received from a call to
                                <function>ReadEventFIFO</function> returns the value of the
                                event word count field.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>TriggerMatchMode</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the module in trigger match mode.  In this mode, hits in the
                                channels are grouped into events that are within a programmable timing
                                window of the gate input.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>ContinuousStorageMode</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the module into continous storage mode.  In this mode,
                                hits are just recorded relative to the last Reset time (bunch reset),
                                without any time relationship constraints.  Think of this data
                                as a stream of hits.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>TransferUntilDone</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This mode refers to the manner in which data from a single TDC chip
                                are transferred to the data buffer.  After calling this function,
                                each TDC transfer data from its L1 storage into the FIFO event buffer
                                until an event has been completely read in before yielding the data
                                path to the FIFO to the next TDC chip.
                            </para>
                            <para>
                                See also <function>TransferOneAtATim</function> which is an alternative
                                to this.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>TransferOneAtATime</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                See also <function>TransferUntilDone</function> after transferring
                                a single hit to the output event FIFO, each TDC chip yields the
                                data path to the next TDC.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>LoadDefaultConfig</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets up the module with the default trigger configuration:
                                <itemizedlist>
                                    <listitem><para>Continuous storage mode</para></listitem>
                                    <listitem><para>Window width 500ns</para></listitem>
                                    <listitem><para>Window Offset -1us.</para></listitem>
                                    <listitem><para>Reject margin 100ns</para></listitem>
                                    <listitem><para>Extra search margin 200ns</para></listitem>
                                    <listitem><para>All channels enabled</para></listitem>
                                </itemizedlist>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>SaveUserConfig</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Saves the current trigger configuration as the <firstterm>User
                                Trigger Configuration</firstterm>.  The user trigger configuration
                                can be loaded via a call to
                                <function>LoadUserConfig</function>, or made to load on power up
                                via a call to <function>AutoLoadUserConfig</function>.  The
                                user trigger configuration is stored in non-volatile memory and
                                therefore preserved across power cycles of the board.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>LoadUserConfig</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Loads the most recently saved user trigger configuration.
                                The user trigger configuration is created by programming the
                                trigger and calling <function>SaveUserConfig</function>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>AutoLoadUserConfig</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the module to load the user configuration on power up or
                                reset.  This should be used with extreme caution and only with TDC
                                modules you own.  Otherwise you can be handing a board to
                                someone that will power up with  a trigger configuration that is
                                much different than what the user might expect from reading
                                the manual.  Similarly, because someone could have done this to you,
                                you should call <function>LoadDefaultConfiguration</function> prior
                                to setting up the trigger configuration so that you  are
                                starting from a known initial state.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>AutoLoadDefaultConfig</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Causes the default trigger configuration to be loaded on the
                                next power up or reset.  If you are using the module in an\
                                application where you have called <function>AutoLoadUserConfig</function>,
                                it would be polite to call this before returning the module to the
                                pool so that it has expected behavior on power up.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>SetWindowWidth</function></funcdef>
                                <paramdef><type>unsigned int</type> <parameter>nWidth</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the trigger matching window width.  The window width and the
                                window offset (see <function>SetWindowOffset</function>) are the main
                                parameters that determine
                                which hits are grouped together into an event when the module is set to
                                trigger matching mode.  See also the TDC hardware manual where the
                                trigger matching parameters are discussed in detail.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>SetWindowOffset</function></funcdef>
                                <paramdef><type>int</type> <parameter>nOffset</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the offset of the window relative to the gate of the trigger
                                matching window.  This offset defines the time that the trigger match
                                window opens relative to the gate.  The window offset
                                together with the window width
                                (see <function>SetWindowWidth</function>) defines the time window during
                                which hits are collected into events when the module is run in trigger
                                matching mode.  See the TDC hardware manual where the trigger
                                matchin paramters are discussed in detail.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>SetExtraSearchMargin</function></funcdef>
                                <paramdef><type>unsigned int</type> <parameter>nMargin</parameter>
                                </paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the trigger matching extra search margin.  This is an additional
                                slice of time at the end of the trigger matching window during which
                                hits will be accepted into an event.  This helps compensate for internal
                                pipeline and clock jitter delays that would otherwise prematurely
                                cut off the trigger match window.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type> <function>SetRejectMargin</function></funcdef>
                                <paramdef><type>unsigned int</type> <parameter>Margin</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the width of an additional bit of time at the front of the
                                trigger matching window during which hits will be accepted into
                                an event in trigger matching mode.  This helps compensate for the
                                jitter of the start in the trigger matching window due to the
                                granularity of the FPGA clock.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type> <function>EnableTriggerTimeSubtraction</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Tells the module to subtract the trigger time from times produced in
                                trigger matching mode.  Note that you must still provide a time reference
                                channel as the trigger time granularity is that of the FPGA clock
                                rather than the resolution of the TDC chip.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type> <function>DisableTriggerTimeSubtraction</function></funcdef>
                                                  <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Turns off the subtraction of the trigger time from the times produced
                                by the module in trigger matching mode.  The times will be relative
                                to the last 'bunch reset'.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>TriggerConfiguration</type>
                                <function>GetTriggerConfiguration</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the entire trigger configuration.  The resulting
                                <type>TriggerConfiguration</type> data type is documented in
                                the section "Types and Public Data" below, however normally you use
                                it by handing it to functions like <function>GetMatchWindow</function> e.g.
                                that knwow how to extract elements of the trigger configuration.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned int</type>
                                <function>GetMatchWindow</function></funcdef>
                                <paramdef><type>TriggerConfiguration</type> <parameter>config</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the trigger match window from the <parameter>config</parameter>
                                <type>TriggerConfiguration</type>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>int</type> <function>GetWindowOffset</function></funcdef>
                                <paramdef><type>TriggerConfiguration</type> <parameter>config</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the window offset from the <parameter>config</parameter>
                                <type>TriggerConfiguration</type>
                                parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned int</type>
                                <function>GetExtraSearchMargin</function></funcdef>
                                <paramdef><type>TriggerConfiguration</type> <parameter>config</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the extra search margin from the
                                <parameter>config</parameter>
                                <type>TriggerConfiguration</type> parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>unsigned int</type>
                                <function>GetRejectMargin</function></funcdef>
                                <paramdef><type>TriggerConfiguration</type> <parameter>config</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Get the trigger rejection margin from the <parameter>
                                                                            config</parameter>
                                                                          <type>TriggerConfiguration</type>
                                                                          </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>bool</type>
                                <function>isTriggerTimeSubtracted</function></funcdef>
                                <paramdef><type>TriggerConfiguration</type> <parameter>config</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> If the <parameter>config</parameter>
                                <type>TriggerConfiguration</type> would enable trigger time
                                subtraction.
                                                                       </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>void</type>
                                <function>SetEdgeDetectMode</function></funcdef>
                                <paramdef><type>EdgeMode</type> <parameter>nEdgeMode</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Sets the edge detection mode of the TDC
                                to <parameter>nEdgeMode</parameter>.  The edge detection mode
                                defines what a hit is and what the TDC measures.  The
                                <type>EdgeMode</type> type, and the meaning of the values it can
                                take are described in the section
                                "Types and Public Data" below.
                                   </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype><funcdef>
                                <type>EdgeMode</type> <function>GetEdgeDetectMode</function></funcdef>
                                <void />
                            </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the currently programmed edge detection mode.
                                See "Types and Public Data below for a description of the
                                <type>EdgeMode</type> data type, the values it can have, and
                                what they mean.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                <varlistentry>
                    <term>
                        <funcsynopsis>
                        <funcprototype><funcdef>
                                <type>void</type>
                                <function>SetIndividualLSB</function></funcdef>
                                <paramdef><type>Resolution</type> <parameter>nResolution</parameter></paramdef>
                            </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects the resolution (meaning of the Least Significant Bit of the time)
                            for all TDC chips.  The data type <type>Resolution</type> is
                            described in the section "Types and Public Data" below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <funcsynopsis>
                        <funcprototype><funcdef>
                        <type>void</type>
                        <function>SetPairResolutions</function></funcdef>
                        <paramdef><type>LEResolution</type> <parameter>nLeadingEdge</parameter></paramdef>
                        <paramdef><type>PWResolution</type> <parameter>nPulseWidth</parameter></paramdef>                        
                        </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the time resolutions of the leading edge and pair timings.
                             The meaning of the data types
                            <type>PWResolution</type> and <type>LEResolution</type> are described in the section
                            "Types and Public Data" below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term>
                    <funcsynopsis>
                    <funcprototype><funcdef>
                    <type>unsigned short</type>
                    <function>GetResolution</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns information about the resolution settings programmed into the
                            TDC module.  The <type>unsigned short</type> that was returned is
                            intended to be passed to functions like
                            <function>InterpretEdgeResolution</function> to get detailed information
                            about the resolution.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <funcsynopsis><funcprototype><funcdef>
                    <type>Resolution</type>
                    <function>InterpretEdgeResolution</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nResolution</parameter></paramdef>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Given a resolution value returned from <function>GetResolution</function>
                            Returns the edge resolutions that are encoded in it.  See
                            "Types and Public Data" below for a description of
                            <type>Resolution</type> and its legal values.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <funcsynopsis><funcprototype><funcdef>
                    <type>LEResolution</type>
                    <function>InterpretLEResolution</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nResolution</parameter></paramdef>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Interprets and returns the leading edge resolution from a value
                            returned by <function>GetResolution</function>.
                            See "Types and Public Data" below for more a description of
                            of the <type>LEResolution</type> data type, and the values it can
                            take.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <funcsynopsis><funcprototype><funcdef>
                    <type>PWResolution</type>
                    <function>InterpretWidthResolution</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nResolution</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Interprets and returns the pair widht resolution from an value that
                            was gotten from <function>GetResolution</function>.
                            See "Types and Public Data" below for more information about the
                            <type>PWResolution</type> and the values it can take.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>SetDoubleHitResolution</function></funcdef>
                    <paramdef><type>DeadTime</type> <parameter>nDead</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Set the double hit resolution of the TDC.  This is the deadtime
                            between hits during which another hit will not be recorded.
                            See "Types and Public Data" below for more information about the
                            <type>DeadTime</type> data type and the values it can take.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>DeadTime</type>
                    <function>GetDoubleHitResolution</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Returns the currently programmed double hit resolution.
                            See "Types and Public Data" below for more information about
                            the <type>DeadTime</type> data type and the values it can take.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>EnableTDCEncapsulation</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Turns on the encapsulation of the data from a single TDC chip
                            in chip headers and trailers.  See the TDC hardware manual
                            for information about the nature and format of these headers
                            and trailers.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>DisableTDCEncapsulation</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Turns off the encapsulation of the data from a single TDC chip
                            (see <function>EnableTDCEncapsulation</function>).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>bool</type>
                    <function>isTDCEncapsulationOn</function></funcdef>
                    <void />
                </funcprototype></funcsynopsis></term>
                <listitem>
                    <para>
                        Returns <literal>true</literal> if TDC chip data encapsulation is
                        enabled.
                    </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>SetMaxHitsPerEvent</function></funcdef>
                    <paramdef><type>HitMax</type> <parameter>nHits</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Set the maximum number of hits the tdc board will accept per event
                            (in trigger matching mode).  Note that this is not a per-channel
                            maximum hit count,  but a <emphasis>per-module</emphasis> maximum.
                            See the section "Types and Public Data" for more information about
                            the <type>HitMax</type> data type and the values it can take.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>HitMax</type>
                    <function>GetMaxHitsPerEvent</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the maximum  number of hits that will be accepted within
                            a trigger matching window (defaulted or set by
                            <function>SetMaxHitsPerEvent</function>).
                            See the section "Types and Public Data" for more information about
                            the <type>HitMax</type> data type and the values it can take.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>EnableErrorMark</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables the TDC to insert an error word into the data when an error
                            condition occurs in the TDC.  See the TDC hardware manual for more information
                            about the format of this error word and the error condition it can report.
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>DisableErrorMark</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Turns off the insertion of an error mark word in the data
                            when the TDC detects an error condition.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>EnableBypassOnError</function></funcdef>
                                      <void />
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Enables bypassing TDC chips that detect error conditions.
                            When bypassed a chip will not contribute data to the output stream.
                            See the hardware manual for more information about what this means.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>DisableBypassOnError</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Disables bypassing a TDC chip that has detected an error condition.
                            In this mode, TDC chips with error conditions will continue to contribe
                            data to the output stream to the best of their ability constrained by the
                            actual error condition.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>SetErrorEnables</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nErrors</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Sets the mask of errors the TDC is enabled to detect.  This is a bit mask
                            with bits numbered from lowest oder to highest order defined as followed:
                            <simplelist>
                                <member>
                                    0 - Vernier error, DLL unlocked or excessive jitter.
                                </member>
                                <member>
                                    1 - Coarse error or parity error on coards count.
                                </member>
                                <member>
                                    2 - Channel select error, probably an internal timing error.
                                </member>
                                <member>
                                    3 - L1 buffer parity error
                                </member>
                                <member>
                                    4 - Trigger FIFO parity error.
                                </member>
                                <member>
                                    5 - Trigger matching error (state machine got really mixed up).
                                </member>
                                <member>
                                    6 - Readout FIFO parity error.
                                </member>
                                <member>
                                    7 - Readout state error.
                                </member>
                                <member>
                                    8 - Set up parity error.
                                </member>
                                <member>
                                    9 - Control parity error.
                                </member>
                                <member>
                                    10 - JTAG instruction parity error.
                                </member>
                            </simplelist>
                            When a bit is set, the corresponding error is enabled, otherwise the
                            corresponding error is disabled.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned short</type>
                    <function>GetErrorEnables</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Returns the mask of error enables.  This mask has the same format
                            as the mask described in <function>SetErrorEnables</function>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>SetL1Size</function></funcdef>
                    <paramdef><type>L1Size</type> <parameter>nL1Size</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Set the usable size of the TDC module's level 1 buffer.
                            See "Types and Public Data" below for  a description of the
                            <type>L1Size</type> data type and the values it can assume.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>L1Size</type>
                    <function>GetL1Size</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Returns the current size selected for the level 1 buffer.
                            See "Types and Public Data" below for  a description of the
                            <type>L1Size</type> data type and the values it can assume.                           
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>EnableChannel</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nChannel</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Enables the specified channel.  The channel numbering may  not be
                            obvious for modules other than the V1190 (full 128 channels).
                            Check the hardware manual
                            for more information about this.  <parameter>nChannel</parameter>
                            specifies which channel should be enabled.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>DisableChannel</function></funcdef>
                    <paramdef><type>unsigned short</type>
                                 <parameter>nChannel</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Disables the specified channel.  Note that channel numbering
                            may not be straightforward for modules other than the V1190 (full 128
                            channels).  Be sure to consult the hardware manual for more information
                            about this.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>EnableAllChannels</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Enables all of the channels on the module.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term>
                    <funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>DisableAllChannels</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Disables all of the channels in the modules.  Effectively disables
                            the module for data acquisition.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>SetChannelEnables</function></funcdef>
                    <paramdef><type>std::vector&lt;unsigned short&gt;</type> <parameter>masks</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Sets enables/disables for all of the channels.   <parameter>masks</parameter>
                            is a vector of channel enable/disable masks that supplied 128 bits of
                            enable disable information numbered from low channel to high channel
                            from low bit of the first 16 bits of the first mask through the top bit
                            of the last mask.
                        </para>
                        <para>
                            Be sure that you read the hardware manual for your TDC model before
                            you jump to conclusions about which channels are which.  The mapping
                            of channel numbers to front panel numbers is not always straightforward
                            for modules other than the V1190.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>GetChannelEnables</function></funcdef>
                    <paramdef><type>std::vector&lt;unsigned short&gt;&amp;</type>
                                 <parameter>masks</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Retrieves the channel enable masks.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>SetChipEnables</function></funcdef>
                    <paramdef><type>unsignedshort</type> <parameter>nChip</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>nMask</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Set the channel enables for a single chip.  <parameter>nChip</parameter>
                            selects the chip and <parameter>nMask</parameter> provides the
                            32 bits of channel enables for that chip.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned int</type> <function>GetChipEnables</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nChip</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Returns the enable mask for a single chip.  <parameter>nChip</parameter>
                            selects the chip you are interested in.  The enables are returned as
                            the function value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned int</type> <function>GetChipId</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nChip</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>GetuCFirmwareInfo</function></funcdef>
                    <paramdef><type>unsigned short&amp;</type> <parameter>nRevision</parameter></paramdef>
                    <paramdef><type>unsigned short&amp;</type> <parameter>nDay</parameter></paramdef>
                    <paramdef><type>unsigned short&amp;</type> <parameter>nMonth</parameter></paramdef>
                    <paramdef><type>unsigned short&amp;</type> <parameter>nYear</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned short</type> <function>GetChipErrors</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nChip</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned int</type> <function>ReadData</function></funcdef>
                    <paramdef><type>void*</type> <parameter>pBuffer</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>nMaxLongs</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned int</type> <function>ReadPacket</function></funcdef>
                    <paramdef><type>void*</type> <parameter>pBuffer</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>nMaxLongs</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef><type>unsigned int</type> <function>ReadValid</function></funcdef>
                    <paramdef><type>void*</type> <parameter>pBuffer</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>nMaxLongs</parameter></paramdef>
                    </funcprototype></funcsynopsis>
                            </term>
                            <listitem>
                                <para>
                                </para>
                              </listitem>
                    </varlistentry>
            
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>SetIndividualLSB</function></funcdef>
                    <paramdef><type>Resolution</type> <parameter>nResolution</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>SetPairResolutions</function></funcdef>
                    <paramdef><type>LEResolution</type> <parameter>nLeadingEdge</parameter></paramdef>
                    <paramdef><type>PWResolution</type> <parameter>nPulseWidth</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned short</type>
                    <function>GetResolution</function></funcdef>
                    <void />
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>Resolution</type>
                    <function>InterpretEdgeResolution</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nResolution</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>LEResolution</type>
                    <function>InterpretLEResolution</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nResolution</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>PWResolution</type>
                    <function>InterpretWidthResolution</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nResolution</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>SetDoubleHitResolution</function></funcdef>
                    <paramdef><type>DeadTime</type> <parameter>nDead</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>DeadTime</type>
                    <function>GetDoubleHitResolution</function></funcdef>
                    <void />
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>EnableTDCEncapsulation</function></funcdef>
                    <void />
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>DisableTDCEncapsulation</function></funcdef>
                    <void />
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>bool</type>
                    <function>isTDCEncapsulationOn</function></funcdef>
                    <void />
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>SetMaxHitsPerEvent</function></funcdef>
                    <paramdef><type>HitMax</type> <parameter>nHits</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>HitMax</type>
                    <function>GetMaxHitsPerEvent</function></funcdef>
                    <void />
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>EnableErrorMark</function></funcdef>
                    <void />
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>DisableErrorMark</function></funcdef>
                    <void />
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>EnableBypassOnError</function></funcdef>
                                      <void />
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>DisableBypassOnError</function></funcdef>
                    <void />
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>SetErrorEnables</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nErrors</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned short</type>
                    <function>GetErrorEnables</function></funcdef>
                    <void />
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>SetL1Size</function></funcdef>
                    <paramdef><type>L1Size</type> <parameter>nL1Size</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>L1Size</type>
                    <function>GetL1Size</function></funcdef>
                    <void />
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>EnableChannel</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nChannel</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>DisableChannel</function></funcdef>
                    <paramdef><type>unsigned short</type>
                                 <parameter>nChannel</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>EnableAllChannels</function></funcdef>
                                      <void />
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>DisableAllChannels</function></funcdef>
                    <void />
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>SetChannelEnables</function></funcdef>
                    <paramdef><type>std::vector&lt;unsigned short&gt;</type> <parameter>masks</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>
                    <function>GetChannelEnables</function></funcdef>
                    <paramdef><type>std::vector&lt;unsigned short&gt;&amp;</type>
                                 <parameter>masks</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>SetChipEnables</function></funcdef>
                    <paramdef><type>unsignedshort</type> <parameter>nChip</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>nMask</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned int</type> <function>GetChipEnables</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nChip</parameter></paramdef>
                </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned int</type> <function>GetChipId</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nChip</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Returns the id code fo the TDC.  Note that there is no documentation about
                            possible values that can be returned.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>GetuCFirmwareInfo</function></funcdef>
                    <paramdef><type>unsigned short&amp;</type> <parameter>nRevision</parameter></paramdef>
                    <paramdef><type>unsigned short&amp;</type> <parameter>nDay</parameter></paramdef>
                    <paramdef><type>unsigned short&amp;</type> <parameter>nMonth</parameter></paramdef>
                    <paramdef><type>unsigned short&amp;</type> <parameter>nYear</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Returns the version/release data information about the
                            firmware for the microcontroller that is used to set up
                            the TDC module.  This micro controllers is what the
                            software interacts with to perform most of the operations
                            described up until now.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned short</type> <function>GetChipErrors</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>nChip</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Reads a mask that describes which errors have occured for a specific
                            TDC chip.  See <function>SetErrorEnables</function> for information about
                            the bits in this mask.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned int</type> <function>ReadData</function></funcdef>
                    <paramdef><type>void*</type> <parameter>pBuffer</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>nMaxLongs</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Reads data from the TDC.  This actually <function>ReadPacket</function>
                            if the module is in trigger matching mode or <function>ReadValid</function>
                            if the module is in continuous storage mode.  These two functions
                            are described  below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned int</type> <function>ReadPacket</function></funcdef>
                    <paramdef><type>void*</type> <parameter>pBuffer</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>nMaxLongs</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                           Reads data from the TDC output FIFO into <parameter>pBuffer</parameter>
                            until either
                            <parameter>nMaxLongs</parameter> long words have been read, or until
                            a global trailer is encountered.  When the TDC is in trigger matching mode,
                            and if <parameter>nMaxLongs</parameter> is larger than the
                            the number of longs until the next global trailer, this is equivalent to
                            reading a single event from the TDC.
                            One way to ensure that you read complete events is to read the
                            event FIFO to determine how large the next event is and then
                            read that event once you are sure you have a large enough buffer to hold it.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype>
                        <funcdef><type>unsigned int</type> <function>ReadValid</function></funcdef>
                    <paramdef><type>void*</type> <parameter>pBuffer</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>nMaxLongs</parameter></paramdef>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads data from the TDC into <parameter>Buffer</parameter>
                            a filler word is encountered or until <parameter>nMaxLongs</parameter>
                            longwords have been read, whichever is first.  This is the preferred
                            way to read the module when it is in continuous storage mode.
                        </para>
                    </listitem>
                </varlistentry>
                </variablelist>
            </refsect1>
            <refsect1>
                <title>Types and public data</title>
                <para>
                    This section describes data types that are used in calls to public methods of
                    the <classname>CCAENV1x90</classname> device support class.
                </para>
                <formalpara>
                    <title><structname>ECLOutputSelect</structname></title>
                    <para>
                        The CCAENV1x90 TDC has a programmable ECL output on its control bus.
                        The <structname>ECLOutputSelect</structname> type is an enumerated
                        type that provides symbolic names to the possible signals that can be
                        programmed to appear on this output:
                        <variablelist>
                            <varlistentry>
                                <term><structfield>DATA_READY</structfield></term>
                                <listitem>
                                    <para>
                                        Data are ready in the module.  In the case of trigger matching
                                        mode, I believe data are only ready if a full event has been
                                        digitized and stored.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><structfield>FULL</structfield></term>
                                <listitem>
                                    <para>
                                        The event FIFO buffer is full.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><structfield>ALMOST_FULL</structfield></term>
                                <listitem>
                                    <para>
                                        The FIFO is almost full as defined by the almost full
                                        level programmed in the devie.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><structfield>ERROR</structfield></term>
                                <listitem>
                                    <para>
                                        An error has ocurred in the TDC.
                                    </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </para>
                </formalpara>
                <formalpara>
                    <title><structname>TriggerConfiguration</structname></title>
                    <para>
                        This is a structure, that is intended to be decoded by e.g.
                        <function>GetWindowOffset</function>.  It is the data
                        that is returned from the TDC microcontroller when
                        <function>GetTriggerConfiguration</function> is called.
                        it has the following fields:
                        <variablelist>
                            <varlistentry>
                                <term><type>unsigned short</type> <structfield>s_MatchWidth</structfield></term>
                                <listitem>
                                    <para>
                                        The matching window width in FPGA clock ticks.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><type>short</type> <structfield>s_MatchOffset</structfield></term>
                                <listitem>
                                    <para>
                                        The matching window offset in FPGA clock ticks (signed).
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><type>unsigned short</type> <structfield>s_MatchExtra</structfield></term>
                                <listitem>
                                    <para>
                                        The extra mathing margin.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><type>unsigned short</type> <structfield>s_RejectMargin</structfield></term>
                                <listitem>
                                    <para>
                                        The reject margin of the matching window.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><type>unsigned short</type> <structfield>s_Subtracting</structfield></term>
                                <listitem>
                                    <para>Inidicates if the gate time is subtracted from times in the
                                        matching window.
                                    </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </para>
                </formalpara>
                <formalpara>
                    <title><structname>EdgeMode</structname></title>
                    <para>
                        This is an enumeration whose values are used to specify what constitutes a
                        hit in a channel.
                        <variablelist>
                            <varlistentry>
                            <term><structfield>EdgeMode_Pair</structfield></term>
                            <listitem>
                                <para>
                                    A hit is  a pulse, and the measurement
                                    consists of the time of the leading edge and the width of the
                                    pulse.
                                </para>
                            </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><structfield>EdgeMode_Leading</structfield></term>
                                <listitem>
                                    <para>
                                        A hit is the leading edge of an input pulse.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><structfield>EdgeMode_Trailing</structfield></term>
                                <listitem>
                                    <para>
                                        A hit is the trailing edge of a pulse.
                                    </para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term><structfield>EdgeMode_Both</structfield></term>
                                <listitem>
                                    <para>
                                        Both edges of each pulse are digitized. 
                                    </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </para>
                </formalpara>
                <formalpara>
                    <title><structname>Resolution</structname></title>
                    <para>
                        This is an enumerated type that defines the possible resolutions
                        of the least significant bit of the time measures.  It can take the following
                        values:
                        <variablelist>
                        <varlistentry>
                            <term><structfield>Res_25ps</structfield></term>
                            <listitem>
                                <para>The resolution is 25ps.  This is only legal for the
                                    V1290.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><structfield>Res_100ps</structfield></term>
                            <listitem>
                                <para>The resolution is 100ps.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><structfield>Res_200ps</structfield></term>
                            <listitem>
                                <para>
                                    The resolution is 200ps.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><structfield>Res_800ps</structfield></term>
                            <listitem>
                                <para>
                                    The resolution is 800ps.
                                </para>
                            </listitem>
                        </varlistentry>
                        </variablelist>
                    </para>
                </formalpara>
                <formalpara>
                    <title><structname>LEResolution</structname></title>
                    <para>
                        Specifies the resolution with which the leading pulse in a pulse
                        pair is measured.  This is an enumerated type that has
                        possible values that look like
                        <structname>LE_<replaceable>nnn</replaceable>ps</structname>,
                        where nnn is the number of picoseconds of resolution and can take the values
                        <literal>100, 200, 400, 800, 1600, 3120, 6250,</literal> and
                        <literal>12500</literal>.
                    </para>
                </formalpara>
                <formalpara>
                    <title><structname>PWResolution</structname></title>
                    <para>Specifies the resolution of the width of a pulse pair.
                        This is an enumerated type with two formats:
                        <structfield>PW_<replaceable>nnn</replaceable>ps</structfield>,
                        and <structfield>PW_<replaceable>mmm</replaceable>ns</structfield>.
                        In the first form, <replaceable>nnn</replaceable> is the resolution in picoseconds
                        and can be any of: <literal>100 200 400 800 1600 3200 6250 12500</literal>.
                        In the second form, <replaceable>mmm</replaceable>   is the resolution in nanoseconds
                        and can be any fo the following: <literal>25 50 100 200 400 800</literal>.
                    </para>
                </formalpara>
                <formalpara>
                    <title><structname>DeadTime</structname></title>
                    <para>This enumerated constant specifies the double hit resolution (dead time between
                        conesecutive hits in the same channel.   Values have the form
                        <structfield>DT_<replaceable>nnn</replaceable>ns</structfield>, where
                        <replaceable>nnn</replaceable> is this timing parameter in ns and can be any
                        of the following <literal>5, 10, 30, 100</literal>.
                    </para>
                </formalpara>
                <formalpara>
                    <title><structname>HitMax</structname></title>
                    <para>
                        This is an enumerated tpe that dtermines how many hits will be accepted in
                        a trigger matching window for an event.  Note that this limit spans all
                        channels rather than being a per channel limit.  Values of this type
                        are of the form <structfield>HITS_<replaceable>n</replaceable></structfield>
                        where <replaceable>n</replaceable> determines the maximum number of hits
                        andcan be any of the following: <literal>0, 1, 2, 4, 8, 16, 32, 64, 128,
                        UNLIMITED</literal>.
                    </para>
                </formalpara>
                <formalpara>
                    <title><structname>L1Size</structname></title>
                    <para>
                        Limits the size of the TDC level 1 buffer.  This enumerated type has
                        values of the form: <structfield>L1_<replaceable>n</replaceable>wds</structfield>,
                        where <replaceable>n</replaceable> is the L1 buffersize limit in
                        32 bit longwords and can be one of:
                        <literal>2, 4, 8, 16, 32, 64, 128, 256</literal>.
                    </para>
                </formalpara>
                <formalpara>
                    <title>Constants</title>
                    <para>The following set of 16 bit constants are defined, and represent bits in the
                        error enable mask <constant>ERR_VERNIER, ERR_COARSE, ERR_SELECT,
                        ERR_L1PARITY, ERR_TFIFOPARITY, ERR_MATCHERROR, ERR_RFIFOPARITY, ERR_RDOSTATE,
                            ERR_SUPPARITY, ERR_CTLPARITY, ERR_JTAGPARITY
                                          </constant>
                    </para>
                </formalpara>
            </refsect1>
            <refsect1>
                <title>Exceptions</title>
                <para>
                    Various exception types may be thrown including:
                    <variablelist>
                        <varlistentry>
                            <term><classname>std::string</classname></term>
                            <listitem>
                                <para>If the module addressed did not have a legal type</para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><classname>CException</classname></term>
                            <listitem>
                                <para>
                                    A standard NSCL Exception typ thrown iif there are low level
                                    problems accessing the device.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>Design by contract exceptions</term>
                            <listitem>
                                <para>
                                   Improper function paramters will in general result in an
                                   excetpion from the <filename>DesignByContract.h</filename>
                                   header.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
            </refsect1>
            <refsect1>
                <title>SEE ALSO</title>
                <para>
                    The CAEN V1190 and CAEN V1290 hardware manuals.
                </para>
            </refsect1>
        </refentry>
        <refentry id="CCAENV560">
        
        <refmeta>
            <refentrytitle>CCAENV560</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CCAENV560</refname>
            <refpurpose>Support the CCAENV560 non-latching scaler.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CCAENV560.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CCAENV560</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CCAENV560</methodname>
                    <methodparam><type>unsigned long</type> <parameter>base</parameter></methodparam>
                    <methodparam><type>int crate</type>     <parameter>crate</parameter><initializer>0</initializer></methodparam>
                </constructorsynopsis>
                <methodsynopsis> 
                    <type>bool</type> <methodname>GetSectStat</methodname>
                    <methodparam><type>int</type> <parameter>nSection</parameter></methodparam>
                    <exceptionname>std::string</exceptionname>
                </methodsynopsis>  
                <methodsynopsis>
                    <type>void</type> <methodname>ScalInc</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetVeto</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>ResetVeto</methodname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Clear</methodname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>GetVetoStat</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>int</type> <methodname>ReadCounter</methodname>
                    <methodparam><type>int</type> <parameter>nChannel</parameter></methodparam>
                    <exceptionname>std::string</exceptionname>
                </methodsynopsis>
            </classsynopsis>
                    
               
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                Note this software was contributed by Kevin Carnes from James R. Macdonald Lab
                Kansas State University.
            </para>
            <para>
                This class is a driver for the CAEN V560 scaler module.  This module is a
                non-latching scaler.  The module can be used both as a 32 bit scaler or channels
                can be ganged together to create 64 bit scalers.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <para>
                <variablelist>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><function>CCAENV560</function></funcdef>
                                <paramdef><type>unsigned long</type> <parameter>base</parameter></paramdef>
                                <paramdef><type>int</type> <parameter>crate</parameter></paramdef>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Constructs an object through which you can control a single
                                CAEN V560 scaler module.  <parameter>base</parameter>
                                is the base address of the module as programmed into the module's
                                rotary switches.  <parameter>crate</parameter> is the number of the
                                VME crate the module is installed in.  If not supplied, the
                                <parameter>crate</parameter>
                                parameter defaults to 0, which is suitable for single crate systems.
                                </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>bool</type> <function>GetSectStat</function></funcdef>
                                <paramdef><type>int</type> <parameter>nSection</parameter></paramdef>
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                The 16 scaler channels in the module are divided into 8 two channel
                                groups.  Each group can be switch selectable to be either
                                two 32 bit scalers or 1 64 bit scaler.  This function essentially
                                returns the swtich value for a specific section.  Section zero is
                                scalers 1/2, section one is scalers 3/4 and so on.  A value of
                                <literal>false</literal> meanst the group is operating as two 32 bit
                                scalers, while a value of <literal>true</literal> means the carry from
                                the lower numbered scaler is feeding the increment for the higher
                                numbered scaler in the group (1 64 bit scaler).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>ScalInc</function></funcdef>
                                <void />
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This test function increments all channels fo the scaler.
                                If a group is in 64 bit mode it is not clear to me if both counters
                                in the group are incremented or not.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                            <funcdef><type>void</type> <function>SetVeto</function></funcdef>
                            <void />
                                          </funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Vetoes the module.  Scalers will not count if there are inputs.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>ResetVeto</function></funcdef>
                                <void />
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Turns off the veto on all of the channels of the 
                                module.  This allows the scaler channels to count.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>void</type> <function>Clear</function></funcdef>
                                            <void />
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Clears all channels of the scaler.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>bool</type> <function>GetVetoStat</function></funcdef>
                                <void />
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the module is vetoed or
                                <literal>false</literal> if not.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <funcsynopsis><funcprototype>
                                <funcdef><type>int</type> <function>ReadCounter</function></funcdef>
                                <paramdef><type>int</type> <parameter>nChannel</parameter></paramdef>
                                          </funcprototype>
                            </funcsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Reads the counter for channel <parameter>nChannel</parameter>.
                                If <parameter>nChannel</parameter> is not legal, a string exception
                                is thrown.
                                   </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </refsect1>
        <refsect1>
            <title>Exceptions</title>
            <para>
                Invalid parameters or failure to map the module and find a scaler will
                result in an std::string exception being thrown.
            </para>
        </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
                The CAEN V560 hardware manual.
            </para>
        </refsect1>
    </refentry>
    <refentry id="CCAENV830">
        
        <refmeta>
            <refentrytitle>CCAENV830</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CCAENV830</refname>
            <refpurpose>Support driver for the CAEN V820/V830 latching scaler module.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CCAENV830.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CCAENV830</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CCAENV830</methodname>
                    <methodparam><type>int</type> <parameter>slot</parameter></methodparam>
                    <methodparam><type>int</type> <parameter>crate</parameter><initializer>0</initializer></methodparam>
                    <methodparam><type>bool</type> <parameter>geo</parameter><initializer>true</initializer></methodparam>
                    <methodparam><type>unsigned long</type> <parameter>base</parameter><initializer>0</initializer></methodparam>
                    <exceptionname>std::string</exceptionname>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Enable</methodname>
                    <methodparam><type>int</type> <parameter>nChannel</parameter></methodparam>
                    <exceptionname>std::string</exceptionname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Disable</methodname>
                    <methodparam><type>int</type> <parameter>nChannel</parameter></methodparam>
                    <exceptionname>std::string</exceptionname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetEnableMask</methodname>
                    <methodparam><type>int</type> <parameter>nMask</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetDwellTime</methodname>
                    <methodparam><type>int</type> <parameter>n400ns</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetTriggerMode</methodname>
                    <methodparam><type>TriggerMode</type> <parameter>mode</parameter></methodparam>
                    <exceptionname>std::string</exceptionname>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetWide</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetNarrow</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>EnableHeader</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>DisableHeader</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>FPClearsMEB</methodname>
                    <methodparam><type>bool</type> <parameter>state</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>EnableAutoReset</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>DisableAutoReset</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isDataReady</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isAlmostFull</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isFull</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isGlobalDready</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isGlobalBusy</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Reset</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Clear</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Trigger</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetTriggerCounter</methodname>
                    <methodparam><type>int</type> <parameter>n</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetAlmostFullLevel</methodname>
                    <methodparam><type>int</type> <parameter>n</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>int</type> <methodname>GetMEBEventCount</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>int</type>  <methodname>ReadEvent</methodname>
                    <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>int</type>  <methodname>ReadEvent</methodname>
                    <methodparam><type>DAQWordBufferPtr&amp;</type> <parameter>rBufferPtr</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>int</type>  <methodname>ReadEvent</methodname>
                    <methodparam><type>DAQWordBuffer&amp;</type>    <parameter>rBuffer</parameter></methodparam>
                    <methodparam><type>int</type> <parameter>nOffset</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>int</type>  <methodname>ReadCounter</methodname>
                    <methodparam><type>int</type> <parameter>nChannel</parameter></methodparam>
                </methodsynopsis>
            </classsynopsis>

        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                The CAEN V830 scaler is a 32 channel latching VME scaler.  The scaler can
                be externally latched, unlatched or latched periodically using an internal
                timer.  Once latched scaler data can either be read from  a multi-event buffer.
                The V820, also supported by this software
                is identical to the V830 except that it does not have a multievent buffer.
                The raw (unlatched) counters can also be read.
            </para>
            <para>
                Modules can be geographically addresssed or relative to a module base address.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <funcsynopsis><funcprototype>
                            <funcdef><function>CCAENV830</function></funcdef>
                            <paramdef><type>int</type> <parameter>slot</parameter></paramdef>
                            <paramdef><type>int</type> <parameter>crate</parameter></paramdef>
                            <paramdef><type>bool</type> <parameter>geo</parameter></paramdef>
                            <paramdef><type>unsigned long</type> <parameter>base</parameter></paramdef>
                        </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a CCAENV830 object that can be used to manipulate an actual
                            scaler module.  <parameter>slot</parameter> is used to geographically
                            address the module if the <parameter>geo</parameter> parameter is false,
                            or to assign a virtual slot number to a module if <parameter>geo</parameter>
                            is true.  <parameter>crate</parameter> is used to select the VME
                            crate.  If omitted it defaults to <literal>0</literal> which is suitable
                            for systems with single crates.
                        </para>
                        <para>
                            If <parameter>geo</parameter> is falsed, the modules is addressed relative
                            to the <parameter>base</parameter> parameter, which must match the
                            base address set in the module's rotary switches.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <funcsynopsis><funcprototype>
                            <funcdef><type>void</type>  <function>Enable</function></funcdef>
                            <paramdef><type>int</type> <parameter>nChannel</parameter></paramdef>
                        </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables channel <parameter>nChannel</parameter>.  A <type>std::string</type>
                            exception will be thrown if the <parameter>nChannel</parameter> parameter
                            is not a legal channel number (0 through 31).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void</type>  <function>Disable</function></funcdef>
                            <paramdef><type>int</type> <parameter>nChannel</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Disables channel <parameter>nChannel</parameter> from counting.
                            If <parameter>nChannel</parameter> is not a legal channel number
                            (0 through 31), a <type>std::string</type> exception will be thrown.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>SetEnableMask </function></funcdef>
                            <paramdef><type>int</type> <parameter>nMask</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Sets the mask of channel enables.  Each bit in the 32 bit
                            <parameter>nMask</parameter> represents a channel.  Channel 0 is the
                            least significant bit, and channel 31 the most.  Channels with bits set
                            are enabled.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>SetDwellTime</function></funcdef>
                            <paramdef><type>int</type>   <parameter>n4ppns</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            In periodic trigger mode, this sets the number of 400ns clock ticks
                            between periodic triggers.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>SetTriggerMode </function></funcdef>
                            <paramdef><type>TriggerMode</type> <parameter>mode</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Selct the module trigger mode.  See "Types and public data" for more
                            information about the set of trigger types supported, and how to specify
                            them.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>SetWide </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Sets the scaler mode to <firstterm>wide</firstterm> in this mode,
                            channel data is 32 bits wide and no channel number information is
                            supplied.  See also <function>SetNarrow</function>
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>SetNarrow </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Sets the scaler readout mode to <firstterm>narrow</firstterm>.  In
                            narrow mode, each channel provides only 26bits of count information,
                            The data are labelled with the channel numbers in bits 27-31 as well.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void</type>  <function>EnableHeader </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Enables header data from the scaler.  This causes data from the multi
                            event buffer to return a header prior to the actual scaler data that
                            describes the trigger condition, the trigger number, the module
                            geographical addres, and the number of channels that follow.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>DisableHeader </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Turns off header data insertion.  See <function>EnableHeader</function>
                            above for more information.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void</type>  <function>FClearsMEB </function></funcdef>
                            <paramdef><type>bool</type> <parameter>state</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            If <parameter>state</parameter> is <literal>true</literal> then
                            a front panel clear also clears the multi-event buffer. Otherwise,
                            only the counters are cleared.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>EnableAutoReset </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            If called, latches also cause the counters to clear.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void</type>  <function>DisableAutoReset </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            If called, latches do not cause counters to clear.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                       <funcsynopsis><funcprototype>
                           <funcdef><type>bool </type>  <function>isDataReady </function></funcdef>
                           <void />
                       </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                       <para>
                        Returns <literal>true</literal> if the multi event memory has at least one
                        event stored in it.
                       </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>bool </type>  <function>isAlmostFull </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Returns <literal>true</literal> if the multievent buffer contains
                            at least the number of words programmed into the almost full register
                            via <function>SetAlmostFullLevel</function>.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>bool</type>  <function>isFull </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Returns <literal>true</literal> if the multi-event buffer is
                            completely full of data.  The V830 has 32Kwords of multi-event buffer.
                            What this means in terms of event <firstterm>depth</firstterm> depends
                            on how the scaler has been set up.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>bool </type>  <function>isGlobalDReady </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Returns true if the global data ready line on the control bus is full.
                            This differential ECL input is the wire tied OR of all the module
                            data readys on the bus.  It therefore indicates that <emphasis>some</emphasis>
                            module on that control bus has data, but not necessarily
                            <emphasis>this</emphasis> module.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>bool</type>  <function> isGlobalBusy</function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Returns <literal>true</literal> if the control bus global busy line is
                            true.  This line is the wire tied or of all of the module busys on the
                            control bus.  This indicates that <emphasis>some</emphasis> module is
                            busy, but not necessarily <emphasis>this</emphasis> module.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>Reset </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Peforms a software reset on the module, returning it to the default
                            condition.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>Clear </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Resets the event counters, the multi event buffer, the trigger counter,
                            and the event number register.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>Trigger </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Triggers a latch and store on the module, if the module is in random trigger
                            mode.  The scaler values are latched and transferred into multi event
                            memory.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>SetTriggerCounter </function></funcdef>
                            <paramdef><type>int</type> <parameter>n</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Sets the value of the trigger counter.  The trigger counter is returned
                            as a field of the header word if enabled.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>SetAlmostFullLevel </function></funcdef>
                            <paramdef><type>int</type> <parameter>n</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Sets the number of words in the multi-event buffer that define the
                            <firstterm>almost full</firstterm> condition.  See
                            also <function>isAlmostFull</function>
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>int </type>  <function>GetMEBEventCount </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Returns the number of events in the multi-event buffer.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>int</type>  <function>ReadEvent </function></funcdef>
                            <paramdef><type>void*</type> <parameter>pBuffer</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Reads an event from the MEB of the scaler into the buffer pointed to
                            by <parameter>pBuffer</parameter>. The number of 16 bit words read is
                            returned (e.g. 2 for each longword).  It is possible to have
                            <literal>0</literal> returned if the MEB has no events.
                            Note that no range checking is or can be done on the buffer, the user
                            must provide a buffer large enough to hold the data.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>int </type>  <function>ReadEvent </function></funcdef>
                            <paramdef><type>DAQWordBufferPtr&amp;</type> <parameter>rBufferPtr</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Reads an event directly into a spectrodaq managed buffer via a
                            <type>DAQWordBufferPtr</type> pointer like object.  The value of
                            <parameter>rBufferPtr</parameter> is modified so that on return
                            it 'points' past the data that has been read in.  The return value
                            is the number of 16 bit words read from the module.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>int </type>  <function>ReadEvent </function></funcdef>
                            <paramdef><type>DAQWordBuffer&amp;</type> <parameter>rBuffer</parameter></paramdef>
                            <paramdef><type>int</type>  <parameter>nOffset</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Reads an event into a spectrodaq managed buffer (<parameter>rBuffer</parameter>),
                            starting <parameter>nOffset</parameter> words from the start of that buffer.
                            The return value is the number of 16 bit words read from the scaler.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type> int</type>  <function>ReadCounter </function></funcdef>
                            <paramdef><type>int</type> <parameter>nChannel</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Reads the raw counter value for channel <parameter>nChannel</parameter>.
                            Note that this is not a latched value and therefore can be changing as
                            it is read.
                	</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title>Types and public data</title>
            <para>
                The trigger mode of the modules is specified using the <structname>TrigggerMode</structname>
                data type.  This is an enumerated type with the following possible values:
                <variablelist>
                    <varlistentry>
                        <term><structfield>Disabled</structfield></term>
                        <listitem>
                            <para>
                                Triggers are disabled.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><structfield>Random</structfield></term>
                        <listitem>
                            <para>
                                Random triggers. Triggers are accepted from the front panel
                                and programmatically.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><structfield>Periodic</structfield></term>
                        <listitem>
                            <para>
                                Periodic triggers.  Triggers happen at a rate determined by the
                                dwell time programmed via <function>SetDwellTime</function>
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </refsect1>
        <refsect1>
            <title>Exceptions</title>
            <para>
                Various parameter range errors are signalled by throwing a <type>std::string</type>
                exception.
            </para>
        </refsect1>
        
    </refentry>
    <refentry id="CCAENV977">
        
        <refmeta>
            <refentrytitle>CCAENV977</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CCAENV977</refname>
            <refpurpose>Software support for the CAEN V977 I/O register.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CCAENV977.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CCAENV977</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CCAENV977</methodname>
                    <methodparam><type>ULong_t</type> <parameter>lBase</parameter></methodparam>
                    <methodparam><type>UShort_t</type> <parameter>nCrate</parameter><initializer>0</initializer></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname>inputSet</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                     <type>void</type> <methodname>inputSet </methodname>
                     <methodparam><type>UShort_t</type> <parameter>value</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname> InputMask</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname> inputMask</methodname>
                    <methodparam><type>UShort_t</type> <parameter>mask</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname>inputRead </methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname> singleHitRead </methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname> multihitRead </methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname>  outputSet</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>        outputSet</methodname>
                    <methodparam><type>UShort_t</type> <parameter>pattern</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname> outputMask </methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>      outputMask</methodname>
                    <methodparam><type>UShort_t</type> <parameter>mask</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname>interruptMask( </methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname> interruptMask</methodname>
                    <methodparam><type>UShort_t</type> <parameter>mask</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname> outputClear</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname>singleHitReadAndClear </methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname> multiHitReadAndClear</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname> serialNumber </methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname>   firmwareLevel </methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>        controlRegister</methodname>
                    <methodparam><type>UShort_t</type> <parameter>mask</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname> controlRegister</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>     Reset </methodname>
                    <void />
                </methodsynopsis>
            </classsynopsis>
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                The CAEN V977 is a 16 channel I/O register.  This software provides
                <firstterm>policy independent</firstterm> support for that module.
                Other software builds on top of this to e.g. use the module as a trigger
                or dead-time management module.
            </para>
            <para>
                Refer to the CAEN hardware manual for the CAEN V977 for more information about this
                module.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <variablelist>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><function>CCAENV977 </function></funcdef>
                            <paramdef><type>ULong_t</type> <parameter>lBase</parameter></paramdef>
                            <paramdef><type>UShort_t</type> <parameter>nCrate</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Constructs a <classname>CCAENV977</classname> object.  Once constructed,
                            you can use this object to manipulate the actual device described by
                            the constructor.
                	</para>
                        <para>
                            <parameter>lBase</parameter> is the base address of the module as
                            configured in the module's rotary switches. <parameter>nCrate</parameter>
                            is the VME crate in which you will insert the module.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>UShort_t </type>  <function>inputSet </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Reads the module input set register.  This module describes the
                            current latched state of the inputs. Note that the module allows you to
                            modify the latched set of inputs (e.g. you can clear bits from the
                            register as you process them.  See the overload of <function>inputSet</function>
                            described below.  
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type> void</type>  <function>inputSet </function></funcdef>
                            <paramdef><type>UShort_t</type> <parameter>value</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Writes <parameter>value</parameter> to the input set register.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>UShort_t </type>  <function>inputMask </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Reads and returns the contents of the input mask register.  Bits set
                            in the input mask register disable the corresponding bits of the
                            input set register from being set as a result of hardware inputs.
                            It is possible, however for the input set register to be modified
                            arbitrarily by the software.
                            See the overload of <function>inputMask</function> below as well.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type> void</type>  <function>inputMask </function></funcdef>
                            <paramdef><type>UShort_t</type> <parameter>mask</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Writes <parameter>mask</parameter> to the input mask register.
                            This allows you to disable the corresponding bits of the
                            input set register from responding to hardware inputs.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type> UShort_t</type>  <function>inputRead </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            This reads and returns the module's input read register.  The input
                            read register reflects the instantaneous state of the module inputs.
                            Note that since the input read register is not a latched register, in
                            general it's not very useful.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type> UShort_t</type>  <function>singleHitRead </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            The module is able to distinguish between single and multiple hits
                            in a gate for each input.  This register is has bits set for each channel
                            that has received a single hit.  The register is not affected by the
                            contents of the input mask register.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type> UShort_t</type>  <function>multihitRead </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            This register has bits set for each channel of the module that received
                            multiple input pulses during the gate time.  The register is not affecte
                            by the input mask register.  Multiple hits can also come about as a result
                            of writes to the input set register.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>UShort_t </type>  <function>outputSet </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Reads and returns the value of the output set register.  This is the set of
                            bits that is presented to the module's outputs.
                            To write this see the overloaded <function>outputMask</function>
                            function below.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>outputSet </function></funcdef>
                            <paramdef><type>UShort_t</type> <parameter>pattern</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Writes <parameter>pattern</parameter> to the output set register.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>UShort_t </type>  <function>outputMask </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Reads the output mask register.  The module outputs are the bitwise OR of the
                            output set register and the input Flip Flop latched value anded with the
                            complement of this mask register.  That is bits set in this register
                            prevent the inputs from setting their corresponding outputs.  The best description
                            of all of this is probably figure 3.1 in the CAEN hardware manual for
                            the module.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>outputMask </function></funcdef>
                            <paramdef><type>Ushort_t</type> <parameter>mask</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Writes a value to the output mask register. Each bit set in the mask
                            register disables the corresponding output bit from being controlled
                            by the inputs. See figure 3.1 in the CAEN V977 hardware manual for
                            more information about the function of the output mask register.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>UShort_t </type>  <function>interruptMask </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Reads the interrupt mask register.  Each bit of the input register
                            can cause an interrupt to occur. Setting bits in the mask register
                            disables the corresoponding input bit from causing an interrupt.
                            Note that NSCLDAQ does not require
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>interruptMask </function></funcdef>
                            <paramdef><type>UShort_t</type> <parameter>mask</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Writes <parameter>mask</parameter> to the interrupt mask register.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void</type>  <function>outputClear </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Clears the output flipflop channels.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type> UShort_t</type>  <function>singleHitReadAndClear </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Returns the value of the single hit read-clear register.   This reads and
                            clears the single hit register.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>UShort_t </type>  <function>multiHitReadAndClear</function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Reads and returns the value of the multihit read-clear register.  This
                            reads and resets the contents of the multihit flip-flop/register.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>Ushort_t </type>  <function>serialNumber </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Returns the serial number of the module.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>UShort_t </type>  <function> firmwareLevel</function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Returns the module firmware revision level.  The firmware revision is divided
                            into a major and minor version (major.minor is the usual way to write this,
                            e.g. 3.4).  The most significant 8 bits of the firmware register are the
                            major revision, the least significatn 8 bits are the minor version.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>controlRegister </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Writes the control register.  It is an error to attempt to set bits that
                            have no meaning.  This is meant to ensure that you use the definitions
                            provided by the class for this (see "Types and public data" below).
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>UShort_t </type>  <function>controlRegister </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Reads and returns the value of the control register.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>Reset </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Resets the module to its default setup.
                	</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title>Types and public data</title>
            <para>
                The following constant values are defined to represent bits in the
                control register:
                <variablelist>
                    <varlistentry>
                        <term><type>UShort_t</type> <classname>CCAENV977</classname>::<varname>control_Pattern</varname></term>
                        <listitem>
                        <para>
                            The Pattern bit in the control register.
                        </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>UShort_t</type> <classname>CCAENV977</classname>::<varname>control_gateMask</varname></term>
                        <listitem>
                            <para>
                                The gateMask bit of the control register.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term> <type>UShort_t</type> <classname>CCAENV977</classname>::<varname>control_OrMask</varname></term>
                        <listitem>
                            <para>
                                The Or mask bit of the control register.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </refsect1>
        <refsect1>
            <title>Exceptions</title>
            <para>
                Contract exceptions defined in the header <filename>DesignByContract.h</filename>
                can be thrown if the expectations of a function are violated by its caller.
            </para>
        </refsect1>
    </refentry>
    <refentry id="CCAMACScalerLRS2551">
        
        <refmeta>
            <refentrytitle>CCAMACScalerLRS2551</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CCAMACScalerLRS2551</refname>
            <refpurpose>Support software for the LeCroy LRS 2551 12 channel CAMAC scaler</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CCAMACScalerLRS2551.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CCAMACScalerLRS2551 : public CScaler</classname>  </ooclass>
                <constructorsynopsis><methodname>CCAMACScalerLRS2551</methodname>
                <methodparam><type>unsigned int</type> <parameter>b</parameter></methodparam>
                <methodparam><type>unsigned int</type> <parameter>c</parameter></methodparam>
                <methodparam><type>unsigned int</type> <parameter>n</parameter></methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <type>virtual void</type> <methodname>Initialize </methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>virtual void</type> <methodname>Read </methodname>
                <methodparam><type>std::vector&lt;unsigned long&gt;&amp;</type> <parameter>Scalers</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>virtual void</type> <methodname>Clear </methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>virtual unsigned int </type> <methodname>size ( </methodname>
            </methodsynopsis>
        </classsynopsis>
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                This class is intended to provide high level support for the LeCroy LRS 2551
                12 channel camac scaler module.  The module works best within the
                production readout framework, as the <classname>CScaler</classname> base class
                matches the needs and interface requirements of registered scalers.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <variablelist>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef> <function> CCAMACScalerLRS2551</function></funcdef>
                            <paramdef><type>unsigned int</type> <parameter>b</parameter></paramdef>
                            <paramdef><type>unsigned int</type> <parameter>c</parameter></paramdef>
                            <paramdef><type>unsigned int</type> <parameter>n</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Creates a new <classname>CCAMACScalerLRS2551</classname> object
                            that can be used to manipulate an actual scaler modulea the
                            CAMAC address described by the <parameter>b, c</parameter> and
                            <parameter>n</parameter> function arguments.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>virtual void</type>  <function>Initialize</function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Prepares the module for data taking; the module scaler channels are cleared.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>Read </function></funcdef>
                            <paramdef><type>std::vector&lt;unsigned long&gt;%amp;</type> <parameter>Scaleres</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Reads all 12 channels of scaler from the module and appends them to the
                            <parameter>Scaler</parameter> vector.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>void </type>  <function>Clear </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Clears all channels of the scaler.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type> </type>  <function> </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Returns 12, the number of scaler channels the module will add
                            to to the output buffer when it is read.
                	</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
    </refentry>
    <refentry id="CCAMACScalerLRS4434">
        
        <refmeta>
            <refentrytitle>CCAMACScalerLRS4434</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CCAMACScalerLRS4434</refname>
            <refpurpose>High level support software for the 32 channel LeCroy LRS 4434 CAMAC scaler module</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CCAMACScalerLRS4434.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CCAMACScalerLRS4434 : public CScaler</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CCAMACScalerLRS4434</methodname>
                    <methodparam><type>unsigned int</type> <parameter>b</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>c</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>n</parameter></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>virtual   void</type> <methodname>Initialize</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual   void</type> <methodname>Read</methodname>
                    <methodparam><type>std::vector&lt;unsigned long&gt;&amp;</type> <parameter>Scalers</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual   void</type> <methodname>Clear</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual   unsigned int</type> <methodname>size</methodname>
                    <void />
                </methodsynopsis>
            </classsynopsis>
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                This function provides very high level support for the LeCroy LRS 4434 32 channel
                CAMAC scaler module.  The support module is intended to be used with the production readout
                framework but could really be used in any application with suitable adaptation on the
                part of the caller.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <variablelist>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><function>CCAMACScalerLRS4434</function></funcdef>
                            <paramdef><type>unsigned int</type> <parameter>b</parameter></paramdef>
                            <paramdef><type>unsigned int</type> <parameter>c</parameter></paramdef>
                            <paramdef><type>unsigned int</type> <parameter>n</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Constructs a new <classname>CCAMACScalerLRS4434</classname> object.
                            This object can be used to  manipulate the physical scaler module
                            at the location in the CAMAC subsystem described by the constructor
                            parameters.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type> virtual   void</type>  <function>Initialize</function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Sets up the module for use in data taking.  The module will be software latched
                            which requires that the LAD switch on the physical module be in the
                            <literal>Off</literal> position.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>virtual   void</type>  <function>Read</function></funcdef>
                            <paramdef><type>std::vector&lt;unsigned long&gt;&amp;</type>
                                      <parameter>Scalers</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Reads the 32 scaler channels of the module and appends their values
                            to the <parameter>Scalers</parameter> vector.  The scalers are atomically
                            latched, read and cleared with respect to additional counts.  The clear is done
                            as the NSCL Scaler display and analysis software all expect the scaler values
                            to be incremental.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>virtual   void</type>  <function>Clear</function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Clears the scaler counters.  The counters are all simulataneousl cleared
                            so there is no skew in time for when the counters in the scaler begin to count
                            again.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>virtual unsigned int</type>  <function>size</function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Returns <literal>32</literal> the number of elements that will be added to
                            the <parameter>Scalers</parameter> vector by the <function>Read</function>
                            operation.
                	</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
    </refentry>
    <refentry id="CCAMACStatusModule">
        
        <refmeta>
            <refentrytitle>CCAMACStatusModule</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CCAMACStatusModule</refname>
            <refpurpose>Provide computer busy status support for the BiRA CAMAC
                NIM out module.
            </refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CCAMACStatusModule.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CCAMACStatusModule</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CCAMACStatusModule</methodname>
                    <methodparam><type>unsigned int</type> <parameter>b</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>c</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>n</parameter></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>virtual   void</type> <methodname>GoBusy</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual   void</type> <methodname>GoClear</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual   void</type> <methodname>ModuleClear</methodname>
                    <void />
                </methodsynopsis>
            </classsynopsis>
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                When an event trigger is sent to the computer, a hardware busy latch
                must also be set.  This latch will indicate that the computer is not
                ready to accept another trigger.  When the computer is done responding to the
                trigger, it must send a software generated signal to clear that latch.
                The Software modules in charge of that are called <firstterm>Status Modules</firstterm>.
            </para>
            <para>
                <classname>CCAMACStatusModule</classname> can be hooked into the readout frameworks
                to provide various software generated signals to external modules.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <variablelist>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><function>CCAMACStatusModule</function></funcdef>
                            <paramdef><type>unsigned int</type> <parameter>b</parameter></paramdef>
                            <paramdef><type>unsigned int</type> <parameter>c</parameter></paramdef>
                            <paramdef><type>unsigned int</type> <parameter>n</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Creates a new <classname>CCAMACStatusModule</classname> object that can be
                            used to manipulate a BiRA NIM out as a status module.  Note that usually
                            you will register this with one of the frameworks and let it control the
                            object rather than directly making calls.
                	</para>
                        <para>
                            The Status module signals the following conditions>
                            <variablelist>
                                <varlistentry>
                                    <term>Module clears</term>
                                    <listitem>
                                        <para>
                                            Output to allow modules with front panel clears
                                            to be simultaneously cleared at the end of an event.
                                            Outputs 1-8 are used to signal this.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>Computer clear</term>
                                    <listitem>
                                        <para>
                                            Output indicating the computer is ready to accept an
                                            event trigger. Use this to clear the busy latch.
                                        </para>
                                    </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>Computer going soft busy</term>
                                    <listitem>
                                        <para>
                                            This indicates the computer is about to go busy
                                            for software reasons.  You may or this with your
                                            <firstterm>live master trigger</firstterm> to set
                                            the computer busy latch.   Do not use this as the sole
                                            input to set your busy latch.  This is not output each event,
                                            as the computer can't get around to reacting to a trigger
                                            much faster than 3 microseconds after the trigger.
                                        </para>
                                    </listitem>
                                </varlistentry>
                            </variablelist>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>virtual void</type>  <function>GoBusy</function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Pulses the computer going busy output.  This is usually used to indicate
                            a soft busy condition such as pausin,  or ending runs.
                            When the status module is hooked into the frameworks, you should not
                            count on this being pulsed for each event. You should use an external
                            latch to set the computer busy for events as there's no appreciable
                            latency associated with it.  In most cases it is actually quite safe
                            to ignore this output as the next event will force your external busy
                            latch to be busy.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>virtual void</type>  <function>GoClear</function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Pulses the end of computer busy output.  This should be used to clear
                            any external computer busy latch.  When the object is hooked into
                            the frameowrk this is output whenever the computer
                            becomes able to accept an event trigger.  This can be at the end of an event
                            readout, when runs begin, when runs resume.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>virtual void</type>  <function>ModuleClear</function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Pulses the module clears outputs. Those can be used to simultaneously
                            hardware clear several modules, rather than taking the time to individually
                            software clear them.  When the object is registered into the framework
                            these output are pusled just prior to calling <function>GoClear</function>.
                	</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
    </refentry>
    <refentry id="CCAMACTrigger">
        
        <refmeta>
            <refentrytitle>CCAMACTrigger</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CCAMACTrigger</refname>
            <refpurpose>Trigger module for the CES CBD 8210 VME CAMAC Parallel Branch Highway Driver
            </refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CCAMACTrigger.h&gt;
            </programlisting>

            <classsynopsis language="c++">
            <ooclass><classname>CCAMACTrigger.h : public CTrigger</classname></ooclass>
            <constructorsynopsis>
                <methodname>CCAMACTrigger</methodname>
                <methodparam><type>unsigned int</type> <parameter>b</parameter></methodparam>
            </constructorsynopsis>
            <methodsynopsis>
                <type>virtual bool</type> <methodname>operator()</methodname>
                <void />
            </methodsynopsis>
            </classsynopsis>
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                Provides a trigger module based on the INT2 input of the CES CBD 8210
                VME CAMAC parallel branch highway driver.  The purpose of trigger modules
                is to determine whether or not the readout software should read data
                from the experimental hardware.  In the simplest case, the trigger
                indicates a single event is ready to be read.  In more complex cases
                involving multibuffered event hardware, the trigger may indicate that on or
                more events is avaiable in the buffer of the device.
            </para>
            <para>
                Typically your code will not manipulate trigger objects other than to
                create them and register them with the appropriate readout framework.
                The readout framework will then invoke the trigger test function
                (<function>operator()</function>), when appropriate and execute your
                readout code in response to a trigger condition.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <variablelist>
            <varlistentry>
                <term>
            	<funcsynopsis><funcprototype>
            	    <funcdef><function>CCAMACTrigger</function></funcdef>
                    <paramdef><type>unsigned int</type> <parameter>b</parameter></paramdef>
            	</funcprototype></funcsynopsis>
                </term>
                <listitem>
            	<para>
                    Creates a trigger object whose methods can be used to test for a trigger
                    in the physical module described by the constructor.  In this case a trigger module
                    is created in branch <parameter>b</parameter>.
            	</para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
            	<funcsynopsis><funcprototype>
            	    <funcdef><type>virtual bool</type>  <function>operator()</function></funcdef>
                    <void />
            	</funcprototype></funcsynopsis>
                </term>
                <listitem>
            	<para>
                    Tests for the presence of a trigger condition.
            	</para>
                </listitem>
            </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title>DEFECTS AND RESTRICTIONS</title>
            <para>
                The trigger module must live in VME crate 0.
            </para>
        </refsect1>
    </refentry>
    <refentry id="CCamac">
        
        <refmeta>
            <refentrytitle>CCamac</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CCamac</refname>
            <refpurpose>Manages CAMAC memory maps.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CCamac.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CCamac</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CCamac</methodname>
                    <void />
                </constructorsynopsis>
                <methodsynopsis>
                    <type>static void</type> <methodname>BranchInit</methodname>
                    <methodparam><type>int</type> <parameter>nBranch</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>static void</type> <methodname>BranchRelease</methodname>
                    <methodparam><type>int</type> <parameter>nBranch</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>static long*</type> <methodname>Base</methodname>
                    <methodparam><type>int</type> <parameter>nBranch</parameter></methodparam>
                </methodsynopsis>
            </classsynopsis>
        </refsynopsisdiv>

        <refsect1>
            <title>Description</title>
            <para>
                The <classname>CCamac</classname> class consists entirely of static
                member functions (and data).  It is used to create and manipulate
                maps to CAMAC branch highways.
            </para>
            <para>
                Branches have a funny numbering system.
                Branches 0-7 are assumed to be in VME crate 0, Branches 8-15 in VME crate
                1 and so on.  The class assumes a maximum of 32 VME crates eac with at most
                8 CAMAC highways installed.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <variablelist>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>static void</type>  <function>BranchInit</function></funcdef>
                            <paramdef><type>int</type> <parameter>nBranch</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Creates a map that covers the entire branch, and stores it in the map table
                            for re-use in case the same branch is requested in the future.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>static void</type>  <function>BranchRelease</function></funcdef>
                            <paramdef><type>int</type> <parameter>nBranch</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Releases a branch.  This will unmap the address space that is
                            referenced by the map.  It is up to the caller to ensure that the application
                            will no longer need to reference the branch that is being released.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>static long*</type>  <function>Base</function></funcdef>
                            <paramdef><type>int</type> <parameter>nBranch</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Returns the pointer to start of the memory space mapped by a branch or
                            <literal>NULL</literal> if the branch has not yet bee mapped.
                	</para>
                    </listitem>
                </varlistentry>
            </variablelist>  
        </refsect1>
        <refsect1>
            <title>Exceptions</title>
            <para>
                <classname>CRangeError</classname> is thrown if the branch is not in range.
            </para>
        </refsect1> 
    </refentry>
        <refentry id="CCamacModule">
            
            <refmeta>
                <refentrytitle>CCamacModule</refentrytitle>
                <manvolnum>3DeviceSupport</manvolnum>
            </refmeta>
            
            <refnamediv>
                <refname>CCamacModule</refname>
                <refpurpose>Provide support for a generic CAMAC module.</refpurpose>
            </refnamediv>
            
            <refsynopsisdiv>
                <programlisting>
    #include &lt;CCamacModule.h&gt;
                </programlisting>
                <classsynopsis language="c++">
                    <ooclass><classname>CCamacModule</classname></ooclass>
                    <constructorsynopsis><methodname>CCamacModule</methodname>
                    <methodparam><type>unsigned int</type> <parameter>branch</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>crate</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>slot</parameter></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>unsigned long</type> <methodname>Read</methodname>
                    <methodparam><type>unsigned int</type> <parameter>f</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>a</parameter></methodparam>
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Write</methodname>
                    <methodparam><type>unsigned int</type> <parameter>f</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>a</parameter></methodparam>
                    <methodparam><type>unsigned long</type> <parameter>d</parameter></methodparam>
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned short</type> <methodname>Control</methodname>
                    <methodparam><type>unsigned int</type> <parameter>f</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>a</parameter></methodparam>
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned long*</type> <methodname>MakePointer</methodname>
                    <methodparam><type>unsigned int</type> <parameter>f</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>a</parameter></methodparam>
                    <methodparam><type>bool</type> <parameter>isshort</parameter><initializer>false</initializer></methodparam>
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned long*</type> <methodname>MakePointer</methodname>
                    <methodparam><type>unsigned int</type> <parameter>c</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>n</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>a</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>f</parameter></methodparam>
                    <methodparam><type>bool</type> <parameter>isshort</parameter><initializer>false</initializer></methodparam>
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>static bool</type> <methodname>ValidBranch</methodname>
                    <methodparam><type>unsigned int</type> <parameter>branch</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>static bool</type> <methodname>ValidCrate</methodname>
                    <methodparam><type>unsigned int</type> <parameter>crate)</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>static bool</type> <methodname>ValidSlot</methodname>
                    <methodparam><type>unsigned int</type> <parameter>slot</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>static bool</type> <methodname>ValidSubaddress</methodname>
                    <methodparam><type>unsigned int</type> <parameter>a</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>static bool</type>  <methodname>ValidFunction</methodname>
                    <methodparam><type>unsigned int</type> <parameter>f</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>static bool</type> <methodname>isRead</methodname>
                    <methodparam><type>unsigned int</type> <parameter>f</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>static bool</type> <methodname>isWrite</methodname>
                    <methodparam><type>unsigned int</type> <parameter>f</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>static bool</type> <methodname>isControl</methodname>
                    <methodparam><type>unsigned int</type> <parameter>f</parameter></methodparam>
                </methodsynopsis>
                </classsynopsis>
            </refsynopsisdiv>
            
            <refsect1>
                <title>Description</title>
                <para>
                    Provides support for a generic CAMAC module.  Constructing a
                    <classname>CCamacModule</classname> object creates an object that can
                    perform generic manipulations on a single CAMAC module in the system.
                </para>
                <para>
                    CAMAC modules are conceptually quite simple. Modules are addressed by
                    crate slot.
                    They can have a function code
                    (operation) directed at them.  Function codes <literal>0-7</literal>
                    represent read operations, Functtion codes <literal>16-23</literal> represent
                    write operations and <literal>8-15,24-31</literal> represent non data transfer
                    (control) operations.
                </para>
                <para>
                    The function code can be qualified by any of 16 subaddresses.  Subaddresses
                    generally represent channels or functional targets within the device.
                </para>
            </refsect1>
            <refsect1>
                <title>Public member functions</title>
                <variablelist>
                    <varlistentry>
                        <term>
                    	<funcsynopsis><funcprototype>
                    	    <funcdef><type></type><function>CCamacModule</function></funcdef>
                            <paramdef><type>unsigned int</type> <parameter>branch</parameter></paramdef>
                            <paramdef><type>unsigned int</type> <parameter>crate</parameter></paramdef>
                            <paramdef><type>unsigned int</type> <parameter>slot</parameter></paramdef>
                    	</funcprototype></funcsynopsis>
                        </term>
                        <listitem>
                    	<para>
                            Constructs a <classname>CCamacModule</classname>.  The module that will
                            be controlled by this objedct is described by the
                            <parameter>branch, crate</parameter> and <parameter>slot</parameter>
                            parameters of the constructor.  As usual for CAMAC systems at the NSCL,
                            the <parameter>branch</parameter> parameter implies a VME crate number.
                    	</para>
                        </listitem>
                    </varlistentry>
                    <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                        <type>unsigned long</type> <function>Read</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>f</parameter></paramdef>
                        <paramdef><type>unsigned int</type> <parameter>a</parameter></paramdef>
                        <modifier>const</modifier>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Performs a read operation on the module.
                            <parameter>f</parameter> is the function code of the read and
                            must be in the range <literal>0-7</literal> inclusive.
                            <parameter>a</parameter>
                            is the subaddress to which the function is directed and must be in the
                            range <literal>0-15</literal>.  The return value of the function is
                            the data provided by the module.
                        </para>
                    </listitem></varlistentry>
                    <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                        <type>void</type> <function>Write</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>f</parameter></paramdef>
                        <paramdef><type>unsigned int</type> <parameter>a</parameter></paramdef>
                        <paramdef><type>unsigned long</type> <parameter>d</parameter></paramdef>
                        <modifier>const</modifier>
                        </funcprototype></funcsynopsis></term>
                        <listitem>
                            <para>
                                Writes data to the module.  The function code and subaddress
                                are provided by the <parameter>f</parameter> and <parameter>a</parameter>
                                parameters respectively.  The data to write is <parameter>d</parameter>.
                                <parameter>f</parameter> must be in the range <literal>16-23</literal>
                                inclusive while <parameter>a</parameter> must be in the range
                                <literal>0-15</literal> inclusive.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                        <type>unsigned short</type> <function>Control</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>f</parameter></paramdef>
                        <paramdef><type>unsigned int</type> <parameter>a</parameter></paramdef>
                        <modifier>const</modifier>
                        </funcprototype></funcsynopsis></term>
                        <listitem>
                            <para>
                                Performs a control function on the device.  The function code
                                <parameter>f</parameter> must be in one of the ranges
                                <literal>8-15</literal> or <literal>24-31</literal> inclusive.
                                The subaddress <literal>a</literal> must be in the range
                                <literal>0-15</literal> inclusive.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                        <type>unsigned long*</type> <function>MakePointer</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>f</parameter></paramdef>
                        <paramdef><type>unsigned int</type> <parameter>a</parameter></paramdef>
                        <paramdef><type>bool</type> <parameter>isshort</parameter><initializer>false</initializer></paramdef>
                        <modifier>const</modifier>
                    </funcprototype></funcsynopsis></term><listitem><para></para></listitem></varlistentry>
                    <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                        <type>static bool</type> <function>ValidBranch</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>branch</parameter></paramdef>
                        </funcprototype></funcsynopsis></term>
                        <listitem>
                            <para>
                                This is a convenience function that returns <literal>true</literal>
                                if <parameter>branch</parameter> is a valid CAMAC branch  number.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                        <type>static bool</type> <function>ValidCrate</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>crate)</parameter></paramdef>
                        </funcprototype></funcsynopsis></term>
                        <listitem>
                            <para>
                                Returns true if the <parameter>crate</parameter> is a valid
                                CAMAC crate.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                        <type>static bool</type> <function>ValidSlot</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>slot</parameter></paramdef>
                        </funcprototype></funcsynopsis></term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if <parameter>slot</parameter>
                                is a valid CAMAC slot number.  This function recognizes that
                                crates have 'pseudo' slots that actually address the controller.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                        <type>static bool</type> <function>ValidSubaddress</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>a</parameter></paramdef>
                        </funcprototype></funcsynopsis></term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if <parameter>a</parameter>
                                is a valid module subaddress.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                        <type>static bool</type>  <function>ValidFunction</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>f</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the function <parameter>f</parameter>
                                is a valid function code.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                        <type>static bool</type> <function>isRead</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>f</parameter></paramdef>
                        </funcprototype></funcsynopsis></term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the function <parameter>f</parameter>
                                is a valid Read operation.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                        <type>static bool</type> <function>isWrite</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>f</parameter></paramdef>
                        </funcprototype></funcsynopsis></term>
                        <listitem>
                           <para>
                                Returns <literal>true</literal> if the function
                                <parameter>f</parameter> is a valid CAMAC write function code.   
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                        <type>static bool</type> <function>isControl</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>f</parameter></paramdef>
                        </funcprototype></funcsynopsis></term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> if the function <parameter>f</parameter>
                                is a valid CAMAC control function code (non data transfer).
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect1>
            <refsect1>
                <title>Exceptions</title>
                <para>
                    <classname>CRangeError</classname> is thrown when parameters are not in their
                    valid range.
                </para>
            </refsect1>
 
            
        </refentry>
    <refentry id="CCamacNimout">
        
        <refmeta>
            <refentrytitle>CCamacNimout</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CCamacNimout</refname>
            <refpurpose>Provides low level support for the BiRa CAMAC Nim output module.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CCamacNimout.h&gt;
            </programlisting>
            <classsynopsis lang="c++">
                <ooclass><classname>CCamacNimout : public CCamacModule</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CCamacNimout</methodname>
                    <methodparam><type>unsigned int</type> <parameter>b</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>c</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>n</parameter></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>WriteMask</methodname>
                    <methodparam><type>unsigned short</type> <parameter>mask</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>WriteBit</methodname>
                    <methodparam><type>unsigned int</type> <parameter>nBitno</parameter></methodparam>
                </methodsynopsis>
            </classsynopsis>
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                Provides low level object oriented support for the BiRa CAMAC Model 3251 NIM output
                register.  Creating an intance of this class allows you to manipulate a physical
                module.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <variablelist>
               <varlistentry>
                <term><funcsynopsis><funcprototype><funcdef>
                    <function>CCamacNimout</function></funcdef>
                    <paramdef><type>unsigned int</type> <parameter>b</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>c</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>n</parameter></paramdef>
                    </funcprototype></funcsynopsis></term>
                    <listitem>
                        <para>
                            Constructs a <classname>CCamacNimout</classname> object to control the
                            module defined at <parameter>b, c, </parameter> and <parameter>n</parameter>
                        </para>
                    </listitem>
               </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>>WriteMask</function></funcdef>
                    <paramdef><type>unsigned short</type> <parameter>mask</parameter></paramdef>
                                        </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes the specified
                            <parameter>mask</parameter> of bits to the output register.
                            What this actually does will depend on the jumpers in the modules.
                            If the jumpers are pulse mode (normal at the NSCL), all the ones bits in the
                            mask will get pulsed as nim trues for some time that is
                            defined by the module hardware.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                        <type>void</type> <function>WriteBit</function></funcdef>
                        <paramdef><type>unsigned int</type> <parameter>nBitno</parameter></paramdef>
                        </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes a mask that consists only of the specific bit <parameter>nBitno</parameter>.
                            This is the same as calling <function>WriteMask</function> with the value
                            <literal> 1 &lt;&lt; nBitno </literal> as the parameter.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
    </refentry>
    <refentry id="CCrateController">
        
        <refmeta>
            <refentrytitle>CCrateController</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CCrateController</refname>
            <refpurpose>Encapsulation of a BiRa 1302 CAMAC controller via CES CBS8210.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CCrateController.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CCrateController</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CCrateController</methodname>
                    <methodparam><type>unsigned int</type> <parameter>b</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>c</parameter></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Z</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>C</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>long</type> <methodname>Lams</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>UnInhibit</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>DisableDemand</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Inhibit</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>nableDemand</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isInhibited</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isDemanding</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isDemandEnabled</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>BroadcastControl</methodname>
                    <methodparam><type>unsigned int</type> <parameter>f</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>a</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>BroadcastWrite</methodname>
                    <methodparam><type>unsigned int</type> <parameter>f</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>a</parameter></methodparam>
                    <methodparam><type>unsigned long</type> <parameter>d</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>MulticastControl</methodname>
                    <methodparam><type>unsigned int</type> <parameter>f</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>a</parameter></methodparam>
                    <methodparam><type>unsigned long</type> <parameter>nMask</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>MulticastWrite</methodname>
                    <methodparam><type>unsigned int</type> <parameter>f</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>a</parameter></methodparam>
                    <methodparam><type>unsigned long</type> <parameter>nMask</parameter></methodparam>
                    <methodparam><type>unsigned long</type> <parameter>nData</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis><type>void</type> <methodname>InitializeCrate</methodname>
                                                  <void />
                </methodsynopsis>
            </classsynopsis>
        </refsynopsisdiv>       
        <refsect1>
            <title>Description</title>
            <para>
                Instances of the <classname>CCrateController</classname> class allow you to manipulate
                a BiRA Model 1302 Type A1/A2 crate controller on the end of a parallel branch highway.
                The CAMAC Branch highway standard provides some common specifications for the behavior
                of Type A1 crate controller.  In addition, there are some model specific features
                of the controller.  It is certain that this class will work correctly with respect
                to the standard features of all A1/A2 crate controllers.  Extension may or may not work
                depending on the way they've been implemented.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <variablelist>
                <varlistentry>
                <term><funcsynopsis><funcprototype><funcdef>
                    <function>CCrateController</function></funcdef>
                    <paramdef><type>unsigned int</type> <parameter>b</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>c</parameter></paramdef>
                                    </funcprototype></funcsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a <classname>CCrateController</classname> object.
                        <parameter>b</parameter> is the branch number, which also implies a
                        VME crate number. <parameter>c</parameter> is the crate numbers set in the thumbwheels
                        on the front of the CAMAC crate controller module.
                    </para>
                </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>Z</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis>
                    </term><listitem><para>
                        Performs a Z cycle on the CAMAC crate.  The dataway Z line is
                        pulse in accordance with the requirements of the CAMAC crate standard
                        for Z cycles.
                                    </para>
                    </listitem>
                 </varlistentry>
                 <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>C</function></funcdef>
                                      <void />
                    </funcprototype></funcsynopsis>
                    </term><listitem><para>
                        Peforms a C cyle on the crate.  The C line is pulsed in accordance
                        with the requirments of the CAMAC crate standard for C cycles.
                                    </para>
                    </listitem>
                 </varlistentry>
                 <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>long</type> <function>Lams</function></funcdef>
                                      <void />
                    </funcprototype></funcsynopsis>
                    </term>
                        <listitem><para>
                            Returns the 24 bit graded LAM mask from the controller.
                            This is only meaningful if a lam grader is installed in the
                            device to map the dataway LAM pattern to graded LAM values.
                            At the NSCL we generally use a passive jumper block for a lam
                            grader that maps the LAM of each slot into the corresponding
                            bit of the LAM grader.  The LAM grader plugs into a connector on the
                            back of the controller module.
                                  </para>
                        </listitem>
                </varlistentry>
                 <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>UnInhibit</function></funcdef>
                                      <void />
                        </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Deasserts the data way I line. The I line provides an
                            <firstterm>Inhibit</firstterm> signal to the modules.
                            while modules are free, under the standard, to interpret
                            the presence or absence of the I signal in any way desired
                            by the designer, in general the I line is used to disable
                            some functions of the module.  For, example, in many digitization
                            modules, the I line prevents gates from having any effect on the module.
                        </para>
                    </listitem>
                </varlistentry>
                 <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>DisableDemand</function></funcdef>
                                      <void />
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Disables the crate controllers ability to assert the
                            branch demand (BD) line.  The branch demand line is
                            generally asserted by a crate controller if it has LAMs.
                        </para>
                    </listitem>
                 </varlistentry>
                 <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>Inhibit</function></funcdef>
                                      <void />
                    </funcprototype></funcsynopsis>
                    </term>
                        <listitem>
                            <para>
                                Asserts the I (inhibit) line on the crate dataway. See
                                the <function>UnInhibit</function> function description for more
                                information about this line and its purpose/funcion.
                            </para>
                        </listitem>
                 </varlistentry>
                 <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>EnableDemand</function></funcdef>
                                      <void />
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enable the module to assert the branch demand (BD) line
                            if LAMs are present.
                        </para>
                    </listitem>
                 </varlistentry>
                
                 <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>bool</type> <function>isInhibited</function></funcdef>
                                      <void />
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>true</literal> if the data way is
                            inhibited.  Note that this function cannot be atomic,
                            a test function must be performed, and the state of the
                            branch Q read.  Therefore to ensure reliable results, the VME
                            bus should be software locked when doing this function.
                        </para>
                    </listitem>
                 </varlistentry>
                 <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>bool</type> <function>isDemanding</function></funcdef>
                                      <void />
                        </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>true</literal> if the controller is asserting
                            a branch demand.
                        </para>
                    </listitem>
                 </varlistentry>
                 <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>bool</type> <function>isDemandEnabled</function></funcdef>
                                      <void />
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>true</literal> if the branch demand is enabled.
                        </para>
                    </listitem>
                 </varlistentry>
                 <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>BroadcastControl</function></funcdef>
                    <paramdef><type>unsigned int</type> <parameter>f</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>a</parameter></paramdef>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a control (non data transfer) broadcast operation to the
                            crate.  A broadcast operation sends the function code <parameter>f</parameter>
                            and subaddress <parameter>a</parameter> to all modules by asserting all
                            N lines (slot selects) during the cycle.  <parameter>f</parameter>
                            must be in one of the inclusive ranges <literal>8-15</literal> or
                            <literal>24-31</literal>.
                        </para>
                    </listitem>
                 </varlistentry>
                 <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>BroadcastWrite</function></funcdef>
                    <paramdef><type>unsigned int</type> <parameter>f</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>a</parameter></paramdef>
                    <paramdef><type>unsigned long</type> <parameter>d</parameter></paramdef>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a broadcast write.  Broadcast writes are like broadcast
                            control operations (See <function>BroadcastControl</function> above)
                            but data are assserted on the data way lines and the function code,
                            <parameter>f</parameter>,
                            must be in the inclusive range <literal>16-23</literal>. This causes common
                            write data to be transferred to all modules on the data way.
                        </para>
                        <para>
                            Note that as the data way read lines are bussed, it makes no sense to
                            provide a broadcast read operation...although the open collector nature of the
                            CAMAC dataway would not cause electrical damage.
                        </para>
                    </listitem>
                 </varlistentry>
                 <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>MulticastControl</function></funcdef>
                    <paramdef><type>unsigned int</type> <parameter>f</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>a</parameter></paramdef>
                    <paramdef><type>unsigned long</type> <parameter>nMask</parameter></paramdef>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a multicast control operation by writing the
                            mask of affected slots, <parameter>nMask</parameter>, to the
                            station number register (a misnomer), and performing a multicast
                            operation using function code <parameter>f</parameter> and
                            <parameter>a</parameter> as the subaddress.
                        </para>
                        <para>
                            The function value <parameter>f</parameter> must be in the range
                            of valid non data transfer CAMAC function codes.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>MulticastWrite</function></funcdef>
                    <paramdef><type>unsigned int</type> <parameter>f</parameter></paramdef>
                    <paramdef><type>unsigned int</type> <parameter>a</parameter></paramdef>
                    <paramdef><type>unsigned long</type> <parameter>nMask</parameter></paramdef>
                    <paramdef><type>unsigned long</type> <parameter>nData</parameter></paramdef>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a multicast write. See <function>MulticastControl</function>
                            for much of the description, however, the function code
                            <parameter>f</parameter> must be a valid write operation and the
                            data <parameter>nData</parameter> is written on the data way.
                        </para>
                    </listitem>
                </varlistentry>
                 <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                        <type>void</type> <function>InitializeCrate</function></funcdef>
                                                  <void />
                </funcprototype></funcsynopsis>
                </term>
                    <listitem>
                        <para>
                            Initializes a CAMAC crate by performing a C cycle, a Z cycle,
                            Disabling the demand and uninhibiting the dataway.
                        </para>
                    </listitem>
                </varlistentry>                
            </variablelist>
        </refsect1>
 
    </refentry>
    <refentry id="CSIS3600">
        
        <refmeta>
            <refentrytitle>CSIS3600</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CSIS3600</refname>
            <refpurpose>Support for the SIS 3600 VME latch module.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CSIS3600.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CSIS3600</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CSIS3600</methodname>
                    <methodparam><type>unsigned long</type> <parameter>base</parameter></methodparam>
                    <methodparam><type>int</type> <parameter>crate</parameter><initializer>0</initializer></methodparam>
                    <exceptionname>std::string</exceptionname>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>void</type>    <methodname>Reset</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>LightLed</methodname>
                    <void /><modifier>const</modifier>
                            
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>ClearLed</methodname>
                                      <void /><modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isLedLit</methodname><void /><modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetLatchMode</methodname><void /><modifier>const</modifier>
                        
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetCoincidenceMode</methodname><void /><modifier>const</modifier>
                        
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isLatchMode</methodname><void /><modifier>const</modifier>
                            
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>EnableExternalClear</methodname><void /><modifier>const</modifier>
                        
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>DisableExternalClear</methodname>
                        <void /><modifier>const</modifier>
                        
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>ExternalClearEnabled</methodname>
                        <void /><modifier>const</modifier>
                        
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>EnableExternalNext</methodname>
                        <void /><modifier>const</modifier>
                        
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>DisableExternalNext</methodname>
                        <void /> <modifier>const</modifier>
                        
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>ExternalNextEnabled</methodname>
                        <void /><modifier>const</modifier>
                        
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetFastClearWindow</methodname>
                    <methodparam><type>int</type> <parameter>ns</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>int</type>  <methodname>GetFastClearWindow</methodname>
                        <void /><modifier>const</modifier>
                    
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Enable</methodname><void /><modifier>const</modifier>
                        
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Disable()</methodname><void /><modifier>const</modifier>
                    
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Clock</methodname><void /><modifier>const</modifier>
            
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>StartLatch</methodname><void /><modifier>const</modifier>
            
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>EndLatch</methodname><void /><modifier>const</modifier>
            
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>DataReady</methodname><void /><modifier>const</modifier>
                    
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>ClearData</methodname><void /><modifier>const</modifier>
                
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned long</type> <methodname>Read</methodname><void /><exceptionname>throws std::string</exceptionname>
                    <modifier>const</modifier>
        
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type>  <methodname>Read</methodname>
                    <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                    <methodparam><type>int</type> <parameter>nLongs</parameter></methodparam>
                    <modifier>const</modifier>
                </methodsynopsis>
            </classsynopsis>

        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                This class provides low level support for the SIS 3600 multievent latch.
                The module can act either as a pure latch or as a coincidence register.
                A latch stores the inputs presented to it on the falling edge of a gate
                while coincidence registers, store 1's for all inputs that have had
                true values for the <emphasis>duration</emphasis> of the input gate.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <variablelist>
                <varlistentry>
                <term><funcsynopsis><funcprototype><funcdef>    
                    <function>CSIS3600</function></funcdef>
                    <paramdef><type>unsigned long</type> <parameter>base</parameter></paramdef>
                    <paramdef><type>int</type> <parameter>crate</parameter></paramdef>
                                    </funcprototype></funcsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates an instance of a <classname>CSIS3600</classname>
                        class.  This object will allow you to manipulate the SIS 3600
                        module that has the base address <parameter>base</parameter> in
                        VME crate number <parameter>crate</parameter>.  If the
                        <parameter>crate</parameter> is not supplied, it defaults to 0
                        which is suitable for single crate systems.
                    </para>
                </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>    <function>Reset</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a module soft reset. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>LightLed</function></funcdef><void /><modifier>const</modifier>
                            
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Turns on the U led on the module.  This LED is available for application
                            specific signalling.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>ClearLed</function></funcdef><void /><modifier>const</modifier>
                            
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Turns off the U led on the module. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>bool</type> <function>isLedLit</function></funcdef><void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>true</literal> if the U LED is lit. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>SetLatchMode</function></funcdef><void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Requests that the module operate in latch mode.  In latch mode,
                            inputs that are asserted will be transferred to the event memory
                            when the next event signal transitions to asserted.
                            See also <function>SetCoincidenceMode</function>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>SetCoincidenceMode</function></funcdef>
                        <void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Places the module in coincidence mode.  In coincidence mode, signals that
                            are asserteed during the length the gate is present are transmitted to the
                            event memory as one, otherwise as zero.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>bool</type> <function>isLatchMode</function></funcdef><void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>true</literal> if the module has been set in latch mode.
                            If the module is in coincidence mode, this will return <literal>false</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>EnableExternalClear</function></funcdef><void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables the external fast clear input.  This is used in conjunction with the
                            fast clear window to allow events to be rejected prior to transferring them
                            to the fifo.  A fast clear signal that arrives within the fast clear
                            window of the end(?) of the gate discards the event prior to transfer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>DisableExternalClear</function></funcdef>
                        <void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Disables the module external fast clear input. Transitions to asserted on
                            this line will have no impact on the operation of the module, regardess of
                            their timing relative to the fast clear window.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>bool</type> <function>ExternalClearEnabled</function></funcdef>
                        <void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>true</literal> if the external fast clear is enabled.
                        </para>
                    </listitem>
                </varlistentry>
               <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>EnableExternalNext</function></funcdef>
                            <void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables the external next input to act either as a latch or coincidence
                            window depending on the mode of the module.
                        </para>
                    </listitem>
                </varlistentry>
  
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>DisableExternalNext</function></funcdef> <void /><modifier>const</modifier>

                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Disables the external next input. When external next is disabled,
                            data can only be latched by a programmatic latch.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>bool</type> <function>ExternalNextEnabled</function></funcdef>
                            <void /><modifier>const</modifier>
                    
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>true</literal> if the external next signal is enabled.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>SetFastClearWindow</function></funcdef>
                    <paramdef><type>int</type> <parameter>ns</parameter></paramdef>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the fast clear window in nano seconds.  Note that there is
                            a granularity to the fast clear window width.  See
                            section 7.4 of the SIS 3600 manual.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>int</type>  <function>GetFastClearWindow</function></funcdef>
                    <void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value of the fast clear window in ns.  Due to the granularity
                            of the fast clear window, it's not strange to set a fast clear window and
                            then ask the card what the fast clear window actually turned out to be.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>Enable</function></funcdef>
                    <void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables the module's ability to clock in new events.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>Disable()</function></funcdef>
                    <void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Disables the module's ability to clock in new events.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>Clock</function></funcdef>
                    <void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Clocks in the next event.  If the module is in latch mode,
                            it is pretty easy to see that the data presented to the module
                            at the time the function is called is loaded into the FIFO as the next event.
                            It is not clear from the manual documentation what  it means to call this
                            whe the module is in coincidence mode.  My guess is that there is a finite
                            width to the internal clock generated by this function, and  the width of
                            that signal determines the coincidence window.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>StartLatch</function></funcdef>
                    <void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Begins a latch operation.  In coincidence mode this allows a (long)
                            software timed coincidence window to be programmed. Calling this
                            starts the window.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>EndLatch</function></funcdef>
                    <void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Ends a software timed latch (load next event) window.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>bool</type> <function>DataReady</function></funcdef>
                    <void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>true</literal> if the module has data in its FIFO.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>ClearData</function></funcdef>
                    <void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Clears any data that may be hanging around in the FIFO.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned long</type> <function>Read</function></funcdef>
                    <void /><modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads an event (one longword) from the FIFO of the module and returns
                            it as the function value.  If there are no events in the FIFO, the
                            function throws an exception of type <type>std::string</type>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned int</type>  <function>Read</function></funcdef>
                    <paramdef><type>void*</type> <parameter>pBuffer</parameter></paramdef>
                    <paramdef><type>int</type> <parameter>nLongs</parameter></paramdef>
                    <modifier>const</modifier>
                </funcprototype></funcsynopsis>
                </term>
                <listitem>
                    <para>
                        Reads at most <parameter>nLongs</parameter> from the event FIFO to the
                        buffer pointed to by <parameter>pBuffer</parameter>.  Returns the number of
                        longwords that were actually read.  This can be less than <parameter>nLongs</parameter>
                        or even 0 if there fewer than <parameter>nLongs</parameter> in the module's FIFO
                    </para>
                </listitem>
            </varlistentry>               
            </variablelist>
        </refsect1>
 
        <refsect1>
            <title>Exceptions</title>
            <para>
                For various errors, <type>std::string</type> exceptions are thrown.
                The exception contents are error messages so it's reasonable to say:
                <programlisting>
try {
   &hellip;   // Calls to CSIS 3600 stuff.
}
catch (std::string msg) {
   cerr &lt;&lt; "String error caught " &lt;&lt; msg &lt;&lt; endl;
   exit(-1);
}
                </programlisting>
            </para>
        </refsect1>
        
    </refentry>
    <refentry id="CSIS3820">
        
        <refmeta>
            <refentrytitle>CSIS3820</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CSIS3820</refname>
            <refpurpose>Low level support for SIS 3820 32 channel latching scaler module</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CSIS3820.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CSIS3820</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CSIS3820</methodname>
                    <methodparam><type>unsigned long</type> <parameter>base</parameter></methodparam>
                    <methodparam><type>int</type> <parameter>crate</parameter><initializer>0</initializer></methodparam>
                    <exceptionname>std::string</exceptionname>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>double</type> <methodname>getRevision</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>   <methodname>LightOn</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>   <methodname>LightOff</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>getCsr</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned long</type> <methodname>getAcqMode</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>   <methodname>Reset</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>   <methodname>setOperatingMode</methodname>
                    <methodparam><type>OperatingMode</type> <parameter>mode</parameter></methodparam>
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>OperatingMode</type>  <methodname>getOperatingMode</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type>   <methodname>setInputMode</methodname>
                    <methodparam><type>InputMode</type> <parameter>mode</parameter></methodparam>
                    <modifier>const</modifier>

                </methodsynopsis>
                <methodsynopsis>
                    <type>InputMode</type> <methodname>getInputMode</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>setLatchSource</methodname>
                    <methodparam><type>LNESource</type> <parameter>mode</parameter></methodparam>
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>LNESource</type> <methodname>getLatchSource</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Arm</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isArmed</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Enable</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Disable</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isEnabled</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>EnableReferencePulser</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>DisableReferencePulser</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isReferencePulserEnabled</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>EnableTestCounter</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>DisableTestCounter</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isTestCounterOn</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>ClearChannels</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>DisableClearOnLatch</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void></type> <methodname>EnableClearOnLatch</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned long</type> <methodname>ReadChannel</methodname>
                    <methodparam><type>unsigned int</type> <parameter>num</parameter></methodparam>
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>ReadAllChannels</methodname>
                    <methodparam><type>unsigned long*</type> <parameter>buffer</parameter></methodparam>
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Latch</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned long</type> <methodname>ReadLatchedChannel</methodname>
                    <methodparam><type>unsigned int</type> <parameter>num</parameter></methodparam>
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>ReadAllLatchedChannels</methodname>
                    <methodparam><type>unsigned long*</type> <parameter>buffer</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>LatchAndRead</methodname>
                    <methodparam><type>unsigned long*</type> <parameter>buffer</parameter></methodparam>
                    <modifier>const</modifier>
                </methodsynopsis>
            </classsynopsis>

        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                The CSIS3820 is a 32 channel latching scaler with several different modes of operation.
                At the NSCL we usually need to run scalers as simple latching scalers.  That mode
                is the one best supported and tested.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <variablelist>
                <varlistentry><term>
                    <funcsynopsis><funcprototype><funcdef>
                    <function>CSIS3820</function></funcdef>
                    <paramdef><type>unsigned long</type> <parameter>base</parameter></paramdef>
                    <paramdef><type>int</type> <parameter>crate</parameter><initializer>0</initializer></paramdef>
                                  </funcprototype></funcsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates an object that can control an SIS 3820 scaler.  The <parameter>base</parameter>
                        parameter is the base address programmed into the rotary switches of the module,
                        while the <parameter>crate</parameter> parameter is the VME crate number.
                        If <parameter>crate</parameter> is not supplied it defaults to zero which
                        is exactly right for a system with a single VME crate.
                    </para>
                </listitem>
                </varlistentry>
                
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>double</type> <function>getRevision</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                </funcprototype></funcsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the firmware revision from the Id/firmware revision register.
                    </para>
                </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>   <function>LightOn</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                </funcprototype></funcsynopsis>
                </term>
                <listitem>
                    <para>
                        Turns on the user LED.
                    </para>
                </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>   <function>LightOff</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                </term>
                <listitem>
                    <para>
                        Turns the user led off.
                    </para>
                </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned int</type> <function>getCsr</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the contents of the control status register.
                    </para>
                </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned long</type> <function>getAcqMode</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the contents of the acquisition mode register.
                    </para>
                </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>   <function>Reset</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                </term>
                <listitem>
                    <para>
                        Does a software reset on the module.
                    </para>
                </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>   <function>setOperatingMode</function></funcdef>
                    <paramdef><type>OperatingMode</type> <parameter>mode</parameter></paramdef>
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                </term>
                <listitem>
                    <para>
                        Set the modue operating mode.  See "Types and public data" below
                        for a description of the <type>OperatingMode</type> data type.
                    </para>
                </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>OperatingMode</type>  <function>getOperatingMode</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the module operating mode.  See "Types and public data"
                        for a description of the <type>OperatingMode</type> data type.
                    </para>
                </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type>   <function>setInputMode</function></funcdef>
                    <paramdef><type>InputMode</type> <parameter>mode</parameter></paramdef>
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                </term>
                <listitem>
                    <para>
                        Set the module's input mode.  This governs the meaning of the control inputs.
                        See "Types and public data" for a description of the <type>InputMode</type>
                        data type.
                    </para>
                </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>InputMode</type> <function>getInputMode</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the module's current input mode. The input mode
                            determines the meaning of the inputs on the module's control bus.
                            The <type>InputMode</type> data type and its allowed values are
                            decribed further in "Types and public data" below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>setLatchSource</function></funcdef>
                    <paramdef><type>LNESource</type> <parameter>mode</parameter></paramdef>
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Set the source of the "load next event" signal.  This signal
                            determines when to latch data
                            For more information about the <type>LNESource</type>
                            data type and its allowed values, see the
                            section "Types and public data" below
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>LNESource</type> <function>getLatchSource</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the current source of the "load next event" signal.
                            See <function>setLatchSource</function> for more information about
                            this.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>Arm</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Arms the module.  The module cannot be enabled until it is armed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>bool</type> <function>isArmed</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>true</literal> if the module is armed for data taking.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>Enable</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables the module.  Once the module is armed and enabled, events can be
                            latched into it using the Load next event source.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>Disable</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Disables the module.  When disabled, the module cannot
                            take data (ignores its load next event source).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>bool</type> <function>isEnabled</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>true</literal> if the module is enabled
                            for data taking.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>EnableReferencePulser</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enales the reference pulser to channel 0 of the scaler.  The reference
                            pulser is a 50Mhz data source that can be routed into the first of
                            the scaler channels.  Note that the manual numbers channels from
                            1, however we use the more conventionaly 0 based numbering.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>DisableReferencePulser</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Disables the reference pulser.  See <function>EnableReferencePulser</function>
                            above for more information about the reference pulser.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>bool</type> <function>isReferencePulserEnabled</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>true</literal> if the reference pulser is enabled.
                            See <function>EnableReferencePulser</function>
                            and <function>DisableReferencePulser</function>
                            for more information about how to turn this on and off.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>EnableTestCounter</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                        <listitem>
                            <para>
                                Enables the test counter.  The test counter is a 25Mhz pulser
                                that can be enabled into all channels of the scaler.
                            </para>
                        </listitem>
                    </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>DisableTestCounter</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Disables the test counter.  See
                            <function>EnableTestCounter</function> for more information about the
                            test counter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>bool</type> <function>isTestCounterOn</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns <literal>true</literal> if the test counter is enabled.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>ClearChannels</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Clears the counters of all the channels of the scaler.  Note that this does
                            not clear the multi-event memory.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>DisableClearOnLatch</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            By default, the Latch next event pulse clears the counters.
                            This makes the event buffers incremental scaler values, which
                            is what scaler programs at the NSCL expect.  This disables that
                            function making the scaler values read 'absolute' values..at least
                            until they roll over.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void></type> <function>EnableClearOnLatch</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables the scalers to clear counters on the "Load next event"
                            signal.  
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned long</type> <function>ReadChannel</function></funcdef>
                    <paramdef><type>unsigned int</type> <parameter>num</parameter></paramdef>
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads a single channel from the scaler.  Note that this function
                            reads the live counters, rather than the event memory or latches.
                            The live counters may be unstable.
                         </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>ReadAllChannels</function></funcdef>
                    <paramdef><type>unsigned long*</type> <parameter>buffer</parameter></paramdef>
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                        <listitem>
                            <para>
                                Reads all of the scaler channels.  Note that this uses
                                <function>ReadChannel</function> to operate.  This means
                                that the raw counters are read, not the latched values so
                                there is at least time skew between channel 0 anbd channel 31,
                                and there may be some instability in the counter values.
                            </para>
                        </listitem>
                    </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>Latch</function></funcdef>
                    <void />
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Latches the scaler counters in to the latches and the event buffer.
                            Once latched the values are stable.  The counters will be cleared if
                            clear on latch is enabled
                            (see <function>DisableClearOnLatch</function> and
                            <function>EnableClearOnLatch</function>).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>unsigned long</type> <function>ReadLatchedChannel</function></funcdef>
                    <paramdef><type>unsigned int</type> <parameter>num</parameter></paramdef>
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads one of the latched channel registers.  This will hold the value
                            of a channel counter at the time of the last Load Next Event operation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>ReadAllLatchedChannels</function></funcdef>
                    <paramdef><type>unsigned long*</type> <parameter>buffer</parameter></paramdef>
                    </funcprototype></funcsynopsis>
                    </term>
                        <listitem>
                            <para>
                                Reads all 32 latch registers into <parameter>buffer</parameter>.
                                These registers will hold the values of the counters as of the
                                most recent "Load Next Event" signal.
                            </para>
                        </listitem>
                    </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>void</type> <function>LatchAndRead</function></funcdef>
                    <paramdef><type>unsigned long*</type> <parameter>buffer</parameter></paramdef>
                    <modifier>const</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                        <listitem>
                            <para>
                                Peforms a load next event and reads all latch registers into the
                                <parameter>buffer</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title>Types and public data</title>
            <para>
                The <filename>CSIS3820.h</filename> defines several enumerated data types that
                are passed to the various setup functions of the module.
            </para>
            <refsect2>
                <title><type>CSIS3820::OperatingMode</type></title>
                <para>
                    This enumerated type defines the module operating modes:
                    <variablelist>
                        <varlistentry>
                            <term><type>CSIS3820::LatchingScaler</type></term>
                            <listitem>
                                <para>
                                    The module will operate as a latching scaler.
                                    This is the only mode that is really supported at the NSCL.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><type>CSIS3820::MultiChannelScaler</type></term>
                            <listitem>
                                <para>
                                    In this mode, the scaler takes data for fixed repetetive time
                                    periods and then latches the values into its event memory.
                                    This mode is not really supported (yet), as there is no
                                    mechanims to access the multievent memory.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><type>CSIS3820::HistogramingScaler</type></term>
                            <listitem>
                                <para>
                                    In this mode, the scaler performs much like the multiscaler mode
                                    described above except that the events saved are sums over all
                                    of the time periods.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
            </refsect2>
            <refsect2>
                <title><type>CSIS3820::InputMode</type></title>
                <para>
                    This enumerated type defines the possible input modes for the device.
                    Input modes determine the meaning of the control inputs.
                    Section 7.18.2 of the SIS3820 manual provides a detailed description of
                    the input modes.
                    Possible values for this type include:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>CSIS3820::NoInputs</type></term>
                        <listitem>
                            <para>
                                The inputs have no function (mode 0).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>CSIS3820::InputLatchInhibitLatch</type></term>
                        <listitem>
                            <para>
                                Input 1 is an external load next event pulse.   Input 2 and 3
                                are external user inputs that are available in the control register.
                                Input 4 is an inhibit for the Load Next Event input.
                                (Mode 1).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>CSIS3820::InputLatchInhibitAllAndLatch</type></term>
                        <listitem>
                            <para>
                                (Mode 2).  Input 1 is an external load next event input,
                                input 2 is external user bit 1 in the status register,
                                Input 3 inhibits counting in all channels of the scaler and Input4 inhibits te
                                load nexte event input.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>CSIS3820::InputLatchInhibitAll</type></term>
                        <listitem>
                            <para>
                                (Mode 3). Input 1 is the extneral latch next event. Inputs 2 and 3 are
                                the user input bits 1 and 2 respectively in the control register and
                                input 4 inhibits counting in all channels of the scaler.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>CSIS3820::InhibitGroups</type></term>
                        <listitem>
                            <para>
                                (Mode 4).  Each input inhibits a group of 8 channels.
                                Input 1 inhibits channels 0-7, input 2 inhibits channels 8-15 etc.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>CSIS3820::InputLNEHiscal</type></term>
                        <listitem>
                            <para>
                                Mode 5: Input 1 is the load next event input while input two
                                starts the module's histogramming scaler data taking. All other
                                inputs have no function.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>CSIS3820::InputLNEInhAllExtClear</type></term>
                        <listitem>
                            <para>
                                Mode 6: Input 1 is the load next event input.  Input 2 inhibits counting
                                in all counters. input 3 clears all counters.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect2>
            <refsect2>
                <title><type>CSIS3820::LNESource</type></title>
                <para>
                    Sets source of the latch next event signal.  This can have any of the following
                    values:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><type>CSIS3820::LatchVMEonly</type></term>
                        <listitem>
                            <para>
                                Next event an only be latched from the VME (via calls to functions
                                that latch the event such as <function>Latch</function>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>CSIS3820::LatchFP</type></term>
                        <listitem>
                            <para>
                                Latch only on front panel input.  This requires an input mode be
                                set that enables one of the front panel inputs as a Load next event
                                signal.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>CSIS3820::Latch10Mhz</type></term>
                        <listitem>
                            <para>
                                Latches based on the 10Mhz internal clock divided by the
                                latch preset register (not really supported)
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>CSIS3820::LatchChannelN</type></term>
                        <listitem>
                            <para>
                                Latch on the overflow of a channel selected
                                by the LNE channel select register.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>CSIS3820::LatchPresetN</type></term>
                        <listitem>
                            <para>
                                Latch on counts in the selected scaler register divided
                                by the preset register value.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect2>
        </refsect1>
        <refsect1>
            <title>Exceptions</title>
            <para>
                <type>std::string</type> exceptions get thrown when various error conditions occur.
            </para>
        </refsect1>        
    </refentry>
     <refentry id="CScaler">
         
         <refmeta>
             <refentrytitle>CScaler</refentrytitle>
             <manvolnum>3DeviceSupport</manvolnum>
         </refmeta>
         
         <refnamediv>
             <refname>CScaler</refname>
             <refpurpose>Abstract base class for reading scalers into a vector</refpurpose>
         </refnamediv>
         
         <refsynopsisdiv>
            <programlisting>
#include &lt;CScaler.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CScaler</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CScaler</methodname>
                    <void />
                </constructorsynopsis>
                <methodsynopsis>
                    <type>virtual   void</type> <methodname>Initialize</methodname> 
                        <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual   void</type>
                    <methodname>Read</methodname>
                    <methodparam><type>std::vector&lt;unsigned long&gt;&amp;</type> <parameter>Scalers</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual   void</type> <methodname>Clear</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual   unsigned int</type>
                    <methodname>size</methodname>
                    <void />
                </methodsynopsis>
            </classsynopsis>
         </refsynopsisdiv>
         
         <refsect1>
             <title>Description</title>
             <para>
                The <classname>CScaler</classname> class is an abstract base class for
                high level support for scaler modules that append data into an STL vector.
                The interfaces defined by this class are suitable for use with scaler classes
                in the production readout skeleton.
             </para>
             <para>
                Since  <classname>CScaler</classname> is an abstract base class this documentation
                will only describe the expectations that must be met by concrete derived classes.
             </para>
         </refsect1>
         <refsect1>
             <title>Public member functions</title>
             <variablelist>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                        <type>virtual   void</type> <function>Initialize</function></funcdef> 
                            <void />
                        </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This function is expected to perform pre-start initialization.  Once this
                            function returns, the scaler managed by this object should be able to
                            count given appropriate inputs.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                        <type>virtual   void</type>
                        <function>Read</function></funcdef>
                        <paramdef><type>std::vector&lt;unsigned long&gt;&amp;</type> <parameter>Scalers</parameter></paramdef>
                        </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            <function>Read</function> is supposed to read all channels from the
                            scaler module controlled by this object and sequentially append them to the
                            vector <parameter>Scalers</parameter>.  An STL vector is appended to by
                            invoking it's <function>push_back()</function> member.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                        <type>virtual   void</type> <function>Clear</function></funcdef>
                        <void />
                        </funcprototype></funcsynopsis>
                    </term>
                        <listitem>
                            <para>
                                This function is expected to clear all scaler channels.  Note that
                                if <function>Initialize</function> and <function>Read</function>
                                both exit with the scaler counters cleared, this function can be
                                implemented as a <literal>no-op</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                <varlistentry>
                    <term><funcsynopsis><funcprototype><funcdef>
                        <type>virtual   unsigned int</type>
                        <function>size</function></funcdef>
                        <void /><modifier> = 0</modifier>
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This function is no longer actually called but currently must be
                            implemented.  It used to return the number of scaler channels the
                            object would read.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
         </refsect1>
         <refsect1>
             <title>SEE ALSO</title>
             <para>
                For information about STL's vector template class see:
                <citation>
                    <author><firstname>David</firstname>
                            <othername>R.</othername>
                            <surname>Musser</surname>
                    </author>
                    <author><firstname>Gillmer</firstname>
                            <othername>J.</othername>
                            <surname>Derge</surname>
                    </author>
                    <author>
                        <firstname>Atul</firstname>
                        <surname>Saini</surname>
                    </author>
                    <citetitle>STL Tutorial and Reference Guide, C++ Programming with the
                        Standard Template Library</citetitle>
                </citation>
             </para>
         </refsect1>
         
     </refentry>
    <refentry id="CStatusModule">
        
        <refmeta>
            <refentrytitle>CStatusModule</refentrytitle>
            <manvolnum>3DeviceControl</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CStatusModule</refname>
            <refpurpose>Abstract base class for status modules.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CStatusModule.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CStatusModule</classname></ooclass>
                <methodsynopsis>
                    <type>virtual void</type> <methodname>GoBusy</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual   void</type> <methodname>GoClear</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual   void</type> <methodname>ModuleClear</methodname>
                    <void />
                </methodsynopsis>
            </classsynopsis>

        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                <classname>CStatusModule</classname> is an abstract base class for status module classes.
                The NSCL Data acquisition system readout software is an event by event readout system.
                in that mode, each event has a dead-time associated with the time it takes to read
                a single event.  Unless digitizers with multi event buffers are used, and used in
                multi-event mode, it is necessary to hold off triggers while the system is dead due to
                the software overhead.   This is done via <firstterm>status modules</firstterm>.
                A status module is by the software primarily to let the external electronics know
                that it has finished and that additional events can be gated into the system.
            </para>
            <para>
                Due to the fact that software latencies are normally several microseconds we
                recommend using  a status module in conjunction with a latch module.  The latch gets
                set by the master trigger, and subsequently cleared by the software generated outputs
                of the status module.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <para>
                Note that since this class is an abstract base class, we will describe the expectations
                the client has of the abstract member functions as implemented by concrete subclasses.
            </para>
            <variablelist>
               <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>virtual void</type> <function>GoBusy</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This will be called when the system is going to go busy
                            for a while, and be unable to respond to triggers.
                            Note that this will <emphasis>not</emphasis> be called
                            for each event, as the latencies are too long to make that useful.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>virtual   void</type> <function>GoClear</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Called when the the system can go live and accept new events.
                            The status module should emit a signal to the external dead time
                            logic to clear any busy latch that may have been set.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry><term><funcsynopsis><funcprototype><funcdef>
                    <type>virtual   void</type> <function>ModuleClear</function></funcdef>
                    <void />
                    </funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Called when it is necessary to clear data taking modules.
                            Some/many status modules have extra outputs that can be fanned
                            out into module clear inputs allowing all modules to be cleared
                            in parallel.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
        
    </refentry>
    <refentry id="CTrigger">
        
        <refmeta>
            <refentrytitle>CTrigger</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CTrigger</refname>
            <refpurpose>Abstract base class for triggers</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CVMEInterface.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CTrigger</classname></ooclass>
                <methodsynopsis><type>virtual   bool</type>
                    <methodname>operator()</methodname>
                        <void />
                </methodsynopsis>
            </classsynopsis>

        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                This abstract base class provides interfaces for trigger objects.
                Trigger objects are polled at a high rate during data taking.  They
                are expected to talk with some hardware that is used to indicate a trigger
                to the data taking computer.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <methodsynopsis>
                <type>virtual bool</type>
                <methodname>operator()</methodname>
                <void />
            </methodsynopsis>
            <para>
                This pure virtual member must be implemented in concrete subclasses.
                It should return <literal>true</literal> if a trigger is pending,
                <literal>false</literal> otherwise.  In order to reduce trigger latency,
                it is acceptable for this member to check for a trigger several times before
                returning.
            </para>
        </refsect1>
        
    </refentry>
    <refentry id="CVME">
        
        <refmeta>
            <refentrytitle>CVME</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CVME</refname>
            <refpurpose>Pointer like object for accessing the VME</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CVME.h&gt;
            </programlisting>
            <classsynopsis language="c++">
            <ooclass><classname>CVME&lt;class T%gt;</classname></ooclass>
            <constructorsynopsis><methodname>CVME&lt;T&gt;</methodname>
            <methodparam><type>CVME::VmeSpace</type> <parameter>space</parameter></methodparam>
            <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
            <methodparam><type>UInt_t</type> <parameter>length</parameter></methodparam>
            <methodparam><type>UInt_t</type> <parameter>crate</parameter><initializer></initializer></methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CVME&lt;T&gt;</methodname>
                <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CVME&lt;T&gt;</methodname>
                <methodparam><type>CVMEptr&lt;T&gt;*</type> <parameter>aCVMEptr</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CVME&lt;T&gt;</methodname>
                <methodparam><type>const CVME&amp;</type> <parameter>aCVME</parameter></methodparam>
            </constructorsynopsis>
            <methodsynopsis>
                <type>CVME&lt;T&gt;&amp;</type> <methodname>operator=</methodname>
                <methodparam><type>const CVME&lt;T&gt;&amp;</type> <parameter>aCVME</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>UInt_t</type> <methodname>getOffset</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>UInt_t</type> <methodname>getLength</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>Address_t</type> <methodname>getStart</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>Address_t</type> <methodname>getgenptr</methodname>
                <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>Address_t</type> <methodname>getcurrptr</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>T&amp;</type> <methodname>operator*</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>T*</type> <methodname>operator-&gt;</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>T&amp;</type> <methodname>operator[]</methodname>
                <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>CVME&lt;T&gt;&amp;</type> <methodname>operator+</methodname>
                <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>CVME&lt;T&gt;&amp;</type> <methodname>operator-</methodname>
                <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>CVME&lt;T&gt;&amp;</type> <methodname>operator+=</methodname>
                <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>CVME&lt;T&gt;&amp;</type> <methodname>operator-=</methodname>
                <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
            </methodsynopsis>
        </classsynopsis>

        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                This class provides a pointer like object that can construct and manipulate
                mappings to chunks of VME address space.  It represents a reference counted pointer.
                A reference counted pointer uses a double indirection to accomplish destructor safe
                copy, assign and destroy semantics.  The object itself contains a reference to an
                actual shared, object that points to the underlying memory map.  Reference counts in
                that object are maintained as the the <classname>CVME</classname> object is
                copied and assigned.  While copies of the original <classname>CVME</classname>
                object can be freely created and assigned, the underlying memory map does not get
                destroyed until there are no more references left to it.
            </para>
            <para>
                The class is a 'type pure' pointer.  This means that it is a templated class and only
                dereferences of the pointer to that type are allowed.  For example, a
                <classname>CVME&lt;long&gt;</classname> will only allow dereferences to
                <type>long</type> targets both on  the left and right side of assignments.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <variablelist>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><function>CVME&lt;T&gt;</function></funcdef>
                            <paramdef><type>VmeSpace</type> <parameter>space</parameter></paramdef>
                            <paramdef><type>UInt_t</type> <parameter>base</parameter></paramdef>
                            <paramdef><type>UInt_t</type> <parameter>length</parameter></paramdef>
                            <paramdef><type>UInt_t</type> <parameter>crate</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Constructs a new address space pointer.  The object produced can
                            be used to affect the actual underlying address space defined by the
                            <parameter>space, base, length</parameter> ande <parameter>crate</parameter>
                            parameters.
                	</para>
                        <para>
                            For more information about the <type>VmeSpace</type> type and its legal
                            values, see "Types and public data" below.  Note that if not supplied, the
                            <parameter>crate</parameter> parameter defaults to 0 which is correct for
                            a system that only has a single VME crate.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><function> CVME&lt;T&gt;</function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Constructs a pointer like object to a VME space that points to nothing.
                            One use of this is to create an object that will later be assigned to
                            e.g.:
                            <programlisting>
                                CVME&lt;long&gt;  a;    // points to nothing.
                                a = b;                  // b is an initiazlied CVME&lt;long&gt;.
                            </programlisting>
                	</para>
                        <para>
                            Dereferencing a <classname>CVME</classname> pointer that has been
                            created with this constructor prior to assigning it a value from an
                            initialized <classname>CVME</classname> pointer will result in
                            bus errors or segmentation faults.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><function>CVME&lt;T&gt;</function></funcdef>
                            <paramdef><type>CVMEptr&lt;T&gt;*</type> <parameter>aCVMEptr</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Given a pointer to a <classname>CVMEptr</classname> object constructs
                            a new <classname>CVME</classname> object that points to the address space
                            described by the <parameter>aCVMEpt</parameter>.  Note that
                            <classname>CVMEptr</classname> is the underlying object that is reference
                            count protected by this class.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><function>CVME&lt;T&gt;</function></funcdef>
                            <paramdef><type>const CVME&amp;</type> <parameter>aCVME</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Constructs a new <classname>CVME</classname> that is a functional
                            duplicate of <parameter>aCVME</parameter>.  Functional duplicate means
                            that it points to the same offset of the same underlying address space.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>CVME&lt;T&gt;&amp;</type> <function>operator=</function></funcdef>
                            <paramdef><type>const CVME&lt;T&gt;&amp;</type> <parameter>aCVME</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Assigns to the object from another object of type <classname>CVME</classname>
                            The pointer becomes a functional duplicate of the right hand side of the
                            assignment.  If left hand side object had been pointing to an object,
                            the reference count is decremented, and that object is destroyed if the
                            left hand side object was the last to refer to it.  The reference count
                            of the underlying object of the right hand side of the assignment is incremented
                            to indicate that the left hand side object now points through it too.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>int</type>  <function>operator==</function></funcdef>
                            <paramdef><type>const CVME&lt;T&gt;&amp;</type> <parameter>aCVME</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Tests two pointer like objects for equality.  Two pointer like objects
                            are equal if they point to the same underlying pointer object.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>UInt_t</type>  <function>getOffset</function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Returns the pointer offset relative to the base of the underlying
                            address space.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>UInt_t </type>  <function>getLength</function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Returns the length of the underlying address space the pointer points into.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type> T&amp;</type>  <function>operator*</function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Dereferences the pointer by returning a reference to the thing that is
                            pointed to.  That allows the <firstterm>pointee</firstterm> to be used
                            either as an <firstterm>lvalue</firstterm> or as an <firstterm>rvalue</firstterm>.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>T*</type>  <function>T* operator-&gt; </function></funcdef>
                            <void />
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            If T is a structured data type, this operator allows dereferencing the pointer
                            to get access to an element of that data type.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>T&amp;</type>  <function>operator[]</function></funcdef>
                            <paramdef><type>UInt_t</type> <parameter>nOffset</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Indexes into an array of object of type <type>T</type>  and returns a reference
                            to the <parameter>nOffset</parameter>'th item.  Returning a reference allows
                            the item to be used in expressions either as an lvalue or an rvalue.
                            There is also an overloaded version of this function which we won't bother
                            to document that is <type>const</type>, that allows indexing in situations
                            where the item returned must be immutable.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>CVME&lt;T&gt;&amp;</type> <function>operator+</function></funcdef>
                            <paramdef><type>UInt_t</type> <parameter>nOffset</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Adds the specified offset to the pointer and returns a reference to the
                            modified pointer.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>CVME&lt;T&gt;&amp;</type>  <function>operator-</function></funcdef>
                            <paramdef><type>UInt_t</type> <parameter>nOffset</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Subtracts the offset from the pointer and returns a reference to the
                            resulting pointer.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>CVME&lt;T&gt;&amp;</type>  <function>operator+=</function></funcdef>
                            <paramdef><type>UInt_t</type> <parameter>nOffset</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Adds the specified offset to the pointer and returns a reference to the
                            modified pointer.
                	</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                	<funcsynopsis><funcprototype>
                	    <funcdef><type>CVME&lt;T&gt;&amp;</type>  <function>operator-=</function></funcdef>
                            <paramdef><type>UInt_t</type> <parameter>nOffset</parameter></paramdef>
                	</funcprototype></funcsynopsis>
                    </term>
                    <listitem>
                	<para>
                            Subtracts the offset from the pointer and returns a reference to the
                            resulting pointer.
                	</para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect1>
        <refsect1>
            <title>Types and public data</title>
            <para>
                The VME bus actually implements several distinct memory spaces.  The
                <type>VmeSpace</type> data type is used in the constructor to select which
                of the address spaces to create.  Note that many of the values are
                misnomers. Legitimate values are:
                <variablelist>
                    <varlistentry>
                        <term><literal>a16d16</literal></term>
                        <listitem>
                            <para>
                                Selects an address space where only the low 16 bits are significant.
                                the d16 is because many peripherals that live in this space only support
                                a 16 bit data path.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>a24d16</literal></term>
                        <listitem>
                            <para>
                                Selects an address space where only the low 24 bits are significant.
                                The d16 is because some devices that live in this space only support
                                a 16 bit data path.  This is really synonymous with
                                <literal>a24d32</literal> however.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>a24d32</literal></term>
                        <listitem>
                            <para>
                                Selects an address space where the low 24 bits are significant.
                                The d32 is because most devices that live in this address space
                                have 32 bit data paths.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>a32d32</literal></term>
                        <listitem>
                            <para>
                                Selects an address space where all 32 bits are significant.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </refsect1>
        <refsect1>
            <title>Exceptions</title>
            <para>
                <classname>CRangeError</classname> is thrown if the pointer is positioned out of the
                address range.
            </para>
        </refsect1>
    </refentry>
     <refentry id="CVMEScalerLRS1151">
         
         <refmeta>
             <refentrytitle>CVMEScalerLRS1151</refentrytitle>
             <manvolnum>3DeviceSupport</manvolnum>
         </refmeta>
         
         <refnamediv>
             <refname>CVMEScalerLRS1151</refname>
             <refpurpose>High level support for the LeCroy LRS 1151 VME scaler.</refpurpose>
         </refnamediv>
         
         <refsynopsisdiv>
             <programlisting>
 #include &lt;CVMEScalerLRS1151.h&gt;
             </programlisting>
             <classsynopsis language="c++">
                <ooclass><classname>CVMEScalerLRS1151</classname></ooclass>
                <constructorsynopsis>
                    <methodname> CVMEScalerLRS1151</methodname>
                    <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
                    <methodparam><type>int</type> <parameter>crate</parameter>
                                                  <initializer>0</initializer></methodparam>
                </constructorsynopsis>
                <methodsynopsis><type>virtual void</type>
                                <methodname>Initialize</methodname>
                                <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual void</type> <methodname>Read</methodname>
                    <methodparam><type>std::vector&lt;unsigned long&gt;&amp;</type> <parameter>Scalers</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual void</type> <methodname>Clear</methodname>
                        <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual unsigned int</type> <methodname>size</methodname>
                        <void />
                </methodsynopsis>
             </classsynopsis>
                
         </refsynopsisdiv>
         
         <refsect1>
             <title>Description</title>
             <para>
                Provides high level support for the LeCroy Model LRS 1151 16 channel VME
                scaler.  This module is not recommended for new applications as it is no longer
                being manufactured. Use the SIS 3820, or CAEN V830/CAEN V820 instead. High level support
                is suitable for use with the production readout skeleton.
             </para>
             <para>
                When used with the production readout skeleton, you don't need to do anything
                other than to construct a scaler and register it with the framwork
                (see Examples below).  The public members are documented in the event
                you want to use this support software in other contexts.
             </para>
         </refsect1>
         <refsect1>
            <title>Public member functions</title>
                <methodsynopsis>
                    <methodname> CVMEScalerLRS1151</methodname>
                    <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
                    <methodparam><type>int</type> <parameter>crate</parameter>
                                                  <initializer>0</initializer></methodparam>
                </methodsynopsis>
                <para>
                    Constructs an object that interfaces to a specific LRS 1151 scaler module.
                    <parameter>base</parameter> is the VME base address of the module
                    as set in the module switches.  If <parameter>crate</parameter> is not defined,
                    it defaults to 0 which is suitable for a single VME crate system.  Otherwise,
                    <parameter>crate</parameter> is the number of the VME crate in which the module
                    is installed.
                </para>
                <methodsynopsis><type>virtual void</type>
                                <methodname>Initialize</methodname>
                                <void />
                </methodsynopsis>
                <para>
                    Initializes the module. Once initialized, the  module counters are ready for
                    pulses.
                </para>
                <methodsynopsis>
                    <type>virtual void</type> <methodname>Read</methodname>
                    <methodparam><type>std::vector&lt;unsigned long&gt;&amp;</type> <parameter>Scalers</parameter></methodparam>
                </methodsynopsis>
                <para>
                    Latches the counters in to the second register rank, and reads all channels, appending
                    their values to the <parameter>Scalers</parameter> parameter.  The latch operation
                    ensures that there is no time skew between the values of all channels.
                </para>
                <methodsynopsis>
                    <type>virtual void</type> <methodname>Clear</methodname>
                        <void />
                </methodsynopsis>
                <para>
                    Clears the scaler counters.
                </para>
                <methodsynopsis>
                    <type>virtual unsigned int</type> <methodname>size</methodname>
                        <void />
                </methodsynopsis>
                <para>
                    Returns the number of channels in the module.  Note that the production readout
                    framework does not ever call this function.
                </para>
         </refsect1>
         <refsect1>
             <title>Examples</title>
             <para>
                The example below shows how to use one of these modules in the production readout
                framework:
                <example>
                    <title>Using the LRS 1151 in the production readout framework.</title>
                    <programlisting>
#include &lt;CLVMEScalerLRS1151.h&gt;
...
void
CMyExperiment::SetupScalers(CExperiment&amp; rExperiment)
{
   CReadoutMain::SetupScalers(rExperiment);


   CScaler* pScaler = new CVMEScalerLRS1151(0xc00200, 0);
   rExperiment.AddScalerModule(pScaler);

}

                    </programlisting>
                </example>
             </para>
         </refsect1>
         
     </refentry>
    <refentry id="CVMEStatusModule">
        
        <refmeta>
            <refentrytitle>CVMEStatusModule</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CVMEStatusModule</refname>
            <refpurpose>Implement a status module using the CAEN V262 module.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CVMEStatusModule.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CVMEStatusModule</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CVMEStatusModule</methodname>
                    <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
                    <methodparam><type>int</type> <parameter>crate</parameter>
                                                  <initializer>0</initializer></methodparam>
                </constructorsynopsis>
                <constructorsynopsis>
                    <methodname>CVMEStatusModule</methodname>
                    <methodparam><type>const CCaenIO&amp;</type> <parameter>module</parameter></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>virtual   void</type> <methodname>GoBusy</methodname>
                            <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual   void</type> <methodname>GoClear</methodname>
                            <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>virtual   void</type> <methodname>ModuleClear</methodname>
                        <void />
                </methodsynopsis>
            </classsynopsis>
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                Implements a concrete status class for the CAEN V262 I/O module.  While this
                module is no longer in the CAEN catalog, the NSCL has quite a few of them and
                we do not <emphasis>yet</emphasis> discourage its use.  The CAENV V977 module is
                one alternative to this device.
            </para>
            <para>
                See also the <classname>CVMETrigger</classname> class that uses this module
                as a trigger module.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <methodsynopsis>
                <methodname>CVMEStatusModule</methodname>
                <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
                <methodparam><type>int</type> <parameter>crate</parameter>
                                              <initializer>0</initializer></methodparam>
            </methodsynopsis>
            <para>
                Constructs a status module based on the CAEN V262.  The V262 has a base address
                of <parameter>base</parameter> set in its rotary switches and lives in
                VME crate <parameter>crate</parameter>, which defaults to crate 0 if not supplied.
                The default is correct for a single crate system.
            </para>
            <methodsynopsis>
                <methodname>CVMEStatusModule</methodname>
                <methodparam><type>const CCaenIO&amp;</type> <parameter>module</parameter></methodparam>
            </methodsynopsis>
            <para>
                Constructs a VME status module given a pre-existing CAEN V262 object
                (<classname>CCaenIO</classname>).
            </para>
            <methodsynopsis>
                <type>virtual   void</type> <methodname>GoBusy</methodname>
                        <void />
            </methodsynopsis>
            <para>
                The status module indicates the system is unable to accept triggers
                by pulsing the <literal>SHP 0</literal> output.
            </para>
            <methodsynopsis>
                <type>virtual   void</type> <methodname>GoClear</methodname>
                        <void />
            </methodsynopsis>
            <para>
                The status module indicates the system is now able to accept triggers
                after going dead (either due to a trigger or a call to <methodname>GoBusy</methodname>)
                by pulsing <literal>SHP 1</literal>.
            </para>
            <methodsynopsis>
                <type>virtual   void</type> <methodname>ModuleClear</methodname>
                    <void />
            </methodsynopsis>
            <para>
                Indicates the modules can be cleared by pulsing <literal>SHP 3</literal>.
                This can be fanned out into modules with external clears.
            </para>
        </refsect1>
    </refentry>
    <refentry id="CVMETrigger">
        
        <refmeta>
            <refentrytitle>CVMETrigger</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CVMETrigger</refname>
            <refpurpose>VME trigger class based on the CAEN V262 I/O module.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CVMETrigger.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CVMETrigger</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CVMETrigger</methodname>
                    <methodparam><type>unsigned int</type> <parameter>base</parameter></methodparam>
                    <methodparam><type>int</type> <parameter>crate</parameter> <initializer>0</initializer></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>virtual   bool</type> <methodname>operator()</methodname>
                                                <void />
                </methodsynopsis>
            </classsynopsis>
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                Implements a concrete trigger module object based on the CAEN V262 module.  The
                trigger is assumed to be input 0.  Note that the inputs to this module are not latched
                by the module.  A trigger must be externally latched until at least it is acknowledged
                by a pulse on the <literal>SHP 2</literal> output, or else triggers can and will be
                missed.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <methodsynopsis>
                <methodname>CVMETrigger</methodname>
                <methodparam><type>unsigned int</type> <parameter>base</parameter></methodparam>
                <methodparam><type>int</type> <parameter>crate</parameter> <initializer>0</initializer></methodparam>
            </methodsynopsis>
            <para>
                Constructs a VME trigger module based on the CAEN V262 I/O register.
                The <parameter>base</parameter> parameter is the base address configured into
                the rotary switches of the physical module.  The <parameter>crate</parameter>
                parameter was introduced in version 8.1-001.  If provided, it allows the trigger to
                live in VME crates other than crate 0.   If omitted, it defaults to crate 0 which was
                the behavior prior to 8.1-001 and also is normal and correct for a single crate system.
            </para>
            <methodsynopsis>
                <type>virtual   bool</type> <methodname>operator()</methodname>
                                            <void />
            </methodsynopsis>
            <para>
                If input 0 is logical true, the <literal>SHP 2</literal> output is pulsed and
                the function returns <literal>true</literal>.  Otherwise <literal>false</literal>
                is returned.                                                        
            </para>
        </refsect1>
    </refentry>
     <refentry id="CVMEptr">
         
         <refmeta>
             <refentrytitle>CVMEptr</refentrytitle>
             <manvolnum>3DeviceSupport</manvolnum>
         </refmeta>
         
         <refnamediv>
             <refname>CVMEptr</refname>
             <refpurpose></refpurpose>
         </refnamediv>
         
         <refsynopsisdiv>
            <programlisting>
#include &lt;CVMEptr.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CVMEptr&lt;T&gt;</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CVMEptr&lt;T&gt;</methodname>
                        <methodparam><type>UInt_t</type> <parameter>space</parameter></methodparam>
                        <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
                        <methodparam><type>UInt_t</type> <parameter>length</parameter></methodparam>
                        <methodparam><type>UInt_t</type> <parameter>crate</parameter><initializer>0</initializer></methodparam>
                </constructorsynopsis>

                <constructorsynopsis>
                    <methodname>CVMEptr&lt;T&gt;</methodname>
                    <methodparam><type>Space</type> <parameter>space</parameter></methodparam>
                    <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
                    <methodparam><type>UInt_t</type> <parameter>length</parameter></methodparam>
                    <methodparam><type>UInt_t</type> <parameter>crate</parameter>
                                                     <initializer>0</initializer></methodparam>
                </constructorsynopsis>
                <constructorsynopsis>
                    <methodname>CVMEptr&lt;T&gt;</methodname>
                    <methodparam><type>const CVMEptr&amp;</type> <parameter>aCVMEptr</parameter></methodparam>
                </constructorsynopsis>
                <constructorsynopsis>
                    <methodname>CVMEptr&lt;T&gt;</methodname>
                    <void />
                </constructorsynopsis>
                <methodsynopsis>
                    <type>Address_t</type>
                    <methodname>getgenptr</methodname>
                    <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>Address_t</type> <methodname>getcurrptr</methodname>
                                           <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>T&amp;</type> <methodname>operator*</methodname>
                                        <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>T*</type> <methodname>operator-&gt;</methodname>
                                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>T&amp;</type> <methodname>operator[]</methodname>
                        <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>CVMEptr&lt;T&gt;</type> <methodname>operator+</methodname>
                    <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>CVMEptr&lt;T&gt;</type> <methodname>operator-</methodname>
                    <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>CVMEptr&lt;T&gt;&amp;</type> <methodname>operator+=</methodname>
                    <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>CVMEptr&lt;T&gt;&amp;</type> <methodname>operator-=</methodname>
                    <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>CVMEptr&lt;T&gt;&amp;</type> <methodname>operator++</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>CVMEptr&lt;T&gt;&amp;</type>
                    <methodname>operator--</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>CVMEptr&lt;T&gt;</type> <methodname>operator++</methodname>
                    <methodparam><type>Int_t</type><parameter /></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>CVMEptr&lt;T&gt;</type> <methodname>operator--</methodname>
                    <methodparam><type>Int_t</type><parameter /></methodparam>
                </methodsynopsis>
            </classsynopsis>
         </refsynopsisdiv>
         
         <refsect1>
             <title>Description</title>
             <para>
                Implements an unreference counted pointer to VME space.  For the unreference
                counted pointer, to destroy one object invalidates all other copies of the
                object.  In general you should prefer the <classname>CVME</classname> class which
                has the same functionality but is safer to use.
             </para>
         </refsect1>
         <refsect1>
             <title>Public member functions</title>
            <methodsynopsis>
                 <methodname>CVMEptr&lt;T&gt;</methodname>
                     <methodparam><type>UInt_t</type> <parameter>space</parameter></methodparam>
                     <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
                     <methodparam><type>UInt_t</type> <parameter>length</parameter></methodparam>
                     <methodparam><type>UInt_t</type> <parameter>crate</parameter><initializer>0</initializer></methodparam>
             </methodsynopsis>
            <para>
                Constructs a <classname>CVMEptr</classname> object for type <type>T</type>.
                The pointer points to a block of VME address space.  Attempts to reference outside
                of this block will, in general, throw exceptions.  The address block is defined as:
                <variablelist>
                    <varlistentry>
                        <term><type>UInt_t</type> <parameter>space</parameter></term>
                        <listitem>
                            <para>
                                Selects which address space the block is selected to live in.
                                See "Types and public data" below for more information about the
                                legal value of the <parameter>space</parameter> parameter as it
                                is just the integer equivalent of the <type>Space</type> type elements.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>UInt_t</type> <parameter>base</parameter></term>
                        <listitem>
                            <para>
                                Defines the base address of the address block that can be
                                referenced by the pointer.  
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>UInt_t</type> <parameter>length</parameter></term>
                        <listitem>
                            <para>
                                Defines the length of the address space block.
                                This length is the size of the region
                                in bytes regardless of the type <type>T</type> of the pointer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>UInt_t</type> <parameter>crate</parameter></term>
                        <listitem>
                            <para>
                                Defines the VME crate number in which this address space
                                lives.  If omitted, this will default to <literal>0</literal>
                                which is perfectly good for single crate systems.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
            <methodsynopsis>
                 <methodname>CVMEptr&lt;T&gt;</methodname>
                 <methodparam><type>Space</type> <parameter>space</parameter></methodparam>
                 <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
                 <methodparam><type>UInt_t</type> <parameter>length</parameter></methodparam>
                 <methodparam><type>UInt_t</type> <parameter>crate</parameter>
                                                  <initializer>0</initializer></methodparam>
            </methodsynopsis>
            <para>
                Creates a pointer as in the previous construtor, however the <parameter>space</parameter>
                parameter is specified using the <type>Space</type> enumerated type which is described
                more completely in the "Types and public data" section below.
            </para>
            <methodsynopsis>
                 <methodname>CVMEptr&lt;T&gt;</methodname>
                 <methodparam><type>const CVMEptr&amp;</type> <parameter>aCVMEptr</parameter></methodparam>
            </methodsynopsis>
            <para>
                Constructs a new pointer that is a functional duplicate of the <parameter>aCVMEptr</parameter>
                parameter.   This pointer uses the same underlying address map as
                <parameter>aCVMEptr</parameter>.
                Therefore, if either of the pointers is destroyed, the other will fail.
            </para>
            <methodsynopsis>
                 <methodname>CVMEptr&lt;T&gt;</methodname>
                 <void />
            </methodsynopsis>
            <para>
                Creates a 'pointer' that does not point to anything.  This pointer can be made
                valid by assigning to it from another <classname>CVMEptr</classname> object.
            </para>
            <methodsynopsis>
                 <type>Address_t</type>
                 <methodname>getgenptr</methodname>
                 <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
            </methodsynopsis>
            <para>
                Returns a 'generic pointer' to the VME bus that is <parameter>nOffset</parameter>
                bytes from the location the pointer is currently pointing to.   The pointer returned
                is an ordeinary <type>void*</type>, and can be cast to anything.  Using this pointer
                throws away all range checking so attempts to reference outside of the block of
                memory that the original pointer points at will yield undefined results.
            </para>
             <methodsynopsis>
                 <type>Address_t</type> <methodname>getcurrptr</methodname>
                                        <void />
             </methodsynopsis>
             <para>
                This is the same as a call to <function>getgenptr(0)</function>.
             </para>
             <methodsynopsis>
                 <type>T&amp;</type> <methodname>operator*</methodname>
                                     <void />
             </methodsynopsis>
             <para>
                Dereferences the pointer, returning a reference to the <type>T</type>
                it points to.  This allows the pointer to be dereferenced on either side
                of an assignment (as an <firstterm>lvalue</firstterm> or an <firstterm>rvalue</firstterm>).
             </para>
             <methodsynopsis>
                 <type>T*</type> <methodname>operator-&gt;</methodname>
                                 <void />
             </methodsynopsis>
             <para>
                If <type>T</type> is a structured type (union, struct or object with public data),
                this allows the pointer to dereference to a field within <type>T</type>.
             </para>
             <methodsynopsis>
                 <type>T&amp;</type> <methodname>operator[]</methodname>
                     <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
             </methodsynopsis>
             <para>
                Indexes to element number <parameter>nOffset</parameter> relative to the current
                position of the pointer and returns a reference to that <type>T</type>.
                Since a reference is used, the result of indexing can be used either as an lvalue
                or an rvalue with respect to the assignment operator.
             </para>
             <methodsynopsis>
                 <type>CVMEptr&lt;T&gt;</type> <methodname>operator+</methodname>
                 <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
             </methodsynopsis>
             <para>
                Returns a new pointer that is advanced by the <parameter>nOffset</parameter>
                <type>T</type>'s from the current pointer (scaled addition).
             </para>
             <methodsynopsis>
                 <type>CVMEptr&lt;T&gt;</type> <methodname>operator-</methodname>
                 <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
             </methodsynopsis>
             <para>
                Returns a new pointer that is <parameter>nOffset</parameter> <type>T</type>'s
                prior to the current pointer (scaled subtraction).
             </para>
             <methodsynopsis>
                 <type>CVMEptr&lt;T&gt;&amp;</type> <methodname>operator+=</methodname>
                 <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
             </methodsynopsis>
             <para>
                Advances the current pointer by <parameter>nOffset</parameter> <type>T</type>'s
                from its current position. 
             </para>
             <methodsynopsis>
                 <type>CVMEptr&lt;T&gt;&amp;</type> <methodname>operator-=</methodname>
                 <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
             </methodsynopsis>
             <para>
                Backs the current pointer up by <parameter>nOffset</parameter> <type>T</type>'s
                from its current position.
             </para>  
             <methodsynopsis>
                 <type>CVMEptr&lt;T&gt;&amp;</type> <methodname>operator++</methodname>
                 <void />
             </methodsynopsis>
             <para>
                Advances the pointer by one <type>T</type>, and returns the value of the pointer
                after this increment (<firstterm>post-increment</firstterm>).
             </para>
             <methodsynopsis>
                 <type>CVMEptr&lt;T&gt;&amp;</type>
                 <methodname>operator--</methodname>
                 <void />
             </methodsynopsis>
             <para>
                Moves the pointer back by one <type>T</type> and returns the pointer after
                this operation (<firstterm>post-decrement</firstterm>).
             </para>
             <methodsynopsis>
                 <type>CVMEptr&lt;T&gt;</type> <methodname>operator++</methodname>
                 <methodparam><type>Int_t</type><parameter /></methodparam>
             </methodsynopsis>
             <para>
                Advances the pointer by one <type>T</type> but returns the value of the
                pointer prior to this operation (<firstterm>pre-increment</firstterm>).
             </para>
             <methodsynopsis>
                 <type>CVMEptr&lt;T&gt;</type> <methodname>operator--</methodname>
                 <methodparam><type>Int_t</type><parameter /></methodparam>
             </methodsynopsis>
             <para>
                Same as the previous operation but does a <firstterm>pre-decrement</firstterm>.
             </para>
         </refsect1>
         <refsect1>
             <title>Types and public data</title>
             <para>
                The <type>Space</type> enumerated type is used to select the VME address space.
                Note that integer equivalents may also be used.  Valid values for the
                <type>Space</type> type are:
                <variablelist>
                    <varlistentry>
                        <term><type>a16</type> <literal>= 0</literal></term>
                        <listitem>
                            <para>
                                The A16 address space is used.  The bottom 16 bits of addresses
                                are significant.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>a24</type> <literal>= 1</literal></term>
                        <listitem>
                            <para>
                                The A24 address space is used.  The bottom 24 bits of address space
                                are importnant.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>a32</type> <literal>= 3</literal></term>
                        <listitem>
                            <para>
                                The 32 bit address space is sused.  All 32 bits of address are significant.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><type>geo</type> <literal>=4</literal></term>
                        <listitem>
                            <para>
                            Geograhpical addressing is used.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
             </para>
         </refsect1>
         <refsect1>
             <title>Exceptions</title>
             <para>
                <type>CMapError </type> exceptions are thrown when the mapping failes.
                <type>CRangeError</type> is thrown when the pointer references or is moved out of
                    the address range that constructed it.
             </para>
         </refsect1>
 
         
     </refentry>
    <refentry id="CaenIO">
        
        <refmeta>
            <refentrytitle>CaenIO</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CaenIO</refname>
            <refpurpose>Support for the CAEN V262 I/O register module.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CaenIO.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CaenIO</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CCaenIO</methodname>
                    <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
                    <methodparam><type>int</type> <parameter>nCrate</parameter><initializer>0</initializer></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname>ReadInput</methodname>
                    <methodparam><type>UInt_t</type> <parameter>input</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname>ReadInputs</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>PulseOutput</methodname>
                    <methodparam><type>UInt_t</type> <parameter>output</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetLevel</methodname>
                    <methodparam><type>UInt_t</type> <parameter>output</parameter>
                    </methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>ClearLevel</methodname>
                    <methodparam><type>UInt_t</type> <parameter>output</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>ClearAll</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetECL</methodname>
                    <methodparam><type>UShort_t</type> <parameter>value</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>ClearECL</methodname>
                                      <void />
                </methodsynopsis>
            </classsynopsis>
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                This class provides low level support for the CAEN V262 I/O register.  This module
                is used by NSCL standard VME trigger and busy classes, but can also be used
                to provide application specific functionality.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
                <methodsynopsis>
                    <methodname>CCaenIO</methodname>
                    <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
                    <methodparam><type>int</type> <parameter>nCrate</parameter><initializer>0</initializer></methodparam>
                </methodsynopsis>
                <para>
                    Creates a <classname>CCaenIO</classname> object.  The object is connected
                    to a real hardware module and can control that module via its member functions.
                    The <parameter>base</parameter> parameter must correspond to the module base
                    address set in the hardware's rotary switches.  If <parameter>nCrate</parameter>
                    is specified, it represents the number of the VME crate in which the module has
                    been installed.  If not, the module is assumed to be installed in VME crate 0,
                    which is suitable for systems with a single VME crate.
                </para>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname>ReadInput</methodname>
                    <methodparam><type>UInt_t</type> <parameter>input</parameter></methodparam>
                </methodsynopsis>
                <para>
                    Reads one of the module's inputs (numbered 0-3).  If the input is NIM true,
                    the function reaturns <literal>1</literal> otherwise it returns
                    <literal>1</literal>.  
                </para>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname>ReadInputs</methodname>
                    <void />
                </methodsynopsis>
                <para>
                    Reads all of the module inputs and returns a mask with bits set to
                    <literal>1</literal> for inputs that have NIM true levels and
                    <literal>0</literal> otherwise.  Input 0 corresponds to the least significant
                    bit of the mask returned.
                </para>
                <methodsynopsis>
                    <type>void</type> <methodname>PulseOutput</methodname>
                    <methodparam><type>UInt_t</type> <parameter>output</parameter></methodparam>
                </methodsynopsis>
                <para>
                    Pulses the selected <literal>SHP</literal> output.
                </para>
                <methodsynopsis>
                    <type>void</type> <methodname>SetLevel</methodname>
                    <methodparam><type>UInt_t</type> <parameter>output</parameter>
                    </methodparam>
                </methodsynopsis>
                <para>
                    Sets the value of one of the <literal>OUT</literal> outputs to a NIM true value.
                </para>
                <methodsynopsis>
                    <type>void</type> <methodname>ClearLevel</methodname>
                    <methodparam><type>UInt_t</type> <parameter>output</parameter></methodparam>
                </methodsynopsis>
                <para>
                    Sets the value of one of the <literal>OUT</literal> outputs to a NIM false value.
                </para>
                <methodsynopsis>
                    <type>void</type> <methodname>ClearAll</methodname>
                                      <void />
                </methodsynopsis>
                <para>
                    Clears all <literal>OUT</literal> and <literal>ECL</literal> outputs,
                    by setting them to false logic levels.
                </para>
                <methodsynopsis>
                    <type>void</type> <methodname>SetECL</methodname>
                    <methodparam><type>UShort_t</type> <parameter>value</parameter></methodparam>
                </methodsynopsis>
                <para>
                    Sets the the <literal>ECL</literal> outputs to the mask <parameter>value</parameter>
                </para>
                <methodsynopsis>
                    <type>void</type> <methodname>ClearECL</methodname>
                                      <void />
                </methodsynopsis>
                <para>
                    Sets all of the <literal>ECL</literal> outputs to false.
                </para>
            </refsect1>
        <refsect1>
            <title>Exceptions</title>
            <para>
                <classname>std::string</classname> exceptions are thrown for bad parameters.
            </para>
        </refsect1>        
    </refentry>
    <refentry id="CMmapError">
        
        <refmeta>
            <refentrytitle>CMmapError</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CMmapError</refname>
            <refpurpose>Exception that can be thrown in the event of memory mapping errors.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;MmapError.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CMmapError : public CException</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CMmapError</methodname>
                    <methodparam><type>const char*</type> <parameter>pDoing</parameter></methodparam>
                </constructorsynopsis>
                <constructorsynopsis>
                    <methodname>CMmapError</methodname>
                    <methodparam><type>const std::string&amp;</type> <parameter>rDoing</parameter></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>virtual const char*</type> <methodname>ReasonText</methodname>
                            <void />
                            <modifier>const</modifier>
                </methodsynopsis>
            </classsynopsis>

        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                <classname>CMmapError</classname> is an exception type that can be
                thrown by device support functions as a result of a failure to create a
                memory mapping to the VME crate.
            </para>
            <para>
                The constructors provide mechanisms to get strings information inserted into the
                exception error information describing what the program was doing when the exception was
                thrown.
            </para>
            <para>
                <methodname>ReasonText</methodname> returns a pointer to a <type>char*</type>
                that can be printed out to provide complete information about the exception to the
                user.
            </para>
        </refsect1>        
    </refentry>
    <refentry id="CNimout">
        
        <refmeta>
            <refentrytitle>CNimout</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CNimout</refname>
            <refpurpose>Low level support for the BiRa VME nim output module</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;Nimout.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CNimout : public CVmeModule</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CNimout</methodname>
                    <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>ClearAll</methodname>
                                            <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>WriteRegister</methodname>
                    <methodparam><type>Register</type> <parameter>reg</parameter></methodparam>
                    <methodparam><type>UShort_t</type> <parameter>pattern</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>Bool_t</type> <methodname>SetStrobeLength</methodname>
                    <methodparam><type>DFloat_t</type> <parameter>time_in_ns</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>StrobeAll</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>OrRegister</methodname>
                    <methodparam><type>Register</type> <parameter>reg</parameter></methodparam>
                    <methodparam><type>UShort_t</type> <parameter>or_pattern</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>AndRegister</methodname>
                    <methodparam><type>Register</type> <parameter>reg</parameter></methodparam>
                    <methodparam><type>UShort_t</type> <parameter>and_pattern</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>Bool_t</type> <methodname>SetBit</methodname>
                    <methodparam><type>Register</type> <parameter>reg</parameter></methodparam>
                    <methodparam><type>UInt_t</type> <parameter>bit_num</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>Bool_t</type> <methodname>ClearBit</methodname>
                    <methodparam><type>Register</type> <parameter>reg</parameter></methodparam>
                    <methodparam><type>UInt_t</type> <parameter>bit_num</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>TransferData</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetTBit</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>ClearCBit</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>ClearTBit</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname>ReadRegister</methodname>
                    <methodparam><type>Register</type> <parameter>reg</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>Bool_t</type> <methodname>ModuleReady</methodname>
                                        <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>Bool_t</type> <methodname>TBitSet</methodname>
                                        <void />
                </methodsynopsis>
            </classsynopsis>
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                This class provides low level support for the BiRA VME NIM output module.
                The module has 16 outputs that can be individually either latched or pulsed.
                The pulse width is programmable over a wide range of values, however it is common
                to all pulsed channels.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <methodsynopsis>
                <methodname>CNimout</methodname>
                <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
            </methodsynopsis>
            <para>
                Constructs a new <classname>CNimout</classname> object that will be used to
                communicate with the actual physical module whose switches have been set to the
                base address <parameter>base</parameter> in VME crate number 0.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>ClearAll</methodname>
                                        <void />
            </methodsynopsis>
            <para>
                Clears all module registers (sets them to zero).
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>WriteRegister</methodname>
                <methodparam><type>Register</type> <parameter>reg</parameter></methodparam>
                <methodparam><type>UShort_t</type> <parameter>pattern</parameter></methodparam>
            </methodsynopsis>
            <para>
                Writes the value <parameter>pattern</parameter> to the module register
                designated by the <parameter>reg</parameter> parameter.  The possible values
                of the <parameter>reg</parameter> parameter are described in
                "Public types and data" below.
            </para>
            <methodsynopsis>
                <type>Bool_t</type> <methodname>SetStrobeLength</methodname>
                <methodparam><type>DFloat_t</type> <parameter>time_in_ns</parameter></methodparam>
            </methodsynopsis>
            <para>
                Sets the length of the pulse for pulsed outputs.  While the time
                <parameter>time_in_ns</parameter> is given in
                ns, please note that the granularity of the tming is 62.5ns.  This function
                will choose the 'closest' strobe time and, if necessary also set or clear the
                bit in the CONTROL register responsible for setting longer timings.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>StrobeAll</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Sets all the bits in the <literal>STROBE</literal> register to 1.  This
                enables all outputs to be pulsed.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>OrRegister</methodname>
                <methodparam><type>Register</type> <parameter>reg</parameter></methodparam>
                <methodparam><type>UShort_t</type> <parameter>or_pattern</parameter></methodparam>
            </methodsynopsis>
            <para>
                Ors the bits in the <parameter>or_pattern</parameter> mask with the contents of the
                register selected by <parameter>reg</parameter>.  This is a bitwise or.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>AndRegister</methodname>
                <methodparam><type>Register</type> <parameter>reg</parameter></methodparam>
                <methodparam><type>UShort_t</type> <parameter>and_pattern</parameter></methodparam>
            </methodsynopsis>
            <para>
                Ands the bits in <parameter>and_pattern</parameter> with the contents of the
                register selected by <parameter>reg</parameter>.  Note that this is a bitwise and.
            </para>
            <methodsynopsis>
                <type>Bool_t</type> <methodname>SetBit</methodname>
                <methodparam><type>Register</type> <parameter>reg</parameter></methodparam>
                <methodparam><type>UInt_t</type> <parameter>bit_num</parameter></methodparam>
            </methodsynopsis>
            <para>
                Sets a specific bit (bit <parameter>bit_num</parameter> numbered from 0 at the
                least significant bit to 15 at the most significant bit), in the register
                designated by <parameter>reg</parameter>.
            </para>
            <methodsynopsis>
                <type>Bool_t</type> <methodname>ClearBit</methodname>
                <methodparam><type>Register</type> <parameter>reg</parameter></methodparam>
                <methodparam><type>UInt_t</type> <parameter>bit_num</parameter></methodparam>
            </methodsynopsis>
            <para>
                Clears the bit specified by <parameter>bit_num</parameter> in the register
                designated by <parameter>reg</parameter>.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>TransferData</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Asks the control register to transfer the data from the data register to the
                hardware.  Bits in the Strobe register that are set select the bits that will
                be strobed on for a time set by the timing register while
                all others will be level outputs.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>SetTBit</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Sets the T bit in the control register. Setting the T bit
                changes the units of the NIM Strobe timing to 4096usec.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>ClearCBit</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Clears the transfer bit in the control/status register.
                Data are transfered by pulsing the C bit in the control
                status register.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>ClearTBit</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Clears the T bit in the control register.  Clearing the T
                bit changes the units of the NIM strobe timing to 62.5ns.
            </para>
            <methodsynopsis>
                <type>UShort_t</type> <methodname>ReadRegister</methodname>
                <methodparam><type>Register</type> <parameter>reg</parameter></methodparam>
            </methodsynopsis>
            <para>
                Reads a register and returns its 16 bit value.  The register read is selected
                by the <parameter>reg</parameter> parameter.  Legal values for this parameter
                documented in the "Types and public data" section below.
            </para>
            <methodsynopsis>
                <type>Bool_t</type> <methodname>ModuleReady</methodname>
                                    <void />
            </methodsynopsis>
            <para>
                Returns <literal>kfTRUE</literal> if the module is ready for another
                operation. This is true if the bottom bit of the status register is
                set.
            </para>
            <methodsynopsis>
                <type>Bool_t</type> <methodname>TBitSet</methodname>
                                    <void />
            </methodsynopsis>
            <para>
                Returns <literal>kfTRUE</literal> if the module's T bit
                is set in the control/status register. If this bit is set,
                NIM strobe timing is set in units of 4096usec if not, the
                strobe timing is in units of 62.5ns.
            </para>

        </refsect1>
        <refsect1>
            <title>Types and public data</title>
            <para>
                The <type>CNimout::Register</type> enumerated type is defined to
                select register names.  It is used by the <function>ReadRegister</function>
                and <function>WriteRegister</function> functions to select the target register.
                legal values of this type are:
                <variablelist>
                    <varlistentry>
                        <term><literal>CNimout::DATA</literal></term>
                        <listitem>
                            <para>
                                Selects the NIM data register (offset 0 in the module).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>CNimout::STROBE</literal></term>
                        <listitem>
                            <para>
                                Selects the NIM Strobe mask register (offset 2 in the module).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>CNimout::TIMING</literal></term>
                        <listitem>
                            <para>
                                Selects the strobe timing register of the module (offset 4 in the module).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>CNimout::CONTROL</literal></term>
                        <listitem>
                            <para>
                                Selects the control status register (offset 6 in the module).
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </refsect1>
        <refsect1>
            <title>Issues and defects</title>
            <itemizedlist>
                <listitem>
                    <para>
                        There is only support for modules in VME crate 0.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        It is the application's responsibility to determine if the module is
                        ready to perform  another transfer operation by calling the
                        <function>ModuleReady</function> function at appropriate times.
                    </para>
                </listitem>
            </itemizedlist>
        </refsect1>
    </refentry>
    <refentry id="CVmeModule">
        
        <refmeta>
            <refentrytitle>CVmeModule</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CVmeModule</refname>
            <refpurpose>Convenience base class for implementing VME module support</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;VmeModule.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CVmeModule</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CVmeModule</methodname>
                    <methodparam><type>Space</type> <parameter>space</parameter></methodparam>
                    <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
                    <methodparam><type>UInt_t</type> <parameter>length</parameter></methodparam>
                    <methodparam><type>int</type> <parameter>nCrate</parameter> <initializer>0</initializer></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>UChar_t</type> <methodname>peekb</methodname>
                    <methodparam><type>UInt_t</type> <parameter>offset</parameter><initializer>0</initializer></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>UShort_t</type> <methodname>peekw</methodname>
                    <methodparam><type>UInt_t</type> <parameter>offset</parameter><initializer>0</initializer></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>ULong_t</type> <methodname>peekl</methodname>
                    <methodparam><type>UInt_t</type> <parameter>offset</parameter><initializer>0</initializer></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>pokeb</methodname>
                    <methodparam><type>UChar_t</type> <parameter>byte</parameter></methodparam>
                    <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>pokew</methodname>
                    <methodparam><type>UShort_t</type> <parameter>word</parameter></methodparam>
                    <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>pokel</methodname>
                    <methodparam><type>ULong_t</type> <parameter>lword</parameter></methodparam>
                    <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>UInt_t</type> <methodname>readl</methodname>
                    <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                    <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                    <methodparam><type>size_t</type> <parameter>longs</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>UInt_t</type> <methodname>readw</methodname>
                    <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                    <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                    <methodparam><type>size_t</type> <parameter>words</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>UInt_t</type> <methodname>readb</methodname>
                    <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                    <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                    <methodparam><type>size_t</type> <parameter>bytes</parameter></methodparam>
                </methodsynopsis>
                
            </classsynopsis> 
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                The <classname>CVmeModule</classname> class provides a convenient set of services for
                device drivers.  Device drivers can either be implemented by private derivation
                or inclusion of an object of type <classname>CVmeModule</classname>, using its member
                functions to access register space or to perform data transfers.
            </para>
            <para>
                Private derivation
                is shown in the example below:
                <example>
                    <title>Creating a device driver via private derivation</title>
                    <programlisting>
class MyDriver  : private CVmeModule
...
                    </programlisting>
                </example>
                In this example, all the member functions of <classname>CVmeModule</classname>
                can be called by member functions of <classname>MyDriver</classname> but not by
                its clients.
            </para>
            <para>
                Layering via inclusion is shown below:
                <example>
                    <title>Creating a device driver via inclusion</title>
                    <programlisting>
class MyDriver {
private:
    CVmeModule&amp;  m_Registers;
    ...
}
                    </programlisting>
                </example>
                In this case, the registers of the module could be acessed through the member
                functions of <varname>m_Registers</varname>.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <methodsynopsis>
                 <methodname>CVmeModule</methodname>
                 <methodparam><type>Space</type> <parameter>space</parameter></methodparam>
                 <methodparam><type>UInt_t</type> <parameter>base</parameter></methodparam>
                 <methodparam><type>UInt_t</type> <parameter>length</parameter></methodparam>
                 <methodparam><type>int</type> <parameter>nCrate</parameter> <initializer>0</initializer></methodparam>
            </methodsynopsis>
            <para>
                Constructs a <classname>CVmeModule</classname> object.  The <parameter>space</parameter>,
                <parameter>base</parameter>, and <parameter>length</parameter> describe the physical
                address space of the module, including its address modifier.
                If <parameter>nCrate</parameter> is supplied,
                it is the number of the VME crate in which the address space is described.  If not supplied,
                this defaults to VME crate 0 which is suitable for systems with a single VME crate.
            </para>
            <methodsynopsis>
                <type>UChar_t</type> <methodname>peekb</methodname>
                <methodparam><type>UInt_t</type> <parameter>offset</parameter><initializer>0</initializer></methodparam>
            </methodsynopsis>
            <para>
                Returns the value of the byte at <parameter>offset</parameter> bytes from the
                base address of the module.  If <parameter>offset</parameter> is not supplied,
                it defaults to zero.
            </para>
            <methodsynopsis>
                <type>UShort_t</type> <methodname>peekw</methodname>
                <methodparam><type>UInt_t</type> <parameter>offset</parameter><initializer>0</initializer></methodparam>
            </methodsynopsis>
            <para>
                Returns the 16 bit word value at <parameter>offset</parameter> words from the
                base address of the module.  If <parameter>offset</parameter> is not supplied,
                it defaults to zero.
            
            </para>
            <methodsynopsis>
                <type>ULong_t</type> <methodname>peekl</methodname>
                <methodparam><type>UInt_t</type> <parameter>offset</parameter><initializer>0</initializer></methodparam>
            </methodsynopsis>
            <para>
                Returns the longword at <parameter>offset</parameter> longwords from the base of the
                module.  If the <parameter>offset</parameter> parameter is not supplied, then
                0 is used.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>pokeb</methodname>
                <methodparam><type>UChar_t</type> <parameter>byte</parameter></methodparam>
                <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
            </methodsynopsis>
            <para>
                Writes the 8 bit byte <parameter>byte</parameter> to the byte offset
                <parameter>nOffset</parameter>
                of the module.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>pokew</methodname>
                <methodparam><type>UShort_t</type> <parameter>word</parameter></methodparam>
                <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
            </methodsynopsis>
            <para>
                Writes the 16 bit word <parameter>word</parameter> to the word offset
                <parameter>nOffset</parameter>
                in the module.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>pokel</methodname>
                <methodparam><type>ULong_t</type> <parameter>lword</parameter></methodparam>
                <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
            </methodsynopsis>
            <para>
                Writes the 32 bit longword <parameter>lword</parameter> to the longword offset
                <parameter>nOffset</parameter>
                in the module.
            </para>
            <methodsynopsis>
                <type>UInt_t</type> <methodname>readl</methodname>
                <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                <methodparam><type>size_t</type> <parameter>longs</parameter></methodparam>
            </methodsynopsis>
            <para>
                Reads a block of longwords from the modules.  The longwords are read starting
                at the longword offset <parameter>nOffset</parameter>
                <parameter>longs</parameter> 32 bit longwords are read.  The interface may
                engage a block transfer engine if appropriate or if available.
                The longwords reads are transferred to successiver longwords pointed to by
                <parameter>pBuffer</parameter>.
                <parameter>pBuffer</parameter> must point to a block of storage that is at
                least <parameter>longs</parameter> 32 bit longwords long.
            </para>
            <methodsynopsis>
                <type>UInt_t</type> <methodname>readw</methodname>
                <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                <methodparam><type>size_t</type> <parameter>words</parameter></methodparam>
            </methodsynopsis>
            <para>
                Reads a block of 16 bit words from the interface.  The words are read starting
                at word offset <parameter>nOffset</parameter>.
                <parameter>words</parameter> consecutive 16 bit words are read into the buffer
                pointed to by <parameter>pBuffer</parameter>.
                <parameter>pBuffer</parameter> must point to a writable block of storage that
                is at least <parameter>words</parameter> 16 bit words long.
            </para>
            <methodsynopsis>
                <type>UInt_t</type> <methodname>readb</methodname>
                <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                <methodparam><type>UInt_t</type> <parameter>nOffset</parameter></methodparam>
                <methodparam><type>size_t</type> <parameter>bytes</parameter></methodparam>
            </methodsynopsis>
            <para>
                Reads a block of 8 bit bytes from the module.  The bytes are read from consucutive
                locations starting at <parameter>nOffset</parameter> bytes from the base of the module.
                <parameter>bytes</parameter> 8 bit bytes are read into the buffer pointed to by
                <parameter>pBuffer</parameter>.
                <parameter>pBuffer</parameter> must point to a block of writable storage that is at least
                <parameter>bytes</parameter> 8 bit bytes long.
            </para>
        </refsect1>
        <refsect1>
            <title>Types and public data</title>
            <para>
                The VME address modifier for the module is determined by a data type called
                <type>CVmeModule::Space</type>.  <type>CVmeModule::Space</type> is an enumerated type that describes the
                address space characteristics of the VME address space inhabited by the module.
                While <type>CVmeModule::Space</type> values specify both the address and data width, in fact only
                the address width is important.  <type>CVmeModule::Space</type> values can be one of the following:
                <variablelist>
                    <varlistentry>
                        <term><literal>CVmeModule::a16d16</literal></term>
                        <listitem>
                           <para>
                                Selects the VME Short IO address space. Short IO addresses are 16 bits
                                wide.  In addtion, the module is free to only decode the top 8 bits of the
                                address as a board select.  Short IO space is intended for simple program
                                control I/O devices.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>CVmeModule::a24d16, CVmeModule::a24d32</literal></term>
                        <listitem>
                           <para>
                                Selects the VME standard address space.  Standard addresses are 24 bits
                                wide.  In the original backplane specification, the VME bus had 24 address
                                and 16 data bits.  There are no longer any backplanes of this sort in use
                                (at least not at the NSCL).  The current backplanes support 32 address lines
                                and 32 data lines (VME64 a related standard expands this to 64 bits of
                                address and data).
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>CVmeModule::a32d32</literal></term>
                        <listitem>
                           <para>
                                Selects the VME extended address space.  Extended addresses are
                                32 bits wide.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>geo</literal></term>
                        <listitem>
                           <para>
                                Selects VME geographical addressing per the CERN backplane extensions.
                                CERN Backplane extensions for the VME bus provide the ability to
                                address a module by slot.  This requires a an additional backplane
                                connected (p3) in between the two standard connectors, and modules
                                that are capable of reading the geographical address space.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </refsect1>
        
    </refentry>
    <refentry id="CSIS3300">
        
        <refmeta>
            <refentrytitle>CSIS3300</refentrytitle>
            <manvolnum>3DeviceSupport</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CSIS3300</refname>
            <refpurpose>Low Level support for the SIS 3300 Flash ADC module</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;sis3300.h&gt;
            </programlisting>
            <classsynopsis language="c++">
                <ooclass><classname>CSIS3300</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CSIS3300</methodname>
                    <methodparam><type>unsigned long</type> <parameter>nBaseAddress</parameter></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>nCrate</parameter><initializer>0</initializer></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Reset</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetClock</methodname>
                    <methodparam><type>CSIS3300::ClockSource</type> <parameter>eSource</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetStartDelay</methodname>
                    <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>false</initializer></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>nClocks</parameter><initializer>0</initializer></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetStopDelay</methodname>
                    <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>false</initializer></methodparam>
                    <methodparam><type>unsigned int</type> <parameter>nClocks</parameter><initializer>0</initializer></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>GateMode</methodname>
                    <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>false</initializer></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>RandomClock</methodname>
                    <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>false</initializer></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>LemoStartStop</methodname>
                    <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>false</initializer></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>P2StartStop</methodname>
                    <methodparam><type>bool</type>   <parameter>Enable</parameter><initializer>false</initializer></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>HiRA_RCM</methodname>
                    <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>false</initializer></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>TriggerOnStop</methodname>
                    <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>true</initializer></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetSampleSize</methodname>
                    <methodparam><type>SampleSize</type> <parameter>eSamples</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>EnableWrap</methodname>
                    <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>true</initializer></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>GetUserInput</methodname>
                                              <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>SetThresholds</methodname>
                    <methodparam><type>bool*</type> <parameter>pLessThan</parameter></methodparam>
		    <methodparam><type>unsigned int*</type> <parameter>pValues</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>enum CSIS3300::ClockSource</type>  <methodname>getCurrentClockSource</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isStartDelayEnabled</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>getStartDelayClocks</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isStopDelayEnabled</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>getStopDelayClocks</methodname>
                                              <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>getThresholdValue</methodname>
                    <methodparam><type>unsigned int</type> <parameter>channel</parameter></methodparam>
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>isLtThreshold</methodname>
                    <methodparam><type>unsigned int</type> <parameter>channel</parameter></methodparam>
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>haveHiRAFirmware</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>LightOn</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>LightOff</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>InitDaq</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Arm1</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>Arm2</methodname>
                    <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>DisArm1</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>DisArm2</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>StartSampling</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>StopSampling</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>EnableUserOut</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>DisableUserOut</methodname>
                                      <void />
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>StrobeUserOut</methodname>
                    <methodparam><type>int</type> <parameter>time</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>bool</type> <methodname>WaitUntilDone</methodname>
                    <methodparam><type>int</type> <parameter>timeout</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned long</type> <methodname>EventNumber</methodname>
                    <methodparam><type>int</type> <parameter>bank</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>ReadGroup1</methodname>
                    <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>ReadGroup2</methodname>
                    <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>ReadGroup3</methodname>
                    <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>ReadGroup4</methodname>
                    <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>ReadAllGroups</methodname>
                    <methodparam><type>void *</type> <parameter>pBuffer</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>ReadGroup1</methodname>
                    <methodparam><type>DAQWordBufferPtr&amp;</type> <parameter>pBuffer</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>ReadGroup2</methodname>
                    <methodparam><type>DAQWordBufferPtr&amp;</type> <parameter>pBuffer</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>ReadGroup3</methodname>
                    <methodparam><type>DAQWordBufferPtr&amp;</type> <parameter>pBuffer</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>ReadGroup4</methodname>
                    <methodparam><type>DAQWordBufferPtr&amp;</type> <parameter>pBuffer</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>unsigned int</type> <methodname>ReadAllGroups</methodname>
                    <methodparam><type>DAQWordBufferPtr&amp;</type> <parameter>pBuffer</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <type>void</type> <methodname>ClearDaq</methodname>
                                      <void />
                </methodsynopsis>
            </classsynopsis>

        </refsynopsisdiv>       
        <refsect1>
            <title>Description</title>
            <para>
                The SIS 3300 is an 8 channel flash adc module.  Sophisticated clock source
                specification and trigger selection make this a very flexible module for digitizing
                wave forms.  Modifications to the base firmware also make this a useful module
                for reading out multiplexed signals into a single high density module.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <methodsynopsis>
                <methodname>CSIS3300</methodname>
                <methodparam><type>unsigned long</type> <parameter>nBaseAddress</parameter></methodparam>
                <methodparam><type>unsigned int</type> <parameter>nCrate</parameter><initializer>0</initializer></methodparam>
            </methodsynopsis>
            <para>
                Constructs an object that can be used to control and read an SIS 3300 flash ADC module.
                <parameter>nBaseAddress</parameter>
                is the module base address set in the module rotary switches while
                <parameter>nCrate</parameter> is the VME crate number the module has been installed in.
                If omitted,
                <parameter>nCrate</parameter> is zero which is suitable for use in single crate systems.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>Reset</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Does a software reset of the module.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>SetClock</methodname>
                <methodparam><type>CSIS3300::ClockSource</type> <parameter>eSource</parameter></methodparam>
            </methodsynopsis>
            <para>
                Selects the clock source for the flash ADC. See "Types and Public data" below for information
                about the possible values of the <type>CSIS3300::ClockSource</type> data type.
            </para>  
            <methodsynopsis>
                <type>void</type> <methodname>SetStartDelay</methodname>
                <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>false</initializer></methodparam>
                <methodparam><type>unsigned int</type> <parameter>nClocks</parameter><initializer>0</initializer></methodparam>
            </methodsynopsis>
            <para>
                Enables or disables the start delay according to the value of <parameter>Enable</parameter>
                if <parameter>Enable</parameter> is <literal>true</literal> <parameter>nClocks</parameter>
                sets the value of that delay in clock ticks.  The start delay is the time between the
                start command or pulse and when the digitizer accepts its first sample.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>SetStopDelay</methodname>
                <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>false</initializer></methodparam>
                <methodparam><type>unsigned int</type> <parameter>nClocks</parameter><initializer>0</initializer></methodparam>
            </methodsynopsis>
            <para>
                Enables or disables the stop delay in a manner similar to <function>SetStartDelay</function>.
                If <parameter>Enable</parameter> is <literal>true</literal> then <parameter>nClocks</parameter>
                is the delay in clock ticks between the stop signal or command and when the last digitizer
                sample is accepted.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>GateMode</methodname>
                <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>false</initializer></methodparam>
            </methodsynopsis>
            <para>
                Enables or disables the module to operate in <firstterm>Gate mode</firstterm>.
                In gate mode the digitization interval is determined by the width of the
                start input.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>RandomClock</methodname>
                <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>false</initializer></methodparam>
            </methodsynopsis>
            <para>
                Selects random clock mode if <parameter>Enable</parameter> is true.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>LemoStartStop</methodname>
                <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>false</initializer></methodparam>
            </methodsynopsis>
            <para>
                Enables the front panel start and stop inputs.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>P2StartStop</methodname>
                <methodparam><type>bool</type>   <parameter>Enable</parameter><initializer>false</initializer></methodparam>
            </methodsynopsis>
            <para>
                Enable digitization start and stop to come from uncommitted backplane pins on the
                P2 connector.  See the module's hardware manual for information about which pin is which.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>HiRA_RCM</methodname>
                <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>false</initializer></methodparam>
            </methodsynopsis>
            <para>
                Enables HiRA Random Clock Mode.  HiRA random clock mode is part of the normal firmware
                now.  In random clock mode, the clock is a front panel input.  It can come at any frequency
                as long as it meets specific duty factor requirements.    In HiRA Random Clock mode,
                the duty factory is unconstrained. as well.
            </para>  
            <methodsynopsis>
                <type>void</type> <methodname>TriggerOnStop</methodname>
                <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>true</initializer></methodparam>
            </methodsynopsis>
            <para>
                Sets the module to emit a trigger pulse when digitization is stopped if
                <parameter>Enable</parameter> is <literal>true</literal>.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>SetSampleSize</methodname>
                <methodparam><type>SampleSize</type> <parameter>eSamples</parameter></methodparam>
            </methodsynopsis>
            <para>
                Sets the number of samples in an event. The possible values of
                <parameter>eSamples</parameter> are described in "Types and public data" below.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>EnableWrap</methodname>
                <methodparam><type>bool</type> <parameter>Enable</parameter><initializer>true</initializer></methodparam>
            </methodsynopsis>
            <para>
                If <parameter>Enable</parameter> is <literal>true</literal> the samples are allowed to
                wrap in the internal buffer during sampling.  Otherwise sampling ends when the end of the
                internal event buffer is reached.
            </para>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>GetUserInput</methodname>
                                          <void />
            </methodsynopsis>
            <para>
                Returns the value of the user NIM input.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>SetThresholds</methodname>
                <methodparam><type>bool*</type> <parameter>pLessThan</parameter></methodparam>
                <methodparam><type>unsigned int*</type> <parameter>pValues</parameter></methodparam>
            </methodsynopsis>
            <para>
                Sets the channel thresholds for the internal trigger.  It is possible for a trigger
                to be fired whenever the voltage input to a channel goes above or below a threshold.
                The trigger is a NIM out which can, in turn, be used as e.g. a start or stop input.
                <parameter>pLessThan</parameter>
                points to an array of 8 bools.  For each bool that is true, that channel's threshold
                means trigger when less than.
                <parameter>pValues</parameter>
                points to an array of 8 integer values that are the thresholds for the individual
                channels.
            </para>
            <methodsynopsis>
                <type>enum CSIS3300::ClockSource</type>  <methodname>getCurrentClockSource</methodname>
                <void />
            </methodsynopsis>
            <para>
                Returns the current clock source.  See "Types and public data" below for legal values
                of the <type>CSIS3300::ClockSource</type> enumerated data type.
            </para>
            <methodsynopsis>
                <type>bool</type> <methodname>isStartDelayEnabled</methodname>
                <void />
            </methodsynopsis>
            <para>
                Returns <literal>true</literal> if the start delay is enabled.
            </para>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>getStartDelayClocks</methodname>
                <void />
            </methodsynopsis>
            <para>
                Returns the current value of the start delay in clock ticks.  This has no meaning
                if the start delay is disabled.
            </para>
            <methodsynopsis>
                <type>bool</type> <methodname>isStopDelayEnabled</methodname>
                <void />
            </methodsynopsis>
            <para>
                Returns <literal>true</literal> if the stop delay is disabled.
            </para>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>getStopDelayClocks</methodname>
                                          <void />
            </methodsynopsis>
            <para>
                Returns the current value of the stop delay in clock ticks.  This has no meaning
                if the stop delay is disabled.
            </para>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>getThresholdValue</methodname>
                <methodparam><type>unsigned int</type> <parameter>channel</parameter></methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns the threshold value for a specified <parameter>channel</parameter>.
            </para>
            <methodsynopsis>
                <type>bool</type> <methodname>isLtThreshold</methodname>
                <methodparam><type>unsigned int</type> <parameter>channel</parameter></methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns <literal>true</literal> if the trigger threshold for channel
                <parameter>channel</parameter> is a "less than" trigger.
            </para>
            <methodsynopsis>
                <type>bool</type> <methodname>haveHiRAFirmware</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns <literal>true</literal> if the module has firmware that supports
                HiRA Random clock mode.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>LightOn</methodname>
                <void />
            </methodsynopsis>
            <para>
                Turns the user led on.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>LightOff</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Turns the user led off.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>InitDaq</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Sets up the module as it was configured by calls to the preceding set of members.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>Arm1</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Arms the module to digitize into the bank 1 memory.  Note that
                at present, we only support bank 1 memory for readout.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>Arm2</methodname>
                <void />
            </methodsynopsis>
            <para>
                Arms the module to digitize into the bank 2 memory.  Note that
                at present, we only support bank 2 memory for the readout. It is
                possible, however, if you know enough about the module internals to
                either derive a class from this that supports both banks or
                build code around this class than supports both banks.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>DisArm1</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Disarms sampling into bank 1.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>DisArm2</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Disarms sampling into bank 2.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>StartSampling</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Starts the module sampling.  If there is a start delay programmed, this will delay
                the actual time of the first sample.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>StopSampling</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Stops sampling.  If a stop delay has been programmed, this will delay the actual
                time of the last sample.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>EnableUserOut</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Enables the user NIM output.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>DisableUserOut</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Disable the user NIM output.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>StrobeUserOut</methodname>
                <methodparam><type>int</type> <parameter>time</parameter></methodparam>
            </methodsynopsis>
            <para>
                Pulses the user NIM output
            </para>
            <methodsynopsis>
                <type>bool</type> <methodname>WaitUntilDone</methodname>
                <methodparam><type>int</type> <parameter>timeout</parameter></methodparam>
            </methodsynopsis>
            <para>
                Pauses until digitization stops.  The <parameter>timeout</parameter> parameter is
                the number of loop passes for which the system will wait. <literal>true</literal>
                is returned if the timeout is exceeded without sampling stopping. The assumption in this
                function is that at least one sample will occur for each loop pass.
                If sampling is halted the module will also have both banks disarmed.
            </para>
            <methodsynopsis>
                <type>unsigned long</type> <methodname>EventNumber</methodname>
                <methodparam><type>int</type> <parameter>bank</parameter></methodparam>
            </methodsynopsis>
            <para>
                Returns the last event number acquired by the specified <parameter>bank</parameter>.
            </para>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>ReadGroup1</methodname>
                <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
            </methodsynopsis>
            <para>
                Reads data from the most recent event in the first group of adcs (channel 0/1).
                The group data are read into the buffer pointed to by <parameter>pBuffer</parameter>.
                The buffer must be large enough to accept the full sample count programmed into the ADC.
                See <function>SetSampleSize</function> for more information.
            </para>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>ReadGroup2</methodname>
                <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
            </methodsynopsis>
            <para>
                Same as <function>ReadGroup1</function> however the data from the second group
                of channels (channels 2/3) are read.
            </para>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>ReadGroup3</methodname>
                <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
            </methodsynopsis>
           <para>
                Same as <function>ReadGroup1</function> however the data from the third group
                of channels (channels 4 and 5) are read.
            </para>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>ReadGroup4</methodname>
                <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
            </methodsynopsis>
           <para>
                Same as <function>ReadGroup1</function> however the data from the fourth group
                of channels (channels 6/7) are read.
            </para>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>ReadAllGroups</methodname>
                <methodparam><type>void *</type> <parameter>pBuffer</parameter></methodparam>
            </methodsynopsis>
            <para>
                This is equivalent to doing reads on all groups .
            </para>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>ReadGroup1</methodname>
                <methodparam><type>DAQWordBufferPtr&amp;</type> <parameter>pBuffer</parameter></methodparam>
            </methodsynopsis>
            <para>
                Reads the most recent event from the first pair of adcs directly into a spectrodaq buffer.  
            </para>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>ReadGroup2</methodname>
                <methodparam><type>DAQWordBufferPtr&amp;</type> <parameter>pBuffer</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>ReadGroup3</methodname>
                <methodparam><type>DAQWordBufferPtr&amp;</type> <parameter>pBuffer</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>ReadGroup4</methodname>
                <methodparam><type>DAQWordBufferPtr&amp;</type> <parameter>pBuffer</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>ReadAllGroups</methodname>
                <methodparam><type>DAQWordBufferPtr&amp;</type> <parameter>pBuffer</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>ClearDaq</methodname>
                                  <void />
            </methodsynopsis>
            <para>
            </para>
        </refsect1>
        <refsect1>
            <title>Types and public data</title>
            <para>
                The <type>CSIS3300::ClockSource</type> data type is an enumerated data type that
                specifies the source of the ADC sampling clock.  Legal values of this type are:
                <variablelist>
                    <varlistentry>
                        <term><literal>CSIS3300::Internal100Mhz</literal></term>
                        <listitem>
                           <para>
                                Selects the internal 100Mhz clock.  Note that since the original
                                module was released, modules with different clock options have been
                                released.  It's not possible to deterimine programmatically which modules
                                are which.  This option sets the value 0 in the clock selection field.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>CSIS3300::Internal50Mhz</literal></term>
                        <listitem>
                           <para>
                               Selects the internal 50Mhz clock.  Note that since the original
                                module was released, modules with different clock options have been
                                released.  It's not possible to deterimine programmatically which modules
                                are which.  This option sets the value 1 in the clock selection field.

                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>CSIS3300::Internal25Mhz</literal></term>
                        <listitem>
                           <para>
                              Selects the internal 25Mhz clock.  Note that since the original
                                module was released, modules with different clock options have been
                                released.  It's not possible to deterimine programmatically which modules
                                are which.  This option sets the value 2 in the clock selection field.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>CSIS3300::Internal12_5Mhz</literal></term>
                        <listitem>
                           <para>
                                Selects the internal 12.5Mhz clock.  Note that since the original
                                module was released, modules with different clock options have been
                                released.  It's not possible to deterimine programmatically which modules
                                are which.  This option sets the value 3 in the clock selection field.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>CSIS3300::Internal6_25Mhz</literal></term>
                        <listitem>
                            <para>
                                Selects the internal 6.25Mhz clock.  Note that since the original
                                module was released, modules with different clock options have been
                                released.  It's not possible to deterimine programmatically which modules
                                are which.  This option sets the value 4 in the clock selection field.
                            </para>
                         </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>CSIS3300::Internal3_125Mhz</literal></term>
                        <listitem>
                           <para>
                                Selects the internal 3.125Mhz clock.  Note that since the original
                                module was released, modules with different clock options have been
                                released.  It's not possible to deterimine programmatically which modules
                                are which.  This option sets the value 5 in the clock selection field.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>ExternalFp</literal></term>
                        <listitem>
                           <para>
                                Selects the clock from the externa front panel clock input.
                                This must be selected for random clock modes.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>ExternalP2</literal></term>
                        <listitem>
                           <para>
                            Selects the clock from the P2 connector.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
            <para>
                The <type>CSIS3300::SampleSize</type> data type is an enumerated type that is used
                to set or read the number of samples in an event buffer.  It can take the following values:
                <variablelist>
                    <varlistentry>
                        <term><literal>Sample128K</literal></term>
                        <listitem>
                           <para>
                                Sets the sample size to 128K samples.  Note that a K is 1024.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Sample16K</literal></term>
                        <listitem>
                           <para>
                                Sets the sample size to 16K samples.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Sample4K</literal></term>
                        <listitem>
                           <para>
                                Sets the sample size to 4K samples.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Sample2K</literal></term>
                        <listitem>
                           <para>
                            Sets the sample size to 2K samples.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Sample1K</literal></term>
                        <listitem>
                           <para>
                                Sets the sample size to 1K samples.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Sample512</literal></term>
                        <listitem>
                           <para>
                                Sets the sample size to 512 samples.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Sample256</literal></term>
                        <listitem>
                           <para>
                                Sets the sample size to 256 samples.
                           </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>Sample128</literal></term>
                        <listitem>
                           <para>
                            Sets the sample size to 128 samples.
                           </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </refsect1>

        
    </refentry>

<!-- /manpage -->
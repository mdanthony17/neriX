<!-- chapter frameworks -->
<chapter>
    <title>The SBS Readout framework</title>
    <para>
        This chapter describes a framework for reading out events via the SBS
        PCI/VME bus bridge interface.  This chapter describes
        <itemizedlist>
            <listitem>
                <para>Basic concepts that underlie the framework</para>
                </listitem>
            <listitem>
                <para>How to obtain a skeleton application which you can expand
                    into a real application, and build it.</para>
                </listitem>
            <listitem>
                <para>
                    What parts of the skeleton application you will most likely
                    have to modify to produce a real application.
                    </para>
                </listitem>
            </itemizedlist>
        </para>
    <para>
        Complete reference information is available in the 3sbsreadout part of
        this manual.
        </para>
    <section>
        <title>SBS Readout concepts</title>
        <para>
            The SBS readout is an application framework.  Application frameworks
            are nice because they already supply the main flow of control.  Your
            job as an application programmer is to fill in the experiment specific
            pieces of the framework.
            </para>
        <para>
            The disadvantage of an application framework is that it can be hard
            to figure out how to get started without a good orientation.  This
            section aims to be that orientation.  We will describe the flow
            of the application and the concepts you'll have to deal with.
            </para>
        <para>
            Normally you will only need to be concerned with how the framework
            operates when data taking is active.  When data taking is active,
            An independent thread loops checking a pair of
            <firstterm>triggers</firstterm>.  These
            triggers are called the
            <firstterm>event trigger</firstterm> and tthe
            <firstterm>scaler triger</firstterm>.
            Each trigger has associated with it a set of code to execute.
            This code is organized hierarchically as <firstterm>event segments</firstterm>
            in the case of the event trigger and <firstterm>scaler banks</firstterm>
            in the case of the scaler trigger.
            </para>
        <para>
            Triggers and the code that responds to them must be registered with
            the framework if it is to know about it.  The specific triggers
            themselves must also be registered.
            </para>
        <para>
            This section therefore will discuss the following objects:
            <itemizedlist>
                <listitem>
                    <para>
                        Event segments.
                        </para>
                    </listitem>
                <listitem>
                    <para>
                        Scaler banks
                        </para>
                    </listitem>
                <listitem>
                    <para>
                        Triggers
                        </para>
                    </listitem>
                <listitem>
                    <para>
                        Busys
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
        <formalpara>
            <title>Event Segments</title>
            <para>
                An event segment is a logical unit of data acquisitition. There
                are two useful base classes:
                <classname>CEventSegment</classname> provides a primitive segment.
                You extend <classname>CEventSegment</classname> to build a class
                that actually initializes, reads and clears some digitizer modules.
                <classname>CCompoundEventSegment</classname> provides a container
                for other event segments (including other
                <classname>CCompoundEventSegment</classname> objects).
                <classname>CCompoundEventSegment</classname> provides the
                glue that allows you to build an experiment readout from logical
                chunks.
                </para>
            </formalpara>
        <para>
            To use the <classname>CEventSegment</classname> class, you create
            a derived class and implement the pure virtual methods of 
            <classname>CEventSegment</classname>.  You can optionally override
            the virtual methods supplied by <classname>CEvenSegment</classname>
            (which are implemented to do nothing) if your electronics requires this.
            </para>
        <para>
            The virtual methods you can implement are:
            </para>
        <variablelist>
            <varlistentry>
                <term><type>void</type> <methodname>initialize</methodname>()</term>
                <listitem>
                    <para>
                        This method is called once as data taking transitions to
                        the active state (resume or begin).  It is expected to perform
                        any one-time initialization of the hardware managed by this
                        event segment.  This includes returning the module to a known
                        state, reading setup files and applying them to the module,
                        enabling data taking and so on.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>void</type> <methodname>clear</methodname>()</term>
                <listitem>
                    <para>
                        Clears any pending data from the module.  This is called
                        after <methodname>initialize</methodname> during startup.
                        It is also called after each event has been read.
                        You should implement this if the hardware this segment is reading
                        requires any post readout attention to be made ready for
                        the next event.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>void</type> <methodname>disable</methodname>() </term>
                <listitem>
                    <para>
                        Called as data taking is being transitioned to an inactive
                        state (paused or ended).  This is expected to do any
                        work needed to disable dat taking in the modules managed
                        by this segment.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>size_t</type> <methodname>read</methodname>(
                <type>void*</type> <parameter>pBuffer</parameter>,
                <type>size_t</type> <parameter>maxwords</parameter>)</term>
                <listitem>
                    <para>
                        Called in response to a trigger. This function is expected
                        to read the hardware directly into <parameter>pBuffer</parameter>
                        which has <parameter>maxwords</parameter> of 16 bit words
                        available.  On return, the actual number of 16 bit words read
                        should be returned.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        <para>
            For reference information on this class see:
            <link linkend='manpage.ceventsegment'>CEventSegment(3sbsreadout)</link>.
            Closely allied with this is the concept of packets.  Packets are supported
            via the <link linkend='manpage.cdocumentedpacket'>CDocumentedPacket(3sbsreadout)</link>.
            The <link linkend='manpage.ceventpacket'>CEventPacket(3sbsreadout)</link>
            class extends  <classname>CEventSegment</classname> to provide a base
            class for event segments that are wrapped in a packet.
            </para>
        <para>
            Event segments are organized by placing them in <classname>CCompoundEventSegment</classname>
            objects. <classname>CCompoundEventSegment</classname> is itself an
            <classname>CEventSegment</classname> and therefore can contain other
            compounds, which supports a hierarchical organization of the
            experimental readout.
            </para>
        <para>
            Ordinarily you will use a <classname>CCompoundEventSegment</classname>
            by creating an instance of it and inserting other segments into it.
            Here are the methods that allow you to manipulate the event segments
            in a compound event segment.
            </para>
        <variablelist>
            <varlistentry>
                <term><type>void</type> <methodname>AddEventSegment</methodname>(
                <type>CEventSegment*</type> <parameter>pSegment</parameter>
                )</term>
                <listitem>
                    <para>
                        Adds an event segment to the end of the ordered collection
                        of event segments in the list.  Whenever a method like
                        <methodname>initialize</methodname> or<methodname>read</methodname>
                        is invoked on a compound event segment it will invoke the
                        corresponding method in the elements it contains in
                        the order in which they were added.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>void</type> <methodname>DeleteEventSegment</methodname>
                (
                    <type>CEventSegment*</type> <parameter>pSegment</parameter>
                )</term>
                <listitem>
                    <para>
                        If <parameter>pSegment</parameter> is contained by
                        the compound, it will be removed from the container.
                        If not this method does nothing.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>CCompoundEventSegment::EventSegmentIterator</type>
                <methodname>begin</methodname>()</term>
                <listitem>
                    <para>
                        Returns an iterator which 'points' to the beginning of the
                        collection.  Refer to the description below for information
                        about iterators.  
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>CCompoundEventSegment::EventSegmentIterator</type>
                <methodname>end</methodname>()</term>
                <listitem>
                    <para>
                        Returns an iterator that points just off the end of
                        the collection.  A typical usage pattern is shown below
                        <informalexample>
                            <programlisting>
CCompoundEventSegment seg;
...
CCompoundEventSegment::EventIterator p = seg.begin();
while (p != seg.end()) {
   // Do something with the event segment pointed to by *p
   
   p++;
}
                                </programlisting>
                            </informalexample>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        <para>
            The <type>CCompoundEventSegment::EventSegmentIterator</type>
            data typeis a pointer like object within the collection of
            event segments.  Dereferencing it gives you a pointer to the
            event segmet at the current location. Increment advances the
            iterator to the next element of the collection.
            </para>
        <para>
            For reference information about the <classname>CCompoundEventSegment</classname>
            class see
            <link linkend='manpage.ccompoundeventsegment'>CCompoundEventSegment(3sbsreadout)</link>.
            </para>
        <para>
            The readout software has a single object from the
            <link linkend='manpage.cexperiment'>CExperiment(3sbsreadout)</link>
            class.   This object contains a top level <classname>CCompoundEventSegment</classname>.
            It also provides a member function <methodname>AddEventSegment</methodname> that
            allows you to add an event segment (or compound event segment) to
            that top level segment.
            </para>
        <para>
            See the section:
            <link linkend='sbsrdo.sec.skeleton'>Modifying the skeleton application to meet your needs</link>
            for information about where to add event segments.
            </para>
        <formalpara>
            <title>Scaler banks</title>
            <para>
                The Readout program supports a second trigger that reads out scaler
                banks.  Scaler banks usually read out a set of counters that
                describe the rates in various detectors subsystems and other
                items of interest.   Scaler banks operate in a manner analagous
                to the event segments we have just described.
                </para>
            
            </formalpara>
        <para>
            The <classname>CScaler</classname> class is intended to read a single
            scaler module.  <classname>CScalerBank</classname> is a container for
            other <classname>CScaler</classname> objects including other
            <classname>CScalerBank</classname> objects.  This pair of classes
            allows you to build a modular hierarchy of scalers to read in
            response to the scaler trigger.  The scaler trigger is assumed
            to come at a much lower rate than the event trigger and therefore can
            tolerate alonger deadtime.
            </para>
        <para>
            <classname>CScaler</classname> is an abstract base class.  You use
            it by extending it by supplying code for the pure virtual methods,
            and overriding the other virtual methods you need to override.
            The virtual methods that are fair game to be overidden are:
            </para>
        <variablelist>
            <varlistentry>
                <term><type>void</type> <methodname>initialize</methodname>()</term>
                <listitem>
                    <para>
                        Invoked once as the readout program begins taking data.
                        This happens after a begin and after a resume.
                        The code you supply here is supposed to prepare modules
                        for data taking.  The base class implementation does nothing
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>void</type> <methodname>clear</methodname>()</term>
                <listitem>
                    <para>
                        Invoked once as data taking becomes active (begin or resume),
                        and after the scaler is read.  If something must be done
                        to clear  a scaler after it has been read write this method
                        and put that code here.  Note that many scalers have a destructive
                        read method and that should be used by preference as it ensures
                        that scaler counts will not be lost (those accepted between
                        read and clear).
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>void</type> <methodname>disable</methodname>()</term>
                <listitem>
                    <para>
                        Called as data taking is halted (due to an end or pause).
                        If a module requires special handling to disable it
                        implement this method.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>std::vector&lt;uint32_t&gt;</type>
                <methodname>read</methodname>
                </term>
                <listitem>
                    <para>
                        Reads the scaler(s) managed by this class.  The
                        scalers are returned as an STL vector of 32 bit
                        unsigned values.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        <para>
            The <classname>CScalerBank</classname> class is a parallel to the
            <classname>CCompoundEventSegment</classname>.  It is a
            <classname>CScaler</classname> that contains other
            <classname>CScaler</classname> objects, including
            <classname>CCompoundEventSegment</classname> objects.
            </para>
        <para>
            The following methods allow you to manipulate the container
            in a <classname>CScalerBank</classname> object:
            </para>
        <variablelist>
            <varlistentry>
                <term><type>void</type> <methodname>AddScalerModule</methodname>(
                    <type>CScaler*</type> <parameter>pScaler</parameter>
                )
                </term>
                <listitem>
                    <para>
                        Adds a scaler module to the end of the ordered container
                        of scaler modules that is managed by this object. The
                        virtual functions that make this module look like a
                        <classname>CScaler</classname> iterate through the
                        set of scaler objects in the container in the order in
                        which they were added and invoke the corresponding
                        function in those objects.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>void</type> <methodname>DeleteScaler</methodname>(
                <type>CScaler*</type> <parameter>pScaler</parameter>
                )
                </term>
                <listitem>
                    <para>
                        If the scaler pointed to by <parameter>pScaler</parameter>
                        is in the container (shallow inclusion), it is removed
                        from the container.  Note that the object is not destroyed.
                        IF <parameter>pScaler</parameter> is not in the collection
                        this function does nothing.
                        </para>  
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>CScalerBank::ScalerIterator</type>
                <methodname>begin</methodname>()</term>
                <listitem>
                    <para>
                        Returns an iterator that 'points' to the first item in
                        the container.  Dereferencing a
                        <type>CScalerBank::ScalerIterator</type> will
                        result in a <type>CScaler*</type>.  Incrementing the
                        iterator will make it 'point' to the next object in the
                        container.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>CScalerBank::ScalerIterator</type>
                <methodname>end</methodname>()</term>
                <listitem>
                    <para>
                        Returns an iterator that points just off the end of the
                        collection.  A typical use for this is:
                        <informalexample>
                            <programlisting>
CScalerBank bank;
...
CScalerBank::ScalerIterator p = bank.begin();
while (p != bank.end()) {
    CScaler* pScaler = *p;
    
    // do something with the scaler.
    
    p++;            // Next scaler.
}
                                </programlisting>
                            </informalexample>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        <para>
            For reference information see
            <link linkend='manpage.cscalerbank'>CScalerBank</link>
            </para>
        <para>
            As with event segments, the <classname>CExperiment</classname>
            encapsulate as <classname>ScalerBank</classname> that is the
            top level of the scaler readout hierarchy.
            <classname>CExperiment</classname> exports methods that
            allow you to add and remove scaler modules (including scaler banks)
            to this top level scaler bank.  See
            <link linkend='sbsrdo.sec.skeleton'>Modifying the skeleton application to meet your needs</link>
            for iformation about how to use these.
            </para>
        <formalpara>
            <title>Triggers</title>
            <para>
                We have seen how to build the list of stuff the readout program
                will read.  <firstterm>Triggers</firstterm> determine when the
                top level event segment and scaler bank are read.  In order to
                make Readout to do anything with these you must supply appropriate
                trigger objects and register them with the <classname>CExperiment</classname>
                object.  This registration is described in
                <link linkend='sbsrdo.sec.skeleton'>"Modifying the skeleton application to meet your needs"</link>
                below.
                </para>
            </formalpara>
        <para>
            All triggers are subclasses of <classname>CEventTrigger</classname>.
            Several of the commonly used triggers have been defined for you.  You
            can also build custom triggers by extending <classname>CEventTrigger</classname>
            or any of the prebuilt classes that are close to what you want.
            </para>
        <para>
            You write a trigger class by overriding the virtual methods in
            <classname>CEventTrigger</classname> supplying code that is
            appropriate to your needs.  You must define and implement
            <methodname>operator()</methodname> which is a pure virtual
            method of <classname>CEventTrigger</classname>.
            </para>
        <para>
            The virtual member functions in the <classname>CEventTrigger</classname>
            class are:
            </para>
        <variablelist>
            <varlistentry>
                <term><type>void</type> <methodname>setup</methodname>()</term>
                <listitem>
                    <para>
                        Called when data taking becomes active (begin or resume).
                        This should perform any initialization of the trigger
                        hardware or software.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>void</type> <methodname>teardown</methodname>()</term>
                <listitem>
                    <para>
                        Called as data taking halts (end or pause).  Any code
                        required to make the trigger hardware or software
                        insenstive to additional triggers should be supplied here.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>bool</type> <methodname>operator()</methodname>()</term>
                <listitem>
                    <para>
                        This is periodically called and should return
                        <literal>true</literal> if the trigger actions should
                        be peformed.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        <para>
            The following trigger classes are in the Readout library and can be
            used simplly by instantiatig and registering them.
            </para>
        <variablelist>
            <varlistentry>
                <term><classname>CCAENV262Trigger</classname></term>
                <listitem>
                    <para>
                        Triggers using the CAEN V262 module.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><classname>CNullTrigger</classname></term>
                <listitem>
                    <para>
                        Trigger that never fires.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><classname>CTimedTrigger</classname></term>
                <listitem>
                    <para>
                        Trigger that fires periodically
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><classname>CV977Trigger</classname></term>
                <listitem>
                    <para>
                        Trigger that uses the CAEN V977 module.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        <formalpara>
            <title>Busys</title>
            <para>
                During the time in which Readout is responding to a trigger it
                is unable to accept a new trigger.  During this time it is often
                important to veto external electronics until the system is able to
                accept the next trigger.  This is the function of <firstterm>Busy</firstterm>
                objects.
                </para>
            </formalpara>
        <para>
            Busy objects are members of classes that are derived from
            <classname>CBusy</classname> which has the following pure virtual
            members:
            </para>
        <variablelist>
            <varlistentry>
                <term><type>void</type> <methodname>GoBusy</methodname></term>
                <listitem>
                    <para>
                    This is called when due to software reasons the computer will
                    be unable to accept a trigger.  For example, as the run ends.
                    It is important to note that the actual event by event busy should
                    be generated by hardware and then only cleared by software.
                    </para>
                    </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>void</type> <methodname>GoClear</methodname></term>
                <listitem>
                    <para>
                        Called when the software is able to accept the next
                        trigger.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        <para>
            The readout framework provides
            <link linkend='manpage.ccaenv262busy'><classname>CCAENV262Busy</classname></link>,
            and
            <link linkend='manpage.cv977busy'><classname>CV977Busy</classname></link> as
            prebuilt busy classes.  This, and any busy class you create must be
            registered to be used.  The example below shows the creation and
            registration of a <classname>CV977Busy</classname> object to
            manage the busy.  The physicsal module is in VME crate 0 and has a base
            address of 0x00444400.
            </para>
        <informalexample>
            <programlisting>
#include &lt;CV977Busy.h&gt;
...
void
Skeleton::SetupReadout(CExperiment* pExperiment)
{
   ...
   pExperiment-&gt;EstablishBusy(new CV977Busy(0x444400));
   ...
}
                </programlisting>
            </informalexample>
        </section>
    <section>
        <title>Obtaining and building the skeleton application</title>
        <para>
            The readout framework provides a skeleton application that you
            can extend to a create a real readout application.
            This section provides best practice methods to obtain the skeleton
            and build it.
            </para>
        <para>
            Framework skeletons are all installed in the <filename>skeletons</filename>
            directory of the NSCLDAQ installation tree.  The following example shows
            how we recommend obtaining this skeleton and how to perform a test build
            of the skeleton. 
            </para>
        <example>
            <title>Obtaining the SBS readout skeleton</title>
            <programlisting>
cd ~
mkdir -p experiment/readout
cd experiment/readout
cp $DAQROOT/skeletons/sbs/* .

make

                </programlisting>
            </example>
        <para>
            The example creates the directory 
	    <filename>~/experiment/readout</filename>.
            Next the skeleton files are copied to that directory.
            <command>make</command> is used to do a test build of the skeleton.            
            </para>
        <note>
            <title>NOTE!</title>
            <para>
                By itself the skeleton cannot take any useful data.  You must
                modify it to meet you readout needs, and build the modified
                version.  See
                <link linkend='sbsrdo.sec.skeleton'>"Modify8ing the skeleton application to meet your needs</link>,
                the next section for information about how to do this.
                </para>
            </note>
        </section>
    <section id='sbsrdo.sec.skeleton'>
        <title>Modifying the skeleton application to meet your needs</title>
        <para>
            The skeleton provides several member functions that are called
            in a specific order.  You should fill some or all of these member
            function in with actual code to set up the framwork to do what
            you want it to do.
            </para>
        <para>
            If you add additional source files, you should modify the
            <filename>Makefile</filename> as well so that they are incorporated
            into the build.  The simplest way to do this is to add them to the
            definition of the <literal>OBJECTS</literal>macro in the
            <filename>Makefile</filename>.
            </para>
        <para>
            Let's look at the member functions in <filename>Skeleton.cpp</filename>
            that you may have to fill in.  These are listed in order of likelyhood
            you'll need or want to add code to them.  Note that all of these members
            invoke the base class member functions they override. This ensures that
            important functionality provided by those members is provided.
            </para>
        <variablelist>
            <varlistentry>
                <term><type>void</type> <methodname>SetupReadout</methodname>(
                    <type>CExperiment*</type> <parameter>pExperiment</parameter>
                )</term>
                <listitem>
                    <para>
                        Fill in code here to setup the event by event reaout
                        part of the framework.  Specific work you must do is:
                        <itemizedlist>
                            <listitem>
                                <para>
                                    Create and register an event trigger.
                                    </para>
                                </listitem>
                            <listitem>
                                <para>
                                    Create event segments and glue them together
                                    into a coherent event segment hierarchy.
                                    </para>
                                </listitem>
                            <listitem>
                                <para>
                                    Register the top end event segment hierarchy
                                    elements in the experiment's top level event
                                    segment so that they will be invoked
                                    at appropriate times.
                                    </para>
                                </listitem>
                            </itemizedlist>
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>void</type> <methodname>SetupScalers</methodname> (
                    <type>CExperiment*</type> <parameter>pExperiment</parameter>
                )</term>
                <listitem>
                    <para>
                        Fill in code here to set up the scaler readout.
                        This involves:
                        </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                Create and register a scaler trigger.  The
                                Skeleton provides sample code for registering
                                a timed trigger.
                                </para>
                            </listitem>
                        <listitem>
                            <para>
                                Create your scalers and glue them together
                                into a coherent scaler readout hierarchy via
                                scaler banks.
                                </para>
                            </listitem>
                        <listitem>
                            <para>
                                Register the top elements of the scaler readout
                                hierarchy with <parameter>pExperiment</parameter>'s
                                top level scaler bank so that your elements will
                                be invoked at the proper times.
                                </para>
                            </listitem>
                                
                        </itemizedlist>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>void</type> <methodname>addCommands</methodname> (
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                )</term>
                <listitem>
                    <para>
                        If you want to add application specific commands to the
                        framework, add them here.  This is usually done by
                        writing subclasses derived from <classname>CTCLObjectProcessor</classname>,
                        and creating an instance for each of these classes.
                        The comments prior to this method describe what you need
                        to do if you have existing procedural commands you want
                        to register.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>void</type> <methodname>SetupRunVariables</methodname> (
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                )</term>
                <listitem>
                    <para>
                        If you want to setup some pre-existing run variables, but
                        don't want to use a script to do this, you can define
                        them here.  The simplest way to define a runvar is to
                        create the appropriate <command>runvar</command> command
                        string and pass it to <parameter>pInterp</parameter>-&gt;<methodname>Eval</methodname>.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><type>void</type> <methodname>SetupStateVariables</methodname> (
                <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                )</term>
                <listitem>
                    <para>
                        If you want to set up some pre-existing state variables, but
                        don't want to use a script to do this, you can define
                        them here.  The simplest way to define a statevar is to
                        create the appropriate <command>statevar</command> command
                        string and passi to <parameter>pInterp</parameter>-&gt;<methodname>Eval</methodname>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
    
        </section>
    <section id="sbsrdo.sec.commands">
        <title>Readout commands</title>
        <para>
            The SBS Readout framework automatically adds several commands.
            These are described fully in the 1sbsReadout reference pages.
            A brief summary of these commands is given here.
            </para>
        <para>
            A cluster of commands allows you to perform run control operations.
            These are the <command>begin</command>, <command>end</command>,
            <command>pause</command> and <command>resume</command> commands.
            </para>
        <para>
            The <command>begin</command> command also uses two Tcl global
            variables to set the run state.  These are:
            <varname>title</varname> and <varname>run</varname>.
            </para>
        <para>
            In addition the <command>statevar</command> and <command>runvar</command>
            commands are defined.  These allow the creation, listing and deleting
            of Tcl variables that will be logged to the event stream periodically.
            State variables are write-protected from Tcl scripts while the run is
            active.  Run variables can be modified during the active part of the
            run.
            </para>
        <para>
            Thus State variables are intended to log fixed unchanging parameters
            of a run, such as documentation of the target, or beam ion or beam
            species.  Run variables are intended to log things that may change
            over time, such as the temperature of the chamber, beamline magnet
            readings and so on.
            </para>
        </section>
    <section id='sbsrdo.sec.server'>
        <title>Embedded Tcl server</title>
        <para>
            If requested, the readout program will run a Tcl server.  This is
            requested via the <option>--port</option> option when Readout is started.
            If the value of the <option>--port</option> is an integer, that is
            taken to be the port on which the server will listen for connections.
            If the value of <option>--port</option> is <literal>managed</literal>,
            the port manager will be contacted to dynamically allocate a port
            for the <literal>Readout</literal> application.  The server will
            listen on that port.
            </para>
        <para>
            One use of the tcl server is to modify run variables.   For example,
            an external program such as <application>controlpush</application>
            can be run to data on specified EPICS process variables.l
            </para>
        </section>
    <section id='sbsrdo.sec.running'>
        <title>Running a readout application</title>
        <para>
            The readout application recognizes a few command options.
            The full Readout command reference is described in
            <link linkend='manpage.1sbsreadout'>Readout(1sbsReadout)</link>.
            You can get a summary of the options by invoking Readout with
            the <option>--help</option> option.
            </para>
        </section>
    </chapter>
    
    
<!-- /chapter -->

<!-- manpage 3sbsReadout -->

    <refentry id="manpage.cbusy">
      <refmeta>
         <refentrytitle>CBusy</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CBusy</refname>
     <refpurpose>Abstract base class for Busy module management.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CBusy.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CBusy</classname></ooclass>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>GoBusy</methodname>
                <void /><modifier>=0</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>GoClear</methodname>
                <void /><modifier>=0</modifier>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CBusy</classname> is an abstract base class
            for managing busy modules.   When the Readout program accepts a
            trigger, there is a <firstterm>deadtime</firstterm> during which it
            is not able to accept subsequent trigger.  External electronics often
            needs to know when this deadtime is.
         </para>
         <para>
            The normal way to provide a signal showing when the computer is busy
            is to have some electronics module that acts like a latch.  The
            latch is set true by the trigger itself.  Software clears the latch
            when it is able to respond to the next trigger.  
            </para>
        <para>
            Concrete busy classes are created by deriving them from
            <classname>CBusy</classname>.  An instance of one of these concrete
            classes should be created and registered with the
            <link linkend='manpage.cexperiment'>CExperiment</link>
            in <classname>Skeleton</classname>::<methodname>SetupReadout</methodname>
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>GoBusy</methodname>
                <void /><modifier>=0</modifier>
                </methodsynopsis>
            <para>
                Pure virtual function the framework calls when, for software
                reasons, it is about to be unable to respond to triggers for
                some extended period of time.  This will be called when data taking
                is about to stop due to a <command>end</command> or
                <command>pause</command> command.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>GoClear</methodname>
                <void /><modifier>=0</modifier>
                </methodsynopsis>
            <para>
                Pure virtual function the framework calls when it's about to be
                able to respond to triggers.  In addition to calling this
                member after processing each trigger, the framework will invoke
                this at some point just prior to starting data taking as a result
                of a <command>begin</command> or <command>resume</command>
                command.
                </para>
        </refsect1>
   </refentry>


    <refentry id="manpage.ccaenv262busy">
      <refmeta>
         <refentrytitle>CCAENV262Busy</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CCAENV262Busy</refname>
     <refpurpose>Concrete busy class for the CAEN V262 input module.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CCAENV262Busy&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CCAENV262Busy : public CBusy</classname></ooclass>
            <constructorsynopsis>
                <methodname>CCAENV262Busy</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CCAENV262Busy</methodname>
                <methodparam>
                    <type>CCaenIO&amp;</type> <parameter>module</parameter>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CCAENV262Busy</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CCAENV262Busy&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>GoBusy</methodname> <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>GoReady</methodname> <void />
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class uses the CAEN V262 I/O register to provide signals
            needed to implement a computer busy.  When you use this module,
            module outputs have the following meanings:
            <informaltable frame='all'>
                <tgroup cols='2'>
                    <thead>
                        <row>
                            <entry>Output</entry>
                            <entry>Meaning</entry>
                            </row>
                        </thead>
                    <tbody>
                        <row>
                            <entry>SHP0</entry>
                            <entry><para>Computer is about to go busy for a long time</para></entry>
                            </row>
                        <row>
                            <entry>SHP1</entry>
                            <entry><para>
                                Computer is about to go ready.</para></entry>
                            </row>
                        <row>
                            <entry>SHP3</entry>
                            <entry><para>
                                Module clears are output just prior to releasing the
                                 busy.</para></entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
         </para>
         <para>
            Note that <literal>SHP0</literal> is not a hardware signal.  It means
            that the computer is about to be busy due to data taking stopping or
            pausing.  To use this module you must have an external latch or
            gate generator in latch mode.  The latch should start on the OR
            of the master trigger and <literal>SHP0</literal> it should clear
            on <literal>SHP1</literal>.
            </para>
         <para>
            The module clears are a convenience output and need not be used, however
            if you can use them, this is quicker than clearing modules in software.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis><type></type>
                <methodname>CCAENV262Busy</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Construct a busy object.  <parameter>base</parameter> is the
                base address of the V262 module and <parameter>crate</parameter> the
                VME crate in which the module lives.  <parameter>crate</parameter>
                is an optional parameter that defaults to <literal>0</literal>.
                </para>
            <methodsynopsis><type></type>
                <methodname>CCAENV262Busy</methodname>
                <methodparam>
                    <type>CCaenIO&amp;</type> <parameter>module</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Constructs a busy object. <parameter>module</parameter> is a
                refererence to a <classname>CCaenIO</classname> module that
                has already been constructed and will be the busy hardware
                controlled by this object.
                </para>
            <methodsynopsis><type></type>
                <methodname>CCAENV262Busy</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CCAENV262Busy&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Copy constructs a new busy module that is a functional
                equivalent to <parameter>rhs</parameter>.
		</para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>GoBusy</methodname> <void />
                </methodsynopsis>
            <para>
                Called by the framework to indicate the busy should
                be asserted.  This is not called in response to a gate.
                Busy in response to a gate must happen at hardware speeds,
                not software.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>GoReady</methodname> <void />
                </methodsynopsis>
            <para>
                Called by the framework to indicate it is able to react to
                the next trigger.
                </para>
      </refsect1>
      <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Creating and registering a V262 as a busy:</title>
            <programlisting>
#include &lt;CCAENV262Busy.h&gt;
...
void
Skeleton::SetupReadout(CExperiment* pExperiment)
{
   ...
   pExperiment-&gt;EstablishBusy(new CCAENV262(0x444400));
   ...
}
                </programlisting>
            </example>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend="manpage.cbusy">CBusy(3sbsReadout)</link>
        <link linkend="CaenIO">CaenIO(3daq)</link>
        <link linkend='manpage.ccaenv262trigger'>CCAENV262Trigger(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.ccaenv262trigger">
      <refmeta>
         <refentrytitle>CCAENV262Triger</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CCAENV262Triger</refname>
     <refpurpose>Trigger module with CAEN V262</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CCAEANV262Trigger.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CCAENV262Trigger : public CEventTrigger</classname></ooclass>
            <constructorsynopsis>
                <methodname>CCAENV262Trigger</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    <initializer>0</initializer>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CCAENV262Trigger</methodname>
                <methodparam>
                    <type>CCaenIO&amp;</type> <parameter>module</parameter>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CCAENV262Trigger</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CCAENV262Trigger&amp;</type> <parameter>rhs</parameter>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                <methodname>operator()</methodname><void />
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Implements a trigger class based on the hardware of the
            CAEN V262 I/O register.  When used as a triggerm odule, the
            Following signals in the V262 have meaning:
            <informaltable>
                <tgroup cols='2'>
                    <thead>
                        <row>
                            <entry>Signal</entry>
                            <entry>Meaning</entry>
                            </row>
                        </thead>
                    <tbody>
                        <row>
                            <entry>IN0</entry>
                            <entry>Computer Master Gate (live)</entry>
                            </row>
                        <row>
                            <entry>SHP2</entry>
                            <entry><para>
                            Trigger acknowledge.  The V262 does not latch signals
                            IN0 must be held true until SHP2 is signalled.
                            </para>
                            </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
             <methodsynopsis><type></type>
                <methodname>CCAENV262Trigger</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    <initializer>0</initializer>
                    </methodparam>
                </methodsynopsis>
             <para>
                Constructs a <classname>CCAENV262Trigger</classname> object.
                The <parameter>base</parameter> parameter is the base address
                of the CAEN V262 module to be used as a trigger.
                The optional <parameter>crate</parameter> parameter specifies
                which VME crate the module is in. If not supplied,
                <parameter>crate</parameter> defaults to <literal>0</literal>.
                </para>
            <methodsynopsis>
                <methodname>CCAENV262Trigger</methodname>
                <methodparam>
                    <type>CCaenIO&amp;</type> <parameter>module</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Constructs a trigger object from an existing
                <classname>CaenIO</classname> object.
                <parameter>module</parameter> is the object that represents the
                physical module that will be used as the trigger module.
                </para>
            <methodsynopsis>
                <methodname>CCAENV262Trigger</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CCAENV262Trigger&amp;</type> <parameter>rhs</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Copy constructor.  Contructs a trigger object from
                <parameter>rhs</parameter>.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                <methodname>operator()</methodname><void />
                </methodsynopsis>
            <para>
                The trigger poll function.  When the framework is able to accept
                triggers, it will poll this method. A <literal>true</literal>
                return indicates the presence of the trigger.  Note that
                this function will also strobe the SHP2 output when it sees a trigger,
                making this a possibly destructive read of the trigger.
                </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
         </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='CaenIO'>CaenIO(3daq)</link>
        <link linkend='manpage.ccaenv262busy'>CCAENV262Busy(3sbsReadout)</link>
        <link linkend='manpage.ceventtrigger'>CEventTrigger(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>
    
    
    <refentry id="manpage.ccompoundeventsegment">
      <refmeta>
         <refentrytitle>CCompoundEventSegment</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CCompoundEventSegment</refname>
     <refpurpose>Container for other event segments</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CCompoundEventSegment.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CCompoundEventSegement : public CEventSegment</classname></ooclass>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type>  <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>size_t</type>
                <methodname>read</methodname>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                    </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>maxwords</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>AddEventSegment</methodname>
                <methodparam>
                    <type>CEventSegment*</type> <parameter>pSegment</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>DeleteEventSegment</methodname>
                <methodparam>
                    <type>CEventSegment*</type> <parameter>pSegment</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                <methodname>isComposite</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>EventSegmentIterator</type>
                <methodname>begin</methodname> <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>EventSegmentIterator</type>
                <methodname>end</methodname><void />
                </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type>
                <methodname>size</methodname><void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>leafCount</methodname> <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>fullCount</methodname><void />
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>visit</methodname>
                <methodparam>
                    <type>CVisitor&amp;</type> <parameter>visitor</parameter>
                    </methodparam>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CCompoundEventSegemnt</classname> provides an ordered
            container for event segment objects (or rather pointers to event
            segment objects).  Since a <classname>CCompoundEventSegment</classname>
            itself is an event segment you can build an arbitrarily deep hierarchy
            of event segments using this class.
         </para>
         <para>
            A rich set of facilities for navigating the event segment hierarchy
            is provided though normally this hierarchy gets built at program initialization
            time and is fixed throughout the lifetime of the program.  Navigation models
            include iteration and visitation.  See Types and Public Data for
            information about the class scoped data types that support these
            models.
            </para>
        <para>
            Event segments also provide a mechanism to determine if they are
            containers via the <methodname>isComposite</methodname> member function.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type>  <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <para>
                Part of the event segment interface.  Does a deep initialization
                of all events segments in the compound event segment. This is
                done by calling the <methodname>initialize</methodname>
                member on each element in the container.  This implies that
                if an element of the container is itself a compound event
                segment, it's children will be recursively initialized.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <para>
                Part of the event segment interface.  Does a deep clear of all
                event segments.  This is
                done by calling the <methodname>clear</methodname>
                member on each element in the container.  This implies that
                if an element of the container is itself a compound event
                segment, it's children will be recursively cleared.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <para>
                Part of the event segment interface.  Does a deep disable of all
                event segments.  This is
                done by calling the <methodname>disable</methodname>
                member on each element in the container.  This implies that
                if an element of the container is itself a compound event
                segment, it's children will be recursively disabled.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>size_t</type>
                <methodname>read</methodname>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                    </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>maxwords</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Part of the event segment interface.  Does a deep read of all
                event segments.  This is
                done by calling the <methodname>read</methodname>
                member on each element in the container.  This implies that
                if an element of the container is itself a compound event
                segment, it's children will be recursively read.
                </para>
            <para>
                <parameter>pBuffer</parameter> points to the buffer into which
                data should be read.  <parameter>maxwords</parameter> is the
                maximum number of words that can still fit in that buffer.
                The method returns the number of words that were read by this
                segment.
                </para>
            <methodsynopsis>
                <type>void</type> <methodname>AddEventSegment</methodname>
                <methodparam>
                    <type>CEventSegment*</type> <parameter>pSegment</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Adds an event segment <parameter>pSegment</parameter>
                to the end of the ordered container of
                event segments in the compound.  Very bad things will happen if
                <parameter>pSegment</parameter>'s lifetime is not at least that of
                the event segment.
                </para>
            <methodsynopsis>
                <type>void</type> <methodname>DeleteEventSegment</methodname>
                <methodparam>
                    <type>CEventSegment*</type> <parameter>pSegment</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                If <parameter>pSegment</parameter> is one of the immediate
                children of the object, it is removed from the container.
                If not, this is a no-op.  Please note that this is not a deep
                delete.  If <parameter>pSegment</parameter> is actually a child
                of some compound event segment in the container, it will not
                be found and therefore not removed.
                </para>
            <para>
                <parameter>pSegment</parameter> is removed from the container.
                It is up to the calling software, if appropriate, to destroy
                the actual object.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                <methodname>isComposite</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <para>
                This returns true.  The member function <methodname>isComposite</methodname>
                is provided in all event segments.  It is true if the object
                implements the interface of the compound event segment.
                </para>
            <methodsynopsis>
                <type>EventSegmentIterator</type>
                <methodname>begin</methodname> <void />
                </methodsynopsis>
            <para>
                Returns a begin of iteration iterator.  See "Types and Public Data"
                below for more about iterators.  See as well <methodname>end</methodname>
                below for typical usage.  This iterator is a shallow iterator.
                </para>
            <methodsynopsis>
                <type>EventSegmentIterator</type>
                <methodname>end</methodname><void />
                </methodsynopsis>
            <para>
                Returns an iterator that points off the end of the container.
                This can be used to determine when the iterator has visited
                all members of the container.  The function below shows a
                typical usage.
                </para>
            <informalexample>
                <programlisting>
CCompoundEventSegment es;
...
CCompoundEventSegment::EventSegmentIterator p = es.begin();
while (p != es.end()) {
    CEventSegment *pSegment = *p;
    //
    // Do something with pSegment:
    ...
    p++;
}
                    </programlisting>
                </informalexample>
            
            <methodsynopsis>
                <type>size_t</type>
                <methodname>size</methodname><void /><modifier>const</modifier>
                </methodsynopsis>
            <para>
                Returns the number of elements in the event segment container.
                This is a shallow count.
                </para>
            <methodsynopsis>
                <type>size_t</type> <methodname>leafCount</methodname> <void />
                </methodsynopsis>
            <para>
                Returns the number of 'terminal' nodes in the hierarchy.  A
                terminal node is one for which <methodname>isComposite</methodname>
                returns <literal>false</literal>.  This is a deep count.
                </para>
            <methodsynopsis>
                <type>size_t</type> <methodname>fullCount</methodname><void />
                </methodsynopsis>
            <para>
                Returns the total number of nodes in the hiearchy.  This is a deep
                count.
                </para>
            <methodsynopsis>
                <type>void</type> <methodname>visit</methodname>
                <methodparam>
                    <type>CVisitor&amp;</type> <parameter>visitor</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Visits each node in the hieararchy and invokes the visitor
                at each node at this level of the hierarchy.  If deep visitation
                is required, then whenever the visitor is handed a node for which
                <methodname>isComposite</methodname> is true, it should invoke
                this method on that node with itself as a parameter.
                </para>
            <para>
                For more on the visitor class, see "Types and public data".
                For a recipe for doing recursive visitation, see "EXAMPLES"
                </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            This class provides an iterator for its container;
            <classname>CCompoundEventSegment::EventSegmentIterator</classname>.
            This is a pointer like object.  When dereferenced the iterator
            returns a <type>CEventSegment*</type> for a segment that is in the
            container.  Increment moves the 'pointer' to the next item
            in the container (shallow iteration).
            </para>
         <para>
            The class provides an abstract base class on which Visitors can be
            built: <classname>CCompoundEventSegment::CVisitor</classname>.
            The definition of this class is shown below:
            <informalexample>
                <programlisting>
  class CVisitor {
  public:
    virtual void operator()(CEventSegment* pSegment) = 0;
  };
                </programlisting>
                </informalexample>
         </para>
         <para>
            The idea is that you would derive a class from that and
            invoke the <methodname>visit</methodname> method with an object
            of that class to do something to all nodes in the container.
            </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            This section shows how to do deep iteration both with visitors and
            with iterators.  The key is that whenever a compound is found
            iteration or visitation is done recursively on that compond.
         </para>
        <example>
            <title>Deep iteration of <classname>CCompondEventSegment</classname> elements</title>
            <programlisting>
/*
   Do something to all leaf nodes of the event segment
   hierarchy
*/
void doSomething(CCompoundEventSegment* pSegment)
{
    CCompoundEventSegment::EventSegmentIterator p = pSegment-&gt;begin();
    while (p != pSegment&gt;end()) {
        CEventSegment* pSeg = *p;
        if (pSeg&gt;isComposite()) {
            doSomething(pSeg);     // Recurse to go deep.
        }
        else {
           // Do whatever needs doing here....
        }
        p++;
    }
}
                </programlisting>
            </example>
        <example>
            <title>Deep visitation of <classname>CCompoundEventSegment</classname> elements</title>
            <programlisting>
class MyVisitor : public CCompoundEventSegment::CVisitor
{
    virtual void operator()(CEventSegment* pSeg)
    {
        if (pSeg&gt;isCompound()) {
            pSeg&gt;visit(*this);
        }
        else {
            // Do what needs doing to terminal nodes....
        }
    }
};
...
CCompoundEventSegment segment;
MyVisitor visitor;
segment.visit(visitor);  // Visitor ensures deep visitation.

                </programlisting>
            </example>
        
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.ceventsegment'>CEventSegment(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>


    <refentry id="manpage.cdocumentedpacket">
      <refmeta>
         <refentrytitle>CDocumentedPacket</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CDocumentedPacket</refname>
     <refpurpose>Encapsulate event data in a packet that is documented.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CDocumentedPacket&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CDocumentedPacket</classname></ooclass>
            <constructorsynopsis>
                <methodname>CDocumentedPacket</methodname>
                <methodparam>
                    <type>unsigned short</type> <parameter>nTag</parameter>
                    </methodparam>
                <methodparam>
                    <modifier>const</modifier> <type>std::string&amp;</type>
                    <parameter>rName</parameter>
                    </methodparam>
                <methodparam>
                    <modifier>const</modifier> <type>std::string&amp;</type>
                    <parameter>Description</parameter>
                    </methodparam>
                <methodparam>
                    <modifier>const</modifier> <type>std::string&amp;</type>
                    <parameter>rVersion</parameter>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CDocumentedPacket&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>std::string&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CDocumentedPacket&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>std::string&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>unsigned short</type> <methodname>getTag</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getName</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getDescription</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getVersion</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getInstantiationDate</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>unsigned short*</type> <methodname>getHeaderPtr</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>bool</type> <methodname>getPacketInProgress</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>Format</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>unsigned short*</type> <methodname>Begin</methodname>
                <methodparam>
                    <type>unsigned short*</type> <parameter>rPointer</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>unsigned short*</type> <methodname>End</methodname>
                <methodparam>
                    <type>unsigned short*</type> <parameter>rBuffer</parameter>
                    </methodparam>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            NSCL data taking programs should try to emit self describing event
            data.  This is facilitated by providing code to support the generation
            of <firstterm>packets</firstterm>.  A packet is a chunk of event data
            with a three word header.  The first longword (32 bits), is the
            number of words in the packet, including the header.  The last word
            of the header is an identifying code.  The remainder of the packet
            are the data read out for that identifying code.
         </para>
         <para>
            <ulink url="http://groups.nscl.msu.edu/userinfo/daq/nscltags.html">
                http://groups.nscl.msu.edu/userinfo/daq/nscltags.html</ulink>
            defines the set of identifiers (tags) that are defined.  The tag assigner
            for permanent devices is
            <ulink url="mailto:bazin@nscl.msu.edu">bazin at nscl dot msu dot edu</ulink>.
            Contact him if you need a new tag assigned.
            </para>
         <para>
            The <classname>CDocumentedPacket</classname> class goes a step further
            than encapsulating your data.  It registers itself with the framework
            in a way that allows the framework to emit data that describes the set
            of tags, and versions to expect in the event data.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis><type></type>
            <methodname>CDocumentedPacket</methodname>
            <methodparam>
                <type>unsigned short</type> <parameter>nTag</parameter>
                </methodparam>
            <methodparam>
                <modifier>const</modifier> <type>std::string&amp;</type>
                <parameter>rName</parameter>
                </methodparam>
            <methodparam>
                <modifier>const</modifier> <type>std::string&amp;</type>
                <parameter>Description</parameter>
                </methodparam>
            <methodparam>
                <modifier>const</modifier> <type>std::string&amp;</type>
                <parameter>rVersion</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Constructs a documented packet.  <parameter>nTag</parameter> is the
            packet id and is the tag assigned to the packet, or one of the user
            defined tags.
            </para>
        <para>
            <parameter>rName</parameter> is a short name for the tag.  In the tag table
            at
            <ulink url="http://groups.nscl.msu.edu/userinfo/daq/nscltags.html">
                    http://groups.nscl.msu.edu/userinfo/daq/nscltags.html</ulink>,
            this is the value of the <emphasis>Acronym</emphasis> column.
            <parameter>Description</parameter> is a more verbose description
            and might be the <emphasis>Description</emphasis> column of that
            table.  <parameter>rVersion</parameter> is a string that allows you
            to indicate changes in the internal structure of this packet over time.
            This can allow analysis software to dynamically adapt to data format
            changes by knowing which data format is actually in the packet.
            </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CDocumentedPacket&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>

        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>std::string&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CDocumentedPacket&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>std::string&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <methodsynopsis>
            <type>unsigned short</type> <methodname>getTag</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the tag that has been assigned to this documented packet.
            </para>            
        <methodsynopsis>
            <type>std::string</type> <methodname>getName</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the short name assigned to the packet
            </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>getDescription</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the long description assigned to the packet.
            </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>getVersion</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the packet version string
            </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>getInstantiationDate</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            When a packet object is created a timestamp indicating when the object
            was create is also created.  This returns that timestamp.  The
            idea of this is to be able to account for any format changes that
            might have occured during an experiment that were accidently not
            reflected by updating the version of the packet.
            </para>
        <methodsynopsis>
            <type>unsigned short*</type> <methodname>getHeaderPtr</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns a pointer to the header of the packet.  This is only meaningful
            if the packet is in the process of being emitted.  See
            <methodname>getPacketInProgress</methodname> below.
            </para>
        <methodsynopsis>
            <type>bool</type> <methodname>getPacketInProgress</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns
            <literal>true</literal> if the packet is in the process of being built.
            </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>Format</methodname>
            <void />
            </methodsynopsis>
        <para>
            Returns an information string about the packet that can be
            inserted in to a packet documentation event.
            </para>
        <methodsynopsis>
            <type>unsigned short*</type> <methodname>Begin</methodname>
            <methodparam>
                <type>unsigned short*</type> <parameter>rPointer</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Starts the creation of a packet.  <parameter>rPointer</parameter>
            points to the location in memory in which the packet will be built.
            The function returns a pointer to the packet body.  The caller should
            not refrence the packet header directly.
            </para>
        <methodsynopsis>
            <type>unsigned short*</type> <methodname>End</methodname>
            <methodparam>
                <type>unsigned short*</type> <parameter>rBuffer</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Indicates that the packet body has been filled in.  <parameter>rBuffer</parameter>
            points to the first word after the packet.  It is used to compute and
            fill in the packet length header field.
            </para>
      </refsect1>
      <refsect1>
        <title>EXCEPTIONS</title>
        <para>
            Under several circumstances, this class can throw a
            <link linkend='manpage.cinvalidpacketstateexception'>
                <classname>CInvalidPacketStateException</classname>
            </link>
            </para>
        <para>
            Specifically attempting to begin a packet that's already begun or
            ending a packet that's already ended, will cause this to be thrown.
            </para>
         </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
        <example>
            <title>Using the <classname>CDocumentedPacket</classname> class</title>
            <programlisting>
class MySegment : public CEventSegment
{
private:
    CDocumentedPacket m_Packet;
public:
    MySegment() :
        CDocumentedPacket(0x1234, "Test", "A test packet", "T1.0")
    {
        
    }
    size_t read(void* pBuffer, size_t maxlen);
    ...
}
size_t
MySegment::read(void* pBuffer, size_t maxlen)
{
    uint16_t* p = reinterpret_cast&lt;uint16_t*&gt;(pBuffer);
    
    uint16_t pBody = m_Packet.Begin(p);
    
    // Fill in packet body incrementing pBody
    ...
    
    m_Packet.End(pBody);
}
                </programlisting>
            </example>
      </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
            <link linkend='manpage.ceventpacket'>CEventPacket(3sbsReadout)</link>
        </para>
        </refsect1>
   </refentry>

    <refentry id="manpage.ceventpacket">
      <refmeta>
         <refentrytitle>CEventPacket</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CEventPacket</refname>
     <refpurpose>Encapsulate an event segment in a documented packet.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CEventPacket&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CEventPacket : public CEventSegment</classname></ooclass>
            <constructorsynopsis>
                <methodname>CEventPacket</methodname>
                <methodparam>
                    <type>CEventSegment&amp;</type>   <parameter>seg</parameter>
                    </methodparam>
                <methodparam>
                    <type>short</type> <parameter>tag</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>description</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>version</parameter>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>size_t</type> <methodname>read</methodname>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                    </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>maxwords</parameter>
                    </methodparam>
                </methodsynopsis>


         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class allows you to wrap an existing event segment in a documented
            packet without modification to the event segment.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis><type></type>
                <methodname>CEventPacket</methodname>
                <methodparam>
                    <type>CEventSegment&amp;</type>   <parameter>seg</parameter>
                    </methodparam>
                <methodparam>
                    <type>short</type> <parameter>tag</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>description</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>version</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Creates the object.  <parameter>seg</parameter> is a reference
                to the event segment you want to wrap in a packet.  All the
                remaining parameters define the packet as in
                <link linkend='manpage.cdocumentedpacket'>CDocumentedPacket(3sbsReadout)</link>
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <para>
                Invokes the <methodname>initialize</methodname> method of the
                event segment
                used to construct this object.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <para>
                Invokes the <methodname>clear</methodname> method of the
                evnet segment used to create this object.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <para>
                Invokes the event segment's <methodname>disable</methodname> method.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>size_t</type> <methodname>read</methodname>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                    </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>maxwords</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Begins the packet, invokes the <methodname>read</methodname>
                method of the encapsulated event segment and ends the
                packet.
                </para>

      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.cdocumentedpacket'>CDocumentedPacket(3sbsReadout)</link>
        <link linkend='manpage.ceventsegment'>CEventSegment(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.ceventsegment">
      <refmeta>
         <refentrytitle>CEventSegment</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CEventSegment</refname>
     <refpurpose>Base class for all event segments.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CEventSegment.h&gt;
         </programlisting>
         <synopsis>
            class <ooclass><classname>CEventSegment</classname></ooclass> {
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type>   <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>size_t</type> <methodname>read</methodname>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                    </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>maxwords</parameter>
                    </methodparam>
                <modifier>=0</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>onEnd</methodname>
                <methodparam>
                    <type>CExperiment*</type> <parameter>pExperiment</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>isComposite</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <!-- SW triggers -->
            <methodsynopsis>
                <type>void</type><methodname>reject</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type><methodname>rejectImmediately</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type><methodname>keep</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>CEventSegment::AcceptState</type><methodname>getAcceptState</methodname>
                <void /> <modifier>const</modifier>
            </methodsynopsis>
        };
         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>DESCRIPTION</title>
         <para>
            Event segments are a logical unit of an experiment readout.
            <classname>CEventSegment</classname> is an abstract base class
            that provides default implementations for most of the interface
            for an event segment as well as a pure virtual function as an
            interface placeholder for the readout of the segment itself.
         </para>
      </refsect1>
      <refsect1>
         <title>PUBLIC MEMBER FUNCTIONS</title>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>void</type> <methodname>initialize</methodname>
            <void />
            </methodsynopsis>
        <para>
            This is called as the runs becomes active (begin or resume).  It
            should be overidden by concrete classes to provide code that
            sets up the hardware used by the segment and makes it ready for
            data taking.  The default implementation of this method is to do
            nothing.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>void</type> <methodname>clear</methodname>
            <void />
            </methodsynopsis>
        <para>
            Called to clear the data taking hardware just prior to releasing
            the busy and enabling gates.   This happens prior to the initial
            enable of response to triggers as well as after each event is read.
            Default action is to do nothing.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>void</type>   <methodname>disable</methodname>
            <void />
            </methodsynopsis>
        <para>
            Called to disable the electronics.  The default does nothing.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>size_t</type> <methodname>read</methodname>
            <methodparam>
                <type>void*</type> <parameter>pBuffer</parameter>
                </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>maxwords</parameter>
                </methodparam>
            <modifier>=0</modifier>
            </methodsynopsis>
        <para>
            This must be suplied by concrete classes for them to be
            concrete classes.  This method is supposed to read out the electronics
            associated with the event segment and put it in <parameter>pBuffer</parameter>.
            At most <parameter>maxwords</parameter> words of data should be read.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>onEnd</methodname>
                <methodparam>
                    <type>CExperiment*</type> <parameter>pExperiment</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This is called at the end of the run.  At this time the trigger
            thread has exited and the end run event has not yet been emitted
            by the readout framework.  One use of this method can be for deeply
            buffered event sources where you need to flush either internal or
            external buffers at the end of the run.  For example, if your custom
            trigger just indicates there are data in buffers, you can invoke
            pExperiment-&gt;ReadEvent to force the system to read events
            until your trigger indicates there is no more data to ready (presumably
            you use this method to disable your hardware triggers).
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>bool</type> <methodname>isComposite</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            If the event segment contains other segments and those segments can
            be queried via the same interfaces supported by
            <classname>CCompoundEventSegment</classname>, this should return
            <literal>true</literal> <literal>false</literal> if not.
            </para>
        
        <methodsynopsis>
            <type>void</type><methodname>reject</methodname>
            <void />
        </methodsynopsis>
        <para>
            This can be called from <methodname>read</methodname> to indicate
            the framework should not keep the event.  The remainder of the
            event segments registered with the experiment are run unless a subsequent
            one calls <methodname>rejectImmediately</methodname> (see below).
        </para>
        <methodsynopsis>
            <type>void</type><methodname>rejectImmediately</methodname>
            <void />
        </methodsynopsis>
        <para>
            This can be called  from <methodname>read</methodname> to indicate
            the framework should not keep the event.  Processing of event
            segments stops with the return from <methodname>read</methodname>
            if this is called.
        </para>
        <methodsynopsis>
            <type>void</type><methodname>keep</methodname>
            <void />
        </methodsynopsis>
        <para>
            This is called by the framework to initalize the event segment
            accept state.  It can also be called to change your mind about
            rejecting an event.  If used in this manner, <methodname>keep</methodname>
            must be called within the same event segment that invoked
            <methodname>reject</methodname> or <methodname>rejectimmediately</methodname>.
        </para>
        <methodsynopsis>
            <type>CEventSegment::AcceptState</type><methodname>getAcceptState</methodname>
            <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the value of the accept state as set by the methods
            <methodname>keep</methodname>, <methodname>reject</methodname> and
            <methodname>rejectImmdediately</methodname>.  See PUBLIC TYPES AND VARIABLES
            below for possible return values.
        </para>
        <para>
            Normally this only needs to be called by the framework.  Since each
            event segement has its own acceptance state, this cannot be used
            to determine if the event has been marked for rejection by another
            event segment.
        </para>
      </refsect1>
      <refsect1>
        <title>PUBLIC TYPES AND VARIABLES</title>
        <para>
            <type>CEventSegment::AcceptState</type> is an enum that describes how the event
            should be disposed of after the segment returns from <methodname>read</methodname>.
            This type can take the following values:
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>CEventSegment::keep</literal></term>
                <listitem>
                    <para>
                        Indicates the event segment wants the framework to keep the
                        event.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>CEventSegement::reject</literal></term>
                <listitem>
                    <para>
                        Indicates that the event segment wants the framework to
                        reject the event but that the remainder of the event
                        segments should keep running.  This takes precedence
                        over <literal>CEventSegment::keep</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>CEventSegment::rejectImmediately</literal></term>
                <listitem>
                    <para>
                        Same meaning as <literal>CExperiment::reject</literal>
                        except that this requests that no more event segments
                        be run.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
      </refsect1>
   </refentry>

    <refentry id="manpage.ceventtrigger">
      <refmeta>
         <refentrytitle>CEventTrigger</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CEventTrigger</refname>
     <refpurpose>Abstract base class for triggers.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CEventTrigger&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CEventTrigger</classname></ooclass>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>setup</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>teardown</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>operator()</methodname>
                <void /><modifier>= 0</modifier>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Event triggers are responsible for kicking off event and scaler
            readouts.  <classname>CEventTrigger</classname> is an
            abstract base class
            on which event triggers must be built. 
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>void</type> <methodname>setup</methodname>
            <void />
            </methodsynopsis>
        <para>
            Inititialize the trigger hardware.  By default this is a no-op.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>void</type> <methodname>teardown</methodname>
            <void />
            </methodsynopsis>
        <para>
            Disable the trigger hardware.  By default this is a no-op.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>bool</type> <methodname>operator()</methodname>
            <void /><modifier>= 0</modifier>
            </methodsynopsis>
        <para>
            Check for a trigger.  Return <literal>true</literal>
            if there is a trigger <literal>false</literal> otherwise.
            This must be implemented by concrete classes as it is pure virtual
            in this class.
            </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.cexperiment">
      <refmeta>
         <refentrytitle>CExperiment</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CExperiment</refname>
     <refpurpose>Encapsulate the experiment.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CExperiment&gt;
         </programlisting>
         <synopsis>
            <ooclass><classname>CExperiment</classname></ooclass>
            <constructorsynopsis>
                <methodname>CExperiment</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>ringName</parameter>
                    </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>eventBufferSize</parameter>
                    <initializer>4096</initializer>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <type>CEventTrigger*</type> <methodname>getEventTrigger</methodname>
                <void/>
                </methodsynopsis>
            <methodsynopsis>
                <type>CEventTrigger*</type> <methodname>getScalerTrigger</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setBufferSize</methodname>
                <methodparam>
                    <type>size_t</type> <parameter>newSize</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>getBufferSize</methodname>
                <void /> <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>Start</methodname>
                <methodparam>
                    <type>bool</type> <parameter>resume</parameter><initializer>false</initializer>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>Stop</methodname>
                <methodparam>
                    <type>bool</type> <parameter>pause</parameter>
                    <initializer>false</initializer>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>AddEventSegment</methodname>
                <methodparam>
                    <type>CEventSegment*</type> <parameter>pSegment</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>RemoveEventSegment</methodname>
                <methodparam>
                    <type>CEventSegment*</type> <parameter>pSegment</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>AddScalerModule</methodname>
                <methodparam>
                    <type>CScaler*</type>  <parameter>pModule</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>RemoveScalerModule</methodname>
                <methodparam>
                    <type>CScaler*</type> <parameter>pModule</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type>  <methodname>EstablishTrigger</methodname>
                <methodparam>
                    <type>CEventTrigger*</type> <parameter>pEventTrigger</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setScalerTrigger</methodname>
                <methodparam>
                    <type>CEventTrigger*</type> <parameter>pScalerTrigger</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>EstablishBusy</methodname>
                <methodparam>
                    <type>CBusy*</type> <parameter>pBusyModule</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>ReadEvent</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>TriggerScalerReadout</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>DocumentPackets</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>ScheduleRunVariableDump</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>CRingBuffer*</type> <methodname>getRing</methodname>
                <void />
            </methodsynopsis>
         </synopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Most of the functionality of an experiment is encapsulated in or
            reachable via the <classname>CExperiment</classname> class.  This
            has methods for configuration as well as several well defined methods
            that are invoked by the framework at specific points in the run-time
            of the system.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <methodsynopsis>
            <methodname>CExperiment</methodname>
            <methodparam>
                <type>std::string</type> <parameter>ringName</parameter>
                </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>eventBufferSize</parameter>
                <initializer>4096</initializer>
                </methodparam>
            </methodsynopsis>
        <para>
            Constructs the <classname>CExperiment</classname> object.  The
            framework generally only has one experiment object live at a time.
            <parameter>ringName</parameter> is the name of the ring buffer into
            which data will bge put.  This is the name of a local ring buffer.
            </para>
        <para>
            <parameter>eventBufferSize</parameter> is the size of the buffer
            created to hold events.  No event can be larger than this size.
            The size can be changed via a call to
            <methodname>setBufferSize</methodname>.
            </para>
        <methodsynopsis>
            <type>CEventTrigger*</type> <methodname>getEventTrigger</methodname>
            <void/>
            </methodsynopsis>
        <para>
            Returns a pointer to the <type>CEventTrigger</type> object that will
            be used to trigger a readout of the event segment of the experiment.
            </para>
        <methodsynopsis>
            <type>CEventTrigger*</type> <methodname>getScalerTrigger</methodname>
            <void />
            </methodsynopsis>
        <para>
            Returns a pointer to the <classname>CEventTrigger</classname>  that will be used
            to trigger a readout of the scaler bank in the experiment.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>setBufferSize</methodname>
            <methodparam>
                <type>size_t</type> <parameter>newSize</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Sets the event buffer size to <parameter>newSize</parameter>
            16 bit words. Ifyour experiment is taking large events that may overflow
            the default buffer size you may want to invoke this from
            your <methodname>Skeleton::SetupReadout</methodname> method.
            </para>
        <methodsynopsis>
            <type>size_t</type> <methodname>getBufferSize</methodname>
            <void /> <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the current event buffer size.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>Start</methodname>
            <methodparam>
                <type>bool</type> <parameter>resume</parameter><initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
        <para>
            Invoked by the framework to start data taking.  If <parameter>resume</parameter>
            is <literal>true</literal> the run is being restarted
            after being paused.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>Stop</methodname>
            <methodparam>
                <type>bool</type> <parameter>pause</parameter>
                <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
        <para>
            Invoked by the framework to stop data taking.  If
            data is being suspended due to a pause, <parameter>pause</parameter>
            will be <literal>true</literal>.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>AddEventSegment</methodname>
            <methodparam>
                <type>CEventSegment*</type> <parameter>pSegment</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Add an event segment to the top level event segment in the experiment.
            <parameter>pSegment</parameter> is the segment to add to the top
            level <classname>CCompoundEventSegment</classname> in the
            experiment.  Note that <parameter>pSegment</parameter> could itself
            point to a <classname>CCompoundEventSegment</classname> object.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>RemoveEventSegment</methodname>
            <methodparam>
                <type>CEventSegment*</type> <parameter>pSegment</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Remove an event segment from the top level event segment in
            the experiment. If <parameter>pSegment</parameter> points to an
            event segment in the top level <classname>CCompoundEventSegment</classname>
            it is removed.  Otherwise this function does nothing.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>AddScalerModule</methodname>
            <methodparam>
                <type>CScaler*</type>  <parameter>pModule</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Adds a scaler module to the top level scaler bank in the
            experiement.  <parameter>pModule</parameter> is added to
            the end of the collection of modules in the bank.  Note that
            <parameter>pModule</parameter> might itself point to a
            <classname>CScalerBank</classname> object.
              </para>
        <methodsynopsis>
            <type>void</type> <methodname>RemoveScalerModule</methodname>
            <methodparam>
                <type>CScaler*</type> <parameter>pModule</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Removes a scaler object from the top level scaler bank.
            If <parameter>pModule</parameter> is in the
            top level <classname>CScalerBank</classname> object it is removed.
            If not, this method does nothing.
            </para>
        <methodsynopsis>
            <type>void</type>  <methodname>EstablishTrigger</methodname>
            <methodparam>
                <type>CEventTrigger*</type> <parameter>pEventTrigger</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Establishes the event trigger.   The trigger for the top level
            event segment readout is set <parameter>pEventTrigger</parameter>.
            When this <classname>CEventTrigger</classname> object's
            <methodname>operator()</methodname> returns <literal>true</literal>
            when polled during data taking, the event segment will be read.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>setScalerTrigger</methodname>
            <methodparam>
                <type>CEventTrigger*</type> <parameter>pScalerTrigger</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Sets the scaler trigger to <parameter>pScalerTrigger</parameter>.
            During data taking this trigger's <methodname>operator()</methodname>
            is polled.  When it returns <literal>true</literal> the top level
            scaler bank will be read.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>EstablishBusy</methodname>
            <methodparam>
                <type>CBusy*</type> <parameter>pBusyModule</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Sets <parameter>pBusyModule</parameter> to be the object that
            will be used to handle the external computer busy hardware.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>ReadEvent</methodname>
            <void />
            </methodsynopsis>
        <para>
            Called by the trigger thread to read an event.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>TriggerScalerReadout</methodname>
            <void />
            </methodsynopsis>
        <para>
            Called by the trigger thread to read a scaler event.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>DocumentPackets</methodname>
            <void />
            </methodsynopsis>
        <para>
            Called by the framework to emit events that describe the set of
            <classname>CDocumentedPacket</classname> objects that are
            currently instantiated.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>ScheduleRunVariableDump</methodname>
            <void />
            </methodsynopsis>
        <para>
            Called by the framework to create events that describe the values of
            run and statevariables.
            </para>
      </refsect1>
   </refentry>


    <refentry id="manpage.cinvalidpacketstateexception">
      <refmeta>
         <refentrytitle>CInvalidPacketStateException</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CInvalidPacketStateException</refname>
     <refpurpose>Exception thrown by documented packets.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CInvalidPacketStateException&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CInvalidPacketStateException : public CReadoutException</classname></ooclass>
            <constructorsynopsis>
                <methodname>CInvalidPacketStateException</methodname>
                <methodparam>
                    <type>bool</type> <parameter>WasOpen</parameter>
                    </methodparam>
                <methodparam>
                    <modifier>const</modifier> <type>char*</type>
                    <parameter>pszAction</parameter>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CInvalidPacketStateException</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CInvalidPacketStateException&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </constructorsynopsis>
            <destructorsynopsis>
                <methodname>~CInvalidPacketStateException</methodname>
                <void />
                </destructorsynopsis>
            <methodsynopsis>
                <type>CInvalidPacketStateException&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CInvalidPacketStateException&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CInvalidPacketStateException&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CInvalidPacketStateException&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>getWasOpen</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>Int_t</type> <methodname>ReasonCode</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual const</modifier>
                <type>char*</type> <methodname>ReasonText</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This exception is thrown when a <classname>CDocumentedPacket</classname>
            is abused.  Specifically if a packet being formatted is begun again,
            or closed one ended.  The best protection against abusing
            <classname>CDocumentedPacket</classname> objects is to
            encapsulate an ordinary <classname>CEventSegment</classname> in
            a <classname>CEventPacket</classname> object as it will
            correctly use the <classname>CDocumentedPacket</classname> to put your
            data inside a packet.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis><type></type>
                <methodname>CInvalidPacketStateException</methodname>
                <methodparam>
                    <type>bool</type> <parameter>WasOpen</parameter>
                    </methodparam>
                <methodparam>
                    <modifier>const</modifier> <type>char*</type>
                    <parameter>pszAction</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Constructs the exception object.  <parameter>WasOpen</parameter>
                should be true if the packet was open when this exception was
                thrown.  <parameter>pszAction</parameter> provides some
                execution context for the exception.
                </para>
            <methodsynopsis>
                <type>int</type> <methodname>getWasOpen</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <para>
                Returns non zero if <parameter>WasOpen</parameter> was true
                when this object was constructed.
                </para>
            <methodsynopsis>
                <type>Int_t</type> <methodname>ReasonCode</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <para>
                Returns a code describing the reason for the exception.
                </para>
            <methodsynopsis>
                <modifier>virtual const</modifier>
                <type>char*</type> <methodname>ReasonText</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <para>
                Returns a pointer to a string that describes why the
                exception was thrown.
                </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.cnulltrigger">
      <refmeta>
         <refentrytitle>CNullTrigger</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CNullTrigger</refname>
     <refpurpose>A trigger that never fires.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CNullTrigger&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CNullTrigger : public CEventTrigger</classname></ooclass>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type> <methodname>operator()</methodname>
                <void />
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Provides a concrete event trigger that never fires.
         </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.creadoutexception">
      <refmeta>
         <refentrytitle>CReadoutException</refentrytitle>
         <manvolnum>3sbsreadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CReadoutException</refname>
     <refpurpose>Base class for readout specific exceptions</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CReadoutException&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CReadoutException :  public CException</classname></ooclass>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class is a place holder in the exception class hierarchy.  It allows
            programmers to catch all readout specific exception by catching exceptions
            of this type.
         </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
        <example>
            <title>Catching readout specific examples</title>
            <programlisting>
try {
// Code that might throw one of the readout applications
// exceptions:
...
}
catch (CReadoutException&amp; error) {
    // Process the exception here.
    ...
}
                </programlisting>
            </example>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.cinvalidpacketstateexception'>CInvalidPacketStateException(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.cscalerbank">
      <refmeta>
         <refentrytitle>CScalerBank</refentrytitle>
         <manvolnum>3sbsreadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CScalerBank</refname>
     <refpurpose>Container for individual Scaler objects.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CScalerBank&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CScalerBank : public CScaler</classname></ooclass>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::vector&lt;uint32_t&gt;</type> <methodname>read</methodname>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>AddScalerModule</methodname>
                <methodparam>
                    <type>CScaler*</type> <parameter>pScaler</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>DeleteScaler</methodname>
                <methodparam>
                    <type>CScaler*</type> <parameter>pScaler</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>ScalerIterator</type> <methodname>begin</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>ScalerIterator</type> <methodname>end</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>isComposite</methodname>
                <void />
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>visit</methodname>
                <methodparam>
                    <type>CVisitor&amp;</type> <parameter>visitor</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>leafCount</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type>
                <methodname>fullCount</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type>
                <methodname>isComposite</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CScalerBank</classname> is an ordered container of
            <classname>CScaler</classname> objects.  As such, it allows scalers
            to be organized into a hierarchy (since <classname>CScalerBank</classname>
            objects are also <classname>CScaler</classname> objects they can contain
            other <classname>CScalerBank</classname>s).
         </para>
         <para>
            The <classname>CExperiment</classname> has a single top level
            <classname>CScalerBank</classname>.  It is the application's
            responsibility to put the top level of the scaler readout hierarchy
            in that <classname>CScalerBank</classname>.  This is normally done in
            <methodname>CSkeleton::SetupScalers</methodname>.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <para>
                <classname>CScaler</classname> interface, invokes
                <methodname>initialize</methodname> on all
                elements of the collection.  This performs a deep initialization
                of the scaler hardware.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <para>
                <classname>CScaler</classname> Interface. Invokes <methodname>clear</methodname>
                on all members of the collection.  This performs a deep clear of
                the scaler hardware.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <para>
                <classname>CScaler</classname> interface.  invokes <methodname>disable</methodname>
                on all members of the collection.  This performs a deep
                <methodname>disable</methodname> of the scaler hardware in the
                hierarchy below this <classname>CScalerBank</classname>.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::vector&lt;uint32_t&gt;</type> <methodname>read</methodname>
                </methodsynopsis>
            <para>
                <classname>CScaler</classname> interface.  Reads the scalers in the
                collection in inertion order.   The return value is a
                <classname>std::vector</classname>  of
                the data read.
                </para>
            <methodsynopsis>
                <type>void</type> <methodname>AddScalerModule</methodname>
                <methodparam>
                    <type>CScaler*</type> <parameter>pScaler</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Adds  the <classname>CScaler</classname> <parameter>pScaler</parameter>
                to the end of the collection maintained by this module.
                </para>
            <methodsynopsis>
                <type>void</type> <methodname>DeleteScaler</methodname>
                <methodparam>
                    <type>CScaler*</type> <parameter>pScaler</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                If <parameter>pScaler</parameter> is an element of the collection
                it is removed from the collection.  IF <parameter>pScaler</parameter>
                is not in the collection, this function does nothing.
                </para>     
            <methodsynopsis>
                <type>ScalerIterator</type> <methodname>begin</methodname>
                <void />
                </methodsynopsis>
            <para>
                Returns a <type>CScalerBank::ScalerIterator</type> which is an
                iterator to the beginning of the collection.  Iterators are  pointer
                like objects. Dereferencing a <type>CScalerBank::ScalerIterator</type>
                retrieves the <type>CScaler*</type> at the iterator's position in
                the collection.  Incrementing a <type>CScalerBank::ScalerIterator</type>
                'points' to the next item in the collection.
                </para>
            <para>
                See also <methodname>end</methodname> below.
                </para>
            <methodsynopsis>
                <type>ScalerIterator</type> <methodname>end</methodname>
                <void />
                </methodsynopsis>
            <para>
                Returns a CScalerBank::<classname>ScalerIterator</classname>
                that points off the end of the collection.  Since iterators
                can be compared for equality, this provides a methdo to
                determine when an iterator has reached the end of
                iteration.
                </para>
            <para>
                For example
                <informalexample>
                    <programlisting>
CScalerBank theBank;
...
CScalerBank::ScalerIterator p = theBank.begin();
while(p != theBank.end()) {
    CScaler* pAScaler = *p;
    ...
    p++;
}
                        </programlisting>
                    </informalexample>
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>isComposite</methodname>
                <void />
                <modifier>const</modifier>
                </methodsynopsis>
            <para>
                Returns <literal>true</literal> indicating this scaler is a
                composite scaler and therefore implements insertion, deletion,
                visitation and iteration.
                </para>
            <methodsynopsis>
                <type>void</type> <methodname>visit</methodname>
                <methodparam>
                    <type>CVisitor&amp;</type> <parameter>visitor</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Visits (in a shallow way), all members of the container.  See
                the EXAMPLES for a way to do a deep visitation.  <parameter>visitor</parameter>
                is a reference to an object from a class derived from
                <classname>CScalerBank::CVisitor</classname>.    See
                "Types and public data" below for information about the
                <classname>CScalerBank::CVisitor</classname> class.
                </para>
            <methodsynopsis>
                <type>size_t</type> <methodname>leafCount</methodname>
                <void />
                </methodsynopsis>
            <para>
                Performs a deep visitation to count the total number of items
                in the hierarchy rooted at this object that are not composites.
                (for which <methodname>isComposite</methodname> returns
                <literal>false</literal>).
                </para>
            <methodsynopsis>
                <type>size_t</type>
                <methodname>fullCount</methodname>
                <void />
                </methodsynopsis>
            <para>
                Performs a deep visitation of the container to count the total
                number of elements regardless of the value returned by
                <methodname>isComposite</methodname>.
                </para>

      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            <classname>CScalerBank::Iterator</classname> is an iterator over
            the container of <classname>CScaler</classname>  objects
            maintained by this class.  It supports the following operations:
            <variablelist>
                <varlistentry>
                    <term>dereference (unary *)</term>
                    <listitem>
                        <para>
                            Returns the <classname>CScaler</classname>* at this
                            position in the container.
                            </para>
                        </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>pre/post increment</term>
                    <listitem>
                        <para>Advances to the next item in the container.
                        This is a shallow advance.
                        </para>
                        </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>Comparison (operator==) with other iterators</term>
                    <listitem>
                    <para>
                        Determines if two iterators  refer to the same location
                        of the container.  Along with the <methodname>end</methodname>
                        method can use to determine when iterators have gone
                        past the end of the container.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>pre/post decrement</term>
                    <listitem>
                        <para>
                            Points the iterator at the previous element of the
                            container.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
         </para>
         <para>
            <classname>CScalerBank::CVisitor</classname>  is an abstract base class
            for objects to be passed to the <methodname>visit</methodname> method.
            This base class has a single, pure virtual method:
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>operator()</methodname>
                <methodparam>
                    <type>CScaler*</type> <parameter>pScaler</parameter>
                    </methodparam>
                </methodsynopsis>
            </para>
         <para>
            This method is called during visitation for each element of the
            container.  <parameter>pScaler</parameter> points to the element
            being visited.
            </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            The example in this section shows how to do  deep visitation.
            The key is that when the visitor sees visits a composit element,
            it recursively invokes <methodname>visit</methodname> on that
            element.  The example produces statistics on the number leaf and
            composite elements.
         </para>
         <example>
            <title>Deep visitation in <classname>CScalerBank</classname> containers</title>
            <programlisting>
class Statistics : public CScalerBank::CVisitor
{
private:
    unsigned    m_leaves;
    unsigned    m_composites;
public:
    Statitics() :
        m_leaves(0),
        m_composites(0) {}
    unsigned leaves() {return m_leaves;}
    unsigned composites() {return m_composites;}
    
    virtual void operator(CScaler* pScaler) {
        if (pScaler&gt;isComposite()) {
            m_composites++;
            CScalerBank* pBank = reinterpret_cast&lt;ScalerBank*&gt;(pScaler);
            pBank&gt;visit(*this);
        } else {
            m_leaves++;
        }
    }
};
                </programlisting>
            </example>
         
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.cscaler'>CScaler</link>
     </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.ctimedtrigger">
      <refmeta>
         <refentrytitle>CTimedTrigger</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTimedTrigger</refname>
     <refpurpose>CEventTrigger that fires periodically</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTimedTrigger.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTimedTrigger : public CEventTrigger</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTimedTrigger</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>timespec&amp;</type>
                    <parameter>interval</parameter>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CTimedTrigger</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CTimedTrigger&amp;</type> <parameter>interval</parameter>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setPeriod</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>struct timespec&amp;</type> <parameter>newInterval</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>setup</methodname>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type>
                <methodname>operator()</methodname>
                <void/>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Provides a concrete <classname>CEventTrigger</classname>  class
            that fires periodically.  Note that the trigger is not latched, that
            that is once <methodname>operator()</methodname> returns
            <literal>true</literal> it won't do so again until the trigger is
            next due to fire.
         </para>
         <para>
            This is the typical event trigger attached to scaler readout.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis>
                <methodname>CTimedTrigger</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>timespec&amp;</type>
                    <parameter>interval</parameter>
                    </methodparam>
                </methodsynopsis>
           <para>
                Constructs a trigger that will fire periodically.  The
                trigger interval is <parameter>interval</parameter>.
                This can be modified by calling <parameter>setPeriod</parameter>
                </para>
            <methodsynopsis>
                <methodname>CTimedTrigger</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CTimedTrigger&amp;</type> <parameter>interval</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Copy construction.
                </para>
            <methodsynopsis>
                <type>void</type> <methodname>setPeriod</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>struct timespec&amp;</type> <parameter>newInterval</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Sets the new trigger period.  This takes effect immediately.  If
                the time since the last trigger is greater than
                <parameter>newInterval</parameter> the next call to
                <methodname>operator()</methodname> will return
                <parameter>true</parameter>.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>setup</methodname>
                </methodsynopsis>
            <para>
                Initializes the trigger by setting the last fired time to now.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type>
                <methodname>operator()</methodname>
                <void/>
                </methodsynopsis>
            <para>
                Returns <literal>true</literal> if the last trigger was more
                longer ago than the trigger period.
                </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.cv977busy">
      <refmeta>
         <refentrytitle>CV977Busy</refentrytitle>
         <manvolnum>volnum</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CV977Busy</refname>
     <refpurpose>Concrete busy class using the CAEN V977 module</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CV977Busy.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CV977Busy : public CBusy</classname></ooclass>
            <constructorsynopsis>
                <methodname>CV977Busy</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    <initializer>0</initializer>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CV977Busy</methodname>
                <methodparam>
                    <type>CCAENV977&amp;</type> <parameter>module</parameter>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>GoBusy</methodname> <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>GoClear</methodname>
                <void />
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Busy objects control external hardware that indicates when the readout
            software is unable to respond to a new trigger.   The CAENV977 module
            achieves this by using its ability to copy input signals to it's outputs
            in a latchemd manner.  It is legal to use a single module as both a
            trigger and a busy module.  
         </para>
         <para>
            The following signals are used by the module:
            </para>
         <informaltable>
            <tgroup cols='3'>
                <thead>
                    <row>
                        <entry>Plug</entry>
                        <entry>Direction</entry>
                        <entry>Meaning</entry>
                        </row>
                    </thead>
                <tbody>
                    <row>
                        <entry>0</entry>
                        <entry>Input (left)</entry>
                        <entry>
                            <para>
                                This should be the event trigger the computer sees.
                                This is the trgger input as well for when the
                                module is being used as a trigger.
                                </para>
                            </entry>
                        </row>
                    <row>
                        <entry>0</entry>
                        <entry>Output (right)</entry>
                        <entry>
                            Computer is busy.
                            </entry>
                        </row>
                    <row>
                        <entry>1</entry>
                        <entry>Output (right)</entry>
                        <entry>
                            Computer going busy for software reasons (pulsed)
                            </entry>
                        
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>  
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
             <methodsynopsis><type></type>
                <methodname>CV977Busy</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    <initializer>0</initializer>
                    </methodparam>
                </methodsynopsis>
            <para>
                Constructor that uses the <parameter>base</parameter> address
                and VME <parameter>crate</parameter> number to describe the
                module.
                </para>
            <methodsynopsis><type></type>
                <methodname>CV977Busy</methodname>
                <methodparam>
                    <type>CCAENV977&amp;</type> <parameter>module</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Constructor that operates with an existing
                <classname>CCAENV977</classname>  <parameter>module</parameter>.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>GoBusy</methodname> <void />
                </methodsynopsis>
            <para>
                Called by the framework to pulse the going busy output.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>GoClear</methodname>
                <void />
                </methodsynopsis>
            <para>
                Called by the framework to clear the busy output.
                </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.cbusy'>CBusy(3sbsReadout)</link>,
     <link linkend='manpage.cv977trigger'>CV977Trigger(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>


    <refentry id="manpage.cv977trigger">
      <refmeta>
         <refentrytitle>CV977Trigger</refentrytitle>
         <manvolnum>volnum</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CV977Trigger</refname>
     <refpurpose>Concrete Trigger class using CAEN V977 module.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CV977Trigger.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CV977Trigger : public CEventTrigger</classname></ooclass>
            <constructorsynopsis>
                <methodname>CV977Trigger</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    <initializer>0</initializer>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CV977Trigger</methodname>
                <methodparam>
                    <type>CCAENV977*</type> <parameter>pModule</parameter>
                    </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>deleteme</parameter>
                    <initializer>true</initializer>
                    </methodparam>
                </constructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>setup</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>operator()</methodname>
                <void />
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CV977Trigger</classname> is a concrete trigger class that
            accepts triggers from a CAEN V977 I/O register module.  The trigger
            is accepted on input 0.  Since the module latches inputs input 0 should
            be pulsed.  Normally you should use this class in conjunction with a
            <classname>CV977Busy</classname> object to manage the busy.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis><type></type>
                <methodname>CV977Trigger</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>base</parameter>
                    </methodparam>
                <methodparam>
                    <type>unsigned</type> <parameter>crate</parameter>
                    <initializer>0</initializer>
                    </methodparam>
                </methodsynopsis>
            <para>
                Constructs the object using a description of the electronics module's
                <parameter>base</parameter> address and VME
                <parameter>crate</parameter> number.
                </para>
            <methodsynopsis>
                <methodname>CV977Trigger</methodname>
                <methodparam>
                    <type>CCAENV977*</type> <parameter>pModule</parameter>
                    </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>deleteme</parameter>
                    <initializer>true</initializer>
                    </methodparam>
                </methodsynopsis>
            <para>
                Constructs the object using an existing hardware object
                <parameter>pModule</parameter>.
                If <parameter>deleteme</parameter> is <literal>true</literal>,
                when this object is destroyed, the module passed in will be as well.
                This is appropriate if a
                <classname>CCAENV977</classname> was dynamically allocated/constructed
                for this object.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>setup</methodname>
                <void />
                </methodsynopsis>
            <para>
                <classname>CEventTrigger</classname> interface.  Called to
                setup the electronics and make it able to accept trigger.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>operator()</methodname>
                <void />
                </methodsynopsis>
            <para>
                <classname>CEventTrigger</classname> interface.  Called to
                poll for a trigger condition.  Triggers are latched until
                they are cleared.  Normally this object will be used in
                conjucntion with a <classname>CV977Busy</classname> object
                on the same electronics.  The clear of the busy output of
                that object will reset the trigger as well.
                </para>
      </refsect1>

      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.ceventtrigger'>CEventTrigger(3sbsReadout)</link>,
        <link linkend='manpage.cv977busy'>CV977Busy(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.runstate">
      <refmeta>
         <refentrytitle>RunState</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>RunState</refname>
     <refpurpose>Encapsulate important state of the software.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;RunState.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>RunState</classname></ooclass>
            <fieldsynopsis>
                <type>State</type> <varname>m_state</varname>
                </fieldsynopsis>
            <fieldsynopsis>
                <type>uint32_t</type> <varname>m_runNumber</varname>
                </fieldsynopsis>
            <fieldsynopsis>
                <type>uint32_t</type>    <varname>m_timeOffset</varname>
                </fieldsynopsis>
            <fieldsynopsis>
                <type>char*</type> <varname>m_pTitle</varname>
                </fieldsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>RunState*</type>
                <methodname>getInstance</methodname>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type>
                <methodname>stateName</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>std::string</type> <methodname>stateName</methodname>
                <methodparam>
                    <type>State</type> <parameter>state</parameter>
                    </methodparam>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This is essentially a singleton structure that encapsulates the
            state of the run.  See Types and Public data for a description of
            the data elements of the struct.  See Public Member functions for the
            methods.  Note that since this is a singleton, construction is private.
            You must use the <methodname>getInstance()</methodname> method to
            obtain a pointer to the one and only instance of the object.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>RunState*</type>
                <methodname>getInstance</methodname>
                </methodsynopsis>
            <para>
                Returns a pointer to the one and only instance of this class.
                If no instance exists yet, it is created.
                </para>
            <methodsynopsis>
                <type>std::string</type>
                <methodname>stateName</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <para>
                Returns a text string that describes the current state of the run.
                This is a textual equivalent of the <varname>m_state</varname>
                member variable.
                </para>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>std::string</type> <methodname>stateName</methodname>
                <methodparam>
                    <type>State</type> <parameter>state</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Given a  <parameter>state</parameter> returns the textual
                equivalent of that state.
                </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            Since member data can be set and read, getters and setter methods
            would be overkill and all data are public.  The public member
            data are:
         </para>
         <variablelist>
            <varlistentry>
                <term><fieldsynopsis>
                <type>RunState::State</type> <varname>m_state</varname>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        Current run state.  The legal values are
                        <literal>inactive</literal>,
                        <literal>active</literal> and
                        <literal>paused</literal>
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><fieldsynopsis>
                <type>uint32_t</type> <varname>m_runNumber</varname>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The run number of the active run or the next run (unless
                        changed by the user), if the run is not active.
                        </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term><fieldsynopsis>
                <type>uint32_t</type>    <varname>m_timeOffset</varname>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The nuber of seconds into the run we are.  This is used by
                        the pause/resume management to ensure that the system
                        does not count time when the run is paused.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
      </refsect1>
      <refsect1>
        <title>EXAMPLES</title>
        <example>
            <title>Outputting the state of the run</title>
            <programlisting>
RunState* pState = RunState::getInstance();
std::cout &lt;&lt; " The run is currently "
          &lt;&lt; pState-&gt;stateName
          &lt; std::endl;
                </programlisting>
            </example>
      </refsect1>
   </refentry>

    <refentry id="manpage.cscaler">
      <refmeta>
         <refentrytitle>CScaler</refentrytitle>
         <manvolnum>3sbsReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CScaler</refname>
     <refpurpose>Base class for scaler readout classes</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CScaler.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CScaler</classname></ooclass>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::vector&lt;uint32_t&gt;</type>
                <methodname>read</methodname>
                <void /><modifier>= 0</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>isComposite</methodname>
                <void />
                <modifier>const</modifier>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CScaler</classname> is an abstract base class for
            objects that read out scaler hardware.  Concrete classes have to be
            made by deriving from this class.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>initialize</methodname>
                <void />
                </methodsynopsis>
            <para>
                Called by the framework to initialize the scaler hardware
                prior to starting data taking.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>clear</methodname>
                <void />
                </methodsynopsis>
            <para>
                Called by the framework to clear scaler hardware both prior to
                starting data taking and after reading a scaler event.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>disable</methodname>
                <void />
                </methodsynopsis>
            <para>
                Called by the framework to disable the scaler hardware
                prior to terminating data taking.
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::vector&lt;uint32_t&gt;</type>
                <methodname>read</methodname>
                <void /><modifier>= 0</modifier>
                </methodsynopsis>
            <para>
                Called by the framework to read this module's scaler(s).  The
                return value is a <type>std::vector</type> consisting of the
                data read from the hardware
                </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>bool</type> <methodname>isComposite</methodname>
                <void />
                <modifier>const</modifier>
                </methodsynopsis>
            <para>
                Should return <literal>false</literal> if the scaler is not a
                container for other scalers (see e.g.
                <link linkend='manpage.cscalerbank'>CScalerBank(3sbsReadout)</link>).
                Should return <literal>false</literal> if the scaler is a container
                and implements the interface defined by
                <link linkend='manpage.cscalerbank'>CScalerBank(3sbsReadout)</link>.
                </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.cscalerbank'>CScalerBank(3sbsReadout)</link>
     </para>
      </refsect1>
   </refentry>

<!-- /manpage -->

<!-- manpage 1sbsReadout -->
<refentry id="manpage.1sbsreadout">
  <refmeta>
     <refentrytitle>Readout</refentrytitle>
     <manvolnum>1sbsReadout</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>Readout</refname>
     <refpurpose>Start an event readout program.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    <command>
Readout <replaceable>options...</replaceable>   
    </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
    Starts the Readout program.
     </para>
  </refsect1>
  <refsect1>
     <title>
    OPTIONS
     </title>
     <variablelist>
    <varlistentry>
        <term><option>--port</option>=<replaceable>port-selection</replaceable></term>
        <listitem>
        <para>
            Enables the Tcl server component to listen on the specified port.
            If the value of this option is <replaceable>managed</replaceable>,
            the port manager is contacted to allocate a port.  Otherwise the
            value must be the integer port number on which to listen.
        </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><option>--ring</option>=<replaceable>name</replaceable></term>
        <listitem>
            <para>
                Provides the name of the local ring into which data will be placed.
                If this switch is omitted, the ring name will be the username
                running the program.
                </para>
            </listitem>
        </varlistentry>
    <varlistentry>
        <term><option>--help</option></term>
        <listitem>
            <para>
                Outputs a summary of the command lineo ptions and exits without
                doing anything else useful.
                </para>
            </listitem>
        </varlistentry>
    <varlistentry>
        <term><option>--version</option></term>
        <listitem>
            <para>
                Outputs the program version number and exists without doing anything
                else useful.
                </para>
            </listitem>
        </varlistentry>
    
     </variablelist>
  </refsect1>

</refentry>

<!-- /manpage -->
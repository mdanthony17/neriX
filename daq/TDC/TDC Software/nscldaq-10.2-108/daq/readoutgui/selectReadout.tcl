# selectReadout.tcl --
#
# UI generated by GUI Builder Build 107673 on 2005-08-12 11:37:15 from:
#    //homedir/home2/fox/My Documents/DAQDocs/2005a/daq/DirectoryStructure/code/selectReadout.ui
# This file is auto-generated.  Only the code within
#    '# BEGIN USER CODE'
#    '# END USER CODE'
# and code inside the callback subroutines will be round-tripped.
# The proc names 'ui' and 'init' are reserved.
#

package require Tk 8.4

# Declare the namespace for this dialog
namespace eval selectReadout {}

# Source the ui file, which must exist
source [file join [file dirname [info script]] selectReadout_ui.tcl]

# BEGIN USER CODE

if {[info var ::argv0] == ""} {
    set ::argv0 ""
}
if {[info var ::argv] == ""} {
    set ::argv ""
}
package provide selectReadout 1.0
# END USER CODE

# BEGIN CALLBACK CODE
# ONLY EDIT CODE INSIDE THE PROCS.

# selectReadout::browse_command --
#
# Callback to handle browse widget option -command
#
# ARGS:
#    <NONE>
#
proc selectReadout::browse_command args {
    # Use an open file dialog to select a
    # a file to load into the path entry widget.
    # We start out with the one currently there.
    # or ./ if none.
    set base $::selectReadout::ROOT
    if {$base == "."} {
        set base ""
    }
    append entry $base . path
    set    filename [$entry get]
    if {$filename == ""} {
        set defaults {}
    } else {
        set defaults [list -initialdir [file dirname $filename] \
                           -initialfile [file tail $filename]]
    }
    set newFile [eval tk_getOpenFile \
                                -parent  $::selectReadout::ROOT \
                                -title {{Readout Program}} $defaults]
    if {$newFile != ""} {
        $entry delete 0 end
        $entry insert end $newFile
    }
}
# selectReadout::cancel_command --
#
# Callback to handle cancel widget option -command
#
# ARGS:
#    <NONE>
#
proc selectReadout::cancel_command args {}

# selectReadout::hostname_invalidcommand --
#
# Callback to handle hostname widget option -invalidcommand
#
# ARGS:
#    <NONE>
#
proc selectReadout::hostname_invalidcommand args {}

# selectReadout::hostname_validatecommand --
#
# Callback to handle hostname widget option -validatecommand
#
# ARGS:
#    <NONE>
#
proc selectReadout::hostname_validatecommand args {}

# selectReadout::hostname_xscrollcommand --
#
# Callback to handle hostname widget option -xscrollcommand
#
# ARGS:
#    <NONE>
#
proc selectReadout::hostname_xscrollcommand args {}

# selectReadout::ok_command --
#
# Callback to handle ok widget option -command
#
# ARGS:
#    <NONE>
#
proc selectReadout::ok_command args {}

# selectReadout::path_invalidcommand --
#
# Callback to handle path widget option -invalidcommand
#
# ARGS:
#    <NONE>
#
proc selectReadout::path_invalidcommand args {}

# selectReadout::path_validatecommand --
#
# Callback to handle path widget option -validatecommand
#
# ARGS:
#    <NONE>
#
proc selectReadout::path_validatecommand args {}

# selectReadout::path_xscrollcommand --
#
# Callback to handle path widget option -xscrollcommand
#
# ARGS:
#    <NONE>
#
proc selectReadout::path_xscrollcommand args {}


# END CALLBACK CODE

# selectReadout::init --
#
#   Call the optional userinit and initialize the dialog.
#   DO NOT EDIT THIS PROCEDURE.
#
# Arguments:
#   root   the root window to load this dialog into
#
# Results:
#   dialog will be created, or a background error will be thrown
#
proc selectReadout::init {root args} {
    # Catch this in case the user didn't define it
    catch {selectReadout::userinit}
    if {[info exists embed_args]} {
	# we are running in the plugin
	selectReadout::ui $root
    } elseif {$::argv0 == [info script]} {
	# we are running in stand-alone mode
	wm title $root selectReadout
	if {[catch {
	    # Create the UI
	    selectReadout::ui  $root
	} err]} {
	    bgerror $err ; exit 1
	}
   }
  catch {selectReadout::run $root}
}



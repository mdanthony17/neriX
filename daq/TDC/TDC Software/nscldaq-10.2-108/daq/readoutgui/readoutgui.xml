<!-- chapter utilities -->

<chapter>
    <title>Readout GUI (ReadoutShell)</title>
    <para>
        The  Readout GUI (installed as $DAQROOT/bin/ReadoutShell)
        is a graphical user interface that wraps around data source (Readout)
        software.  It allows you to:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                Run a data source in a remote system.
            </para>
        </listitem>
        <listitem>
            <para>
                Control your experiment runs via a simple graphical user
                interface
            </para>
        </listitem>
        <listitem>
            <para>
                Manage event files and ancillary data so that they remain
                together in a single package while providing an event file
                view.
            </para>
        </listitem>
        <listitem>
            <para>
                Customize the operation of the GUI program by adding
                Tcl scripted extensions that are called at specific times.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        For reference information see the
        <xref linkend="manpage_readoutshell" endterm="manpage_readoutshell_title" />
        man page in section 1daq.
    </para>
    <section>
        <title>Running and using the ReadoutShell</title>
        <para>
            The Readout GUI is installed as
            <filename>$DAQROOT/bin/ReadoutShell</filename> where
            <literal>$DAROOT</literal> is used as a placeholder for the top
            level of the ring buffer data acquisition installation directory.
        </para>
        <warning>
            <title>WARNING!</title>
            <para>
                You cannot use the readout gui of nscldaq versions earlier
                than 10.0 with the ring buffer data acquisition system.
            </para>
        </warning>
        <para>
            <command>ReadoutShell</command> accepts two command line options:
        </para>
        <variablelist>
            <varlistentry>
                <term><option>-host</option>=<replaceable>hostname</replaceable></term>
                <listitem>
                    <para>
                        Specifies on which system Readout will be run.  You must
                        be able to do an ssh login to that host by means
                        of ssh key exchange (without a password).  You can
                        find out how to set this up by googling for
                        <literal>setting up ssh keys</literal>.
                    </para>
                    <para>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-path</option>=<replaceable>readout-path</replaceable></term>
                <listitem>
                    <para>
                        Specifies the full path to the readout program
                        ReadoutShell should run.  This path must be accessible
                        on the system that runs ReadoutGui and the users's home
                        directory must be shared between that system and the
                        system designated by the <option>-host</option> option.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
           By default, the system assumes data will be put in a ringbuffer on
           the same system as the readout program with a name the same as your
           username.  If, for example, your username is <literal>fox</literal>
           and your readoutis running in
           <literal>spdaq22.nscl.msu.edu</literal>, the default ring name is
           going to be <literal>tcp://spdaq22.nscl.msu.edu/fox</literal>.
        </para>
        <para>
           You can override the default ring name by setting the environment
           variable <literal>RINGNAME</literal> to the name of the ring in the
           system on which the readout is running.  If, in the example above,
           your readout software is putting data in the ring
           <literal>s800</literal>, you would: <command>export
           RINGNAME=s800</command> prior t running the GUI.
        </para>
        <para>
            When the GUI starts it will attempt start the readout program specified
            in the remote host specified.  All output from that program will
            appear in the large output window on the GUI.  Below are a few
            of the common controls you'll need to know how to use:
        </para>
        <variablelist>
            <varlistentry>
                <term><guibutton>Begin</guibutton></term>
                <listitem>
                    <para>
                        Starts a new data taking run.  If the run is active,
                        this button is a <guibutton>End</guibutton> button and
                        ends the active run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><guilabel>Title</guilabel></term>
                <listitem>
                    <para>
                        This text entry is only enabled when the run is
                        inactive (the <guibutton>Begin</guibutton> button
                        is visible).  Type into this entry to provide a
                        title that will be used for the next run.
                        The title, truncated if necessary to 79 characters
                        is inserted into some of the ring items the run
                        produces.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><guilabel>Run Number</guilabel></term>
                <listitem>
                    <para>
                        This entry is only enabled when the run is inactive.
                        It is validated so that it must contain an integer
                        at all times.  The number in this entry will be the run
                        number of the next run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><guibutton>Record</guibutton></term>
                <listitem>
                    <para>
                        This check button is only enabled when the the run
                        is inactive.  When checked, the next run will be
                        recorded to disk.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><guimenu>File</guimenu>&#8594;<guimenuitem>New...</guimenuitem></term>
                <listitem>
                    <para>
                        This menu item allows you to choose a new readout
                        program and/or host.  Once this a new readout/host
                        have been selected you can use either
                        <guimenu>File</guimenu>&#8594;<guimenuitem>Restart...</guimenuitem>
                        or <guimenu>File</guimenu>&#8594;<guimenuitem>Start</guimenuitem>
                        to start it depending on whether or not a readout program
                        is already running.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
    <section>
        <title>
            Event file organization
        </title>
        <para>
            The Readout GUI works with the event logger to maintain
            a directory structure of event files and associated data.
            You can associate an arbitrary set of files and directory subtrees
            with each run.  Through heavy use of symbolic links, the
            Readout GUI provides you with two views of your data.
        </para>
        <formalpara>
            <title>Events view</title>
            <para>
                The events view presents all of the event files in a single
                directory.  This view allows you to sequentiall analyze
                several runs without the need to move around in the directory
                hierarchy.
            </para>
        </formalpara>
        <formalpara>
            <title>Runs view</title>
            <para>
                This view collects all of the data associated with each run
                into a single directory.
            </para>
        </formalpara>
        <para>
            The top of the directory subtree that is managed by Readout Gui is
            determined by a symbolic link; <filename>~/stagearea</filename>.
            <footnote>
                <para>
                    Environment variables can override this link however and are
                    useful in the event you are using a single account to do
                    multiple tests for which you want to segregate the data.
                </para>
            </footnote>
            This must be created by you when you set the account up for data taking.
        </para>
        <para>
            When Readout GUI runs the first time it will create the directory
            structure it need underneath the directory pointed to by
            <filename>~/stagearea</filename>.
        </para>
        <para>
            The directory tree created looks like this:
        </para>
        <figure>
            <title>Readout GUI Directory tree</title>
            <literallayout><![CDATA[
stagearea +
          +----> experiment+
          |                +---> current
          |                +---> run1
          |                +---> run2
          ...             ...
          +----> complete
          +----> current
            ]]>
            </literallayout>
        </figure>
        <para>
            Let's start with the <filename>~/stagearea/current</filename> directory.
            The Readout GUI arranges for the event file set currently being
            accumulated to be written in this directory.  Event files have the name
            <literal>run-nnnn-ss.evt</literal> where <literal>nnnn</literal> is a
            zero filled run number (e.g. <literal>0001</literal>), and
            <literal>ss</literal> is a zero filled event segment.
        </para>
        <para>
            The event data from each run are segmented into files that are no
            more than 2GBytes long.  The segments number from 00.
        </para>
        <para>
            The <filename>~/stagearea/experiment</filename> subdirectory tree
            provides the run view of the data.  Within that directory are
            subdirectories for each recorded run.  At the end of a run,
            the Readout GUI moves the event data files from the
            <filename>~/stagearea/current</filename> directory into the
            associated run directory.  The data in
            <filename>~stagearea/experiment/current</filename> is copied into
            the run directory as well.  Files or directories pointed to by
            symoblic links in the <filename>experiment/current</filename> subtree
            are copied rather than the links themselves.
        </para>
        <para>
            Finally, the <filename>complete</filename> directory provides the
            events view of the experiment.  At the end of a run, after the
            event file segments copied to <filename>~stagearea/experiment/runn</filename>,
            a symbolic link to each event file segment is created here.
        </para>
    </section>
    <section>
        <title>Customizing Readout Shell</title>
        <para>
            The readout gui is highly customizable.  You can provide Tcl
            code that is called by the Readout Shell and specific times to
            perform application specific operations. An API allows you to
            interact with the Readout GUI through these script extensions.
        </para>
        <para>
            Furthermore, a large number of environment variables allow you
            to configure how the ReadoutGUI operates.
        </para>
        <section>
            <title>ReadoutCallouts.tcl</title>
            <para>
                ReadoutCallouts is a script that you can supply.  When the Readout
                Gui starts it sources all scripts by this name in the following
                directories in order: <filename>~</filename>, <filename>~/experiment/current</filename>,
                and <filename>.</filename>.  The script is sourced at the global
                level.
            </para>
            <para>
                In addition to performing any desired operations as the script
                is initially sourced, if these script define any of the
                following <command>proc</command>s they will be called
                by the Readout GUI at the appropriate time.  Please note that
                Tcl does not support overloading <command>proc</command>names.
                If you want to chain to previously defined instances of those
                procs you'll need to use the <command>rename</command> command
                to rename the old ones and then manually chain to them from your
                code.
            </para>
            <variablelist>
                <varlistentry>
                    <term><command>OnBegin</command> <parameter>runNumber</parameter></term>
                    <listitem>
                        <para>
                            This proc is called by Readout GUI when the run has been
                            started.  By the time this proc is called, the event logger
                            has already started, however the Readout program itself
                            has not yet been told to start the run.
                            As implied by the header above,  the proc receives
                            the current run number as a parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnEnd</command> <parameter>runNumber</parameter></term>
                    <listitem>
                        <para>
                            This proc is called just after a run has neded.  The
                            Readout program has been asked to end the run,
                            however due to the lack of closed loop control
                            between the ReadoutGui and Readout, it is not yet known
                            that the Readout program actually has finished ending
                            the run and sent its end run item to the ring buffer.
                            The proc is parameterized by the number of the run'
                            that is ending.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnPause</command> <parameter>runNumber</parameter></term>
                    <listitem>
                        <para>
                            This proc is called just after a run has paused.
                            The timing for this call is essentially the same as that for
                            <command>OnEnd</command>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnResume</command> <parameter>runNumber</parameter></term>
                    <listitem>
                        <para>
                            This proc is called just after a run has resumed.
                            The timing for this is the same as that for
                            <command>OnStart</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnStart</command></term>
                    <listitem>
                        <para>
                            This proc is called just after the readout program
                            has been asked to start.  There is no gaurentee that
                            by the time OnStart begins executing, the readout
                            program is able to accept and act on commands. It
                            may be appropriate to delay some appropriate time
                            period to allow it to initialize.
                            A common use of this callback is to define
                            run and state variables in a readout framework
                            so that it can log those to file.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The toy extension below logs readout loads, and run state transitions
                to a file <filename>~/readout.log</filename>  The  file
                is opened and appended to for each log operation.
            </para>
            <example>
                <title>ReadoutCallouts.tcl sample extension</title>
                <programlisting>
set filename [file join ~ readout.log]

if {[info procs OnBegin] ne ""} {
    rename OnBegin PreLogger_OnBegin 
}

proc logToFile message {
   global filename
   
   set fd [open $filename "w+"]
   set timestamp [clock format [clock seconds]]
   puts $fd "$timestamp : $message"
   close $fd
}
proc OnBegin run {
   if {[info procs PreLogger_OnBegin] ne ""} {
        PreLogger_OnBegin $run
   }
   logToFile "Run $run Begun"
}
proc OnEnd run {
   logToFile "Run $run has ended"
}
proc OnPause run {
   logToFile "Run $run has been paused"
}
proc OnResume run {
   logToFile "Run $run has been resumed"
}
proc OnStart {} {
   logToFile "Readout program has been started"
}
                    
                </programlisting>
            </example>
            <para>
                The code at the top of the file and the code in
                <command>OnBegin</command> illustrate how to chain to a previously
                defined OnBegin.  As the script starts up, any existing OnBegin
                proc is renamed to <command>PreLogger_OnBegin</command>. If
                OnBegin detects the existence of this proc it is called.
                Obviously this can be extended to any and all of the callback
                functions.
            </para>
        </section>
        <section>
            <title>Environment and configuration variables</title>
            <para>
                ReadoutGUI looks for a large number of environment variables.
                Setting these overrides default values and symbolic links.
                This section describes the set of environment variables that
                are understood by Readout GUI.
            </para>
            <para>
                Readout GUI processes configuration files, then environment
                variables and finally command line parameters where appropriate.
                The cofiguration file is located in
                <filename>~/stagerea/.readoutconfig</filename>.  This contains
                static configuration as a set of Tcl Variables.
                <filename>~/.daqconfig</filename> can contain additional
                static configuration as can <filename>./.daqconfig</filename>.
                In the tables below, the <literal>parameter</literal> column is
                the global Tcl variable to set to modify this parameter in
                a configuration file.
            </para>
            <table frame="all">
                <title>Data Acquisition configuration parameters</title>
                <tgroup cols="3" colsep='1' rowsep='1'>
                    <thead>
                        <row>
                            <entry>Parameter</entry>
                            <entry>Environment variable</entry>
                            <entry>Meaning</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>SourceHost</entry>
                            <entry>DAQHOST</entry>
                            <entry>Name of the system that runs the Readout program.</entry>
                        </row>
                        <row>
                            <entry>ReadoutPath</entry>
                            <entry>RDOFILE</entry>
                            <entry>File system path to the readout program</entry>
                        </row>
                        <row>
                            <entry>EventLogger</entry>
                            <entry>EVENTLOGGER</entry>
                            <entry>Path to an event logger that substitutes
                                for the standard event logger.
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <table>
                <title>Directory root configuration parameters</title>
                <tgroup cols="3" colsep="1" rowsep="1">
                    <thead>
                        <row>
                           <entry>Parameter</entry>
                            <entry>Environment variable</entry>
                            <entry>Meaning</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>StageArea</entry>
                            <entry>EVENTS</entry>
                            <entry>Overrides the symbolic link <filename>~stagearea</filename>
                            if set</entry>
                        </row>
                        <row>
                            <entry>Experiment</entry>
                            <entry>EXPDIRM</entry>
                            <entry>Overrides the root directory where the
                            experiment view is generated.  This defaults to
                            <filename>~/experiment</filename> which if it does
                            not initially exist is linked to an <filename>experiment</filename>
                            directory in the stage area.
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <table>
                <title>State Parameters</title>
                <tgroup cols="3" colsep="1" rowsep="1">
                    <thead>
                        <row>
                           <entry>Parameter</entry>
                            <entry>Environment variable</entry>
                            <entry>Meaning</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>RunTitle</entry>
                            <entry>EXPTITLE</entry>
                            <entry>The title of the run.  This is intended to allow
                            you to provide an initial run title.  It is usually overidden
                            by the value in <filename>.readoutconfig</filename> which
                            is rewritten at the start and end of each run</entry>
                        </row>
                        <row>
                            <entry>RunNumber</entry>
                            <entry>--</entry>
                            <entry>The current run number.  This is far too dynamic
                            to merit an environment variable.
                            </entry>
                        </row>
                        <row>
                            <entry>ScalerCount</entry>
                            <entry>SCALERS</entry>
                            <entry>
                                The value that will be used in the initial
                                <command>set scalers</command> command at the
                                start of the run. The intent of this variable
                                (not much used nowadays). is to allow experiment
                                specific code to bind to it and use its value
                                to determine the number of scalers to read out.
                            </entry>
                        </row>
                        <row>
                            <entry>ScalerInterval</entry>
                            <entry>SCALERINTERVAL</entry>
                            <entry>Value in the <command>set frequency</command>
                                command performed at the beginning of each run.
                                The original intent of this was to allow
                                users to bind to this value and use it to
                                dynamically set the scaler trigger period.
                            </entry>
                        </row>
                        <row>
                            <entry>Recording</entry>
                            <entry> --</entry>
                            <entry>Non zero when the recording checkbox is lit.
                            Like the run number this is too dynamic to merit an
                            environment variable.
                            </entry>
                        </row>
                        <row>
                            <entry>Timed</entry>
                            <entry> -- </entry>
                            <entry>Reflects the state of the timed run checkbox</entry>
                        </row>
                        <row>
                            <entry>TimedLength</entry>
                            <entry> -- </entry>
                            <entry>Number of seconds the time in the timed run
                            length entries reflects.
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
    
        </section>
    </section>
</chapter>

<!-- /chapter -->

<!-- manpage 1daq -->
      <refentry id="manpage_readoutshell">
        <refmeta>
           <refentrytitle id="manpage_readoutshell_title">Readout Gui</refentrytitle>
           <manvolnum>1daq</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>ReadoutShell</refname>
           <refpurpose>Encapsulate data sources in a graphical user interface</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
$DAQROOT/bin/ReadoutShell <optional><option>-host</option>=<replaceable>readout-host</replaceable></optional>
<optional><option>-path</option>=<replaceable>readout-program-path</replaceable></optional>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
                Starts the readout GUI. All of the options on the command line are optional.
                If they are omitted, the program first attempts to fetch them from the
                configuration (see the section Configuration files and environment variables
                below for more information about configuration). If the required information
                cannot be retrieved from the configuration, dialogs will be launched to prompt
                for the host and readout path.
            </para>
            <para>
                The NSCL Data acquisition system uses a specific file directory
                tree to associate event data and any other data that may be
                germane to the run. The ReadoutGUI on startup creates this
                directory structure and enforces it during its operation.
            </para>
            <para>
                The ReadouGui on startup attempts to launch the readout program
                specified on the command line, in the configuration or via
                prompts to the user on the host system specified in the same
                way. It reports unexpected Readout program exits via a dialog
                box to the user.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
                <varlistentry>
                    <term><option>-host</option>=<replaceable>readout-host</replaceable></term>
                    <listitem>
                        <para>
                            Specifies that
                            <parameter>readout-host</parameter>  is the name of the computer
                            on which the Readout program should be run. hostname
                            is also used as the data source to which the readout
                            gui connects other pieces of the system it controls,
                            most importantly, the eventlog event data logging
                            program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-path</option>=<replaceable>readout-program-path</replaceable></term>
                    <listitem>
                        <para>
                            Specifies
                            <parameter>readout-program-path</parameter> as the
                            readout program that should be run.  The path  must
                            be absolute as you cannot make any assumptions about
                            the working directory in which it is resolved.
                            This is an important point that is sometimes missed:
                        </para>
                        <para>
                            Suppose your current working directory is ~/readout
                            and the Readout program is stored in
                            <filename>~/software/readout/Readout</filename>.
                            Specifying the readout program as
                            <filename>../software/readout/Readout</filename>
                            will not work as expected.
                        </para>
                    </listitem>
                </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
            <title>FILES</title>
            <para>
                Several files are read written to maintain both the
                static configuration (not changing from run to run) and the
                last known dynamic configuration (changing from run to run).
                Every effort is made to preserve state so that if you start
                the Readout GUI again after it has exited normally or abnomrally,
                it will return to the state it was when it exited.
            </para>
            <variablelist>
                <varlistentry>
                    <term><filename>~/stagearea/.readoutconfig</filename></term>
                    <listitem>
                        <para>
                            Contains state data for both static and dynamic
                            state.  This is rewritten as dynamic stat is modified.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>.daqconfig</filename></term>
                    <listitem>
                        <para>
                            This file is loaded both from the home directory ansd
                            from your current working directory.  It allows
                            you to finely tune the startup static state of the
                            readout gui.  See CONFIGURATION below for more
                            information about what can be put in this file.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>ReadoutCallouts.tcl</filename></term>
                    <listitem>
                        <para>
                            This file is loaded from the home directory,
                            the experiment view's <filename>current</filename>
                            directory and the current working directory.
                            See EXTENSION hooks below for more information
                            about what this file can contain.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title>CONFIGURATION</title>
            <para>
                The ReadoutGUI has many configuration parameters, although
                normally the default values are suitable for your use.
                The program gets configuration from a combination of
                configuration files, environment variables and default values.
                See FILES above for the set of configuration files.
            </para>
            <para>
                The section below describes the configuration parameters,
                where appropriate the corresponding environment variables and
                the precedence.
            </para>
            <segmentedlist>
                <segtitle>Configuration Parameter</segtitle>
                <segtitle>Environment Variable</segtitle>
                <segtitle>Precedence</segtitle>
                <segtitle>Description</segtitle>
                <seglistitem>
                    <seg>SourceHost</seg>
                    <seg>DAQHOST</seg>
                    <seg>Command line, Environment variable, config files.</seg>
                    <seg>Provides the host in which the readout software is run.
                        This also determines the URL that will be generated to
                        describe to the clients Readout GUI runs where data
                        comes from.
                    </seg>
                </seglistitem>
                <seglistitem>
                    <seg>ReadoutPath</seg>
                    <seg>RDOFILE</seg>
                    <seg>Command line, Environment variable, config files.</seg>
                    <seg>Absolute path to the Readout program.</seg>
                </seglistitem>
                <seglistitem>
                    <seg>StageArea</seg>
                    <seg>EVENTS</seg>
                    <seg>Environment, Config File</seg>
                    <seg>The root directory of the event data. This normally
                         defaults to <filename>~/stagearea</filename>.</seg>
                </seglistitem>
                <seglistitem>
                    <seg>Experiment</seg>
                    <seg>EXPDIR</seg>
                    <seg>Environment, config</seg>
                    <seg>The root of the directory where the run data are stored.
                    This defaults to <filename>~/experiment which,</filename>
                    if it does not initially exist is linked symbolically to
                    <filename>$StageArea/experiment</filename>
                    </seg>
                </seglistitem>
                <seglistitem>
                    <seg>RunTitle</seg>
                    <seg>EXPTITLE</seg>
                    <seg>Config File, Environment</seg>
                    <seg>Title of the run.  This is normally only useful
                    to provide an initial title as it is overidden by any
                    changes the user makes in the GUI.
                    </seg>
                </seglistitem>
                <seglistitem>
                    <seg>RunNumber</seg>
                    <seg>N/A</seg>
                    <seg>Gui, Config file</seg>
                    <seg>The run number of the current run if the run is active,
                    or the next run if the run is idle.</seg>
                </seglistitem>
                <seglistitem>
                    <seg>ScalerCount</seg>
                    <seg>SCALERS</seg>
                    <seg>GUI, Configuration file, Environment</seg>
                    <seg>Value set to the Readout's <varname>scalers</varname>
                    variable prior to starting run initialization.  This can be,
                    but need not be, used by the Readout program to determine how
                    many scaler channels are expected. Whether and how it is used
                    is entirely up tot he application developer(s).
                    </seg>
                </seglistitem>
                <seglistitem>
                    <seg>ScalerInterval</seg>
                    <seg>SCALERINTERVAL</seg>
                    <seg>Gui, Config file, Environment</seg>
                    <seg>Determines the value set in the Readout program's
                    <varname>frequency</varname> variable prior to run initiaization.
                    This can be but need not be used to set the period of the
                    scaler readout trigger.  Whether and how it is used
                    is entirely  up to the application developer(s).
                    </seg>
                </seglistitem>
                <seglistitem>
                    <seg>Recording</seg>
                    <seg>N/A</seg>
                    <seg>GUI, Config file</seg>
                    <seg>If the run is active,this non zero when event data
                    are being recorded. When the run is not active, this
                    variable reflects whether or not the next run will record
                    event data.</seg>
                </seglistitem>
                <seglistitem>
                    <seg>Timed</seg>
                    <seg> N/A</seg>
                    <seg>Gui, Config file</seg>
                    <seg>Reflects whether or not this run (or the next run if
                    idle) will be a timed run</seg>
                </seglistitem>
                <seglistitem>
                    <seg>TimedLength</seg>
                    <seg>N/A</seg>
                    <seg>Gui, Config file</seg>
                    <seg>If the configuration/state parameter <varname>Timed</varname>
                    is true, this variable is the number of seconds for which a
                    timed run should take data.</seg>
                </seglistitem>
            </segmentedlist>
        </refsect1>
        <refsect1>
            <title>EXTENSION HOOKS</title>
            <para>
                The Readout GUI can be extended by user supplied scripts.
                How to provide an extension script is described in
                FILES under the description of <filename>ReadoutCallouts.tcl</filename>.
                This section describes the callbacks ReadoutGUI makes to any
                extension that defines them and the API available to those
                scripts (see Programmatic Inteface below).
            </para>
            <para>
                In addition to executing arbitrary Tcl code at the global level
                when it is loaded, <filename>ReadoutCallouts.tcl</filename> can
                provide <command>proc</command>s that are called at well defined
                points in the execution of the Readout GUI.
            </para>
            <para>
                The callbacks the set of <filename>ReadoutCallouts</filename> can
                provide are:
            </para>
            <variablelist>
                <varlistentry>
                    <term><command>OnStart</command></term>
                    <listitem>
                        <para>
                            Called when the readout program is started up.
                            At the time this is called, the Readout program
                            may not be sufficiently initialized to accept
                            commands.  if your script feeds commands you might
                            want to insert a short delay prior to doing this.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnBegin</command></term>
                    <listitem>
                        <para>
                            This proc is called just after the run has been
                            started. It is passed the run number of the run
                            that has just started. By the time <command>OnBegin</command>
                            is called, the Event Logging program (if recording
                            is enabled) is ready to run. The Readout program has
                            not yet, however, been told to start the run.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnEnd</command></term>
                    <listitem>
                        <para>
                           Called just after a run has ended. The Readout program
                           has been asked to end however it is not known yet
                           that the readout program has actually sent its end
                           of run buffer to the event distribution system.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnPause</command></term>
                    <listitem>
                        <para>
                            Called when a data taking run is being paused. This
                            is called at an analagous time to the OnEnd call.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>OnResume</command></term>
                    <listitem>
                        <para>
                            Called when a data taking run is being resumed.
                            This is called at an analgous time to the OnBegin
                            function.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <refsect2>
                <title>Programmatic Interface</title>
                <para>
                    Readout GUI extension scripts can also interact with well
                    defined interfaces to the Readout GUI.
                    This section describes those interfaces.
                </para>
                <para>
                    The Readout GUI is segmented into several packages.  Each
                    package is implemented as a Tcl package and you should use
                    <command>package require</command> to ensure the package is
                    loaded prior to invoking <command>proc</command>s from the
                    package.
                </para>
                <variablelist>
                    <para>
                        The Readout GUI package your script can use are:
                    </para>
                    <varlistentry>
                        <term>ReadoutState</term>
                        <listitem>
                            <para>
                                Provides the ability to manipulate and inquire
                                about the state of the system.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>ReadoutControl</term>
                        <listitem>
                            <para>
                                Provides the ability to control the readout
                                program.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>ReadoutGui</term>
                        <listitem>
                            <para>
                                Provides the ability to do things that the
                                GUI elements can cause to happen.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>ReadougGUIPanel</term>
                        <listitem>
                            <para>
                                Provides access to the gui elements of the
                                user interface itself.  Note the first
                                <literal>g</literal> in this package name
                                is <emphasis>not</emphasis> a typo.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <refsect3>
                    <title>Programmatic interface</title>
                    <subtitle>ReadoutState package</subtitle>
                    <para>
                        The ReadoutState package manipulates and gets access
                        to various state values of the Readout GUI.  These commands
                        are located in the <literal>ReadoutState</literal> namespace.
                        If you don't want to qualify calls with
                        <literal>ReadoutState::</literal>, you can
                        <command>namespace import ReadoutState::*</command>.
                        The descriptions below assume this has been done.
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><command>setTitle</command> <replaceable>newTitle</replaceable></term>
                            <listitem>
                                <para>
                                    Sets the title string for the next run. Unlike
                                    the GUI, which does not allow title string
                                    changes until the run is halted, the software
                                    can change this string at any time and the new
                                    value will be reflected in the GUI. The Readout
                                    program, however, only receives a new title
                                    string just prior to the start of a run, and
                                    prior to the call to <command>OnBegin</command>.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>setRun</command> <replaceable>runNumber</replaceable></term>
                            <listitem>
                                <para>
                                     Sets the run number for the next run that
                                     Readout will start. See setTitle for for
                                     what this means and when the Readout
                                     program will actually see this setting.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>getRun</command></term>
                            <listitem>
                                <para>
                                    Returns the run number
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>incRun</command></term>
                            <listitem>
                                <para>
                                     Increments the run number held by the GUI.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>setScalerCount</command> <replaceable>scalers</replaceable></term>
                            <listitem>
                                <para>
                                     Sets the number of scalers the user wants
                                     read out. This is updated in the readout
                                     program at the start of the next run. It is
                                     possible for the readout software to
                                     override this value programmtically. It is
                                     intended for scaler readout software that
                                     knows how to use this value to adjust the
                                     set of scalers that are actually being read.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>getScalerCount</command></term>
                            <listitem>
                                <para>
                                     Returns the proposed number of scalers
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>setScalerPeriod</command> <replaceable>timInSeconds</replaceable></term>
                            <listitem>
                                <para>
                                    Sets the number of seconds between timed
                                    scaler readout in seconds.  Note that it
                                    is up to the application code to select
                                    a timed trigger and to modify the time interval
                                    based on this value at the beginning of each
                                    run.  The value will be pushed into the
                                    main interpreter's <varname>frequency</varname>
                                    variable.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>getScalerPeriod</command></term>
                            <listitem>
                                <para>
                                    Returns the number of seconds between
                                    periodic scaler readouts.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>getRecording</command></term>
                            <listitem>
                                <para>
                                     Returns true if event recording is enabled.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>enableRecording</command></term>
                            <listitem>
                                <para>
                                    Enables event recording. As with all of
                                    these parameters, event recording determines
                                    what happens at the start of the next run.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>disableRecording</command></term>
                            <listitem>
                                <para>
                                    Disable event recording.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>isTimedRun</command></term>
                            <listitem>
                                <para>
                                    Returns a true boolean value if the Timed
                                    run checkbox is enabled.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>TimedRun</command></term>
                            <listitem>
                                <para>
                                    Enables the next run to be a timed run.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>notTimedRun</command></term>
                            <listitem>
                                <para>                                   
                                    Says that the next run will not be a timed
                                    run.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>timedLength</command></term>
                            <listitem>
                                <para>
                                    Returns the length of a timed run. The
                                    length is returned as the number of seconds
                                    the run would last.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>setTimedLength</command> <replaceable>seconds</replaceable></term>
                            <listitem>
                                <para>
                                     Sets the length of the timed run in seconds.
                                     You must also enabled timed running in
                                     order for this to mean anything.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect3>
                <refsect3>
                    <title>Programmatic interface</title>
                    <subtitle>ReadoutControl package</subtitle>
                    <para>
                        This package allows you to set and inquire the
                        known state of the Readout program.  You can us it
                        to send arbitrary messages to the readout program
                        or to perform specific state transitions of the run.
                    </para>
                    <para>
                       Where you force a state change in the Readout program
                       that the GUI normally forces (e.g. starting a run), it
                       is important that you use the higher level functions to
                       do that so that the GUI remains consistent with the state
                       of the Readout. If, for example, you start a run by
                       sending the begin command directly to the Readout program,
                       the run control buttons will not reflect that the run can
                       be halted. Use of e.g.
                       <command>ReadoutControl::Begin</command> maintains
                       the state correspondence.
                    </para>
                    <para>
                        All of the procs described in this section are
                        in the <literal>ReadoutControl</literal> namespace.
                        If you don't want to prefix each command with
                        <literal>::ReadoutControl::</literal> you should
                        import the namespace using
                        <command>namespace import ::ReadoutControl::*</command>.
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><command>getReadoutState</command></term>
                            <listitem>
                                <para>
                                     Returns the known state of the readout program.
                                     This can be any of the following textual values:
                                </para>
                                <variablelist>
                                    <varlistentry>
                                        <term><literal>NotLoaded</literal></term>
                                        <listitem>
                                            <para>
                                                The Readout program is not running.
                                                Either it was never started, or it
                                                failed.
                                            </para>
                                        </listitem>
                                    </varlistentry>
                                    <varlistentry>
                                        <term><literal>NotRunning</literal></term>
                                        <listitem>
                                            <para>
                                                The Readout program is present, but
                                                the run is in the halted state.
                                            </para>
                                        </listitem>
                                    </varlistentry>
                                    <varlistentry>
                                        <term><literal>Paused</literal></term>
                                        <listitem>
                                            <para>
                                                The readout program has an active
                                                run that is currently paused.
                                            </para>
                                        </listitem>
                                    </varlistentry>
                                    <varlistentry>
                                        <term><literal>Active</literal></term>
                                        <listitem>
                                            <para>
                                                The readout program has an active
                                                run and is taking data.
                                            </para>
                                        </listitem>
                                    </varlistentry>
                                </variablelist>
                            </listitem>
                        </varlistentry>                    
                        <varlistentry>
                            <term><command>isExecuting</command></term>
                            <listitem>
                                <para>
                                     Returns a
                                     <literal>true</literal>
                                     boolean value if the Readout
                                     program is executing. That is if
                                     <command>ReadoutControl::getReadoutState</command>
                                     would not return
                                     <literal>NotLoaded</literal>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>SendCommand</command> <replaceable>string</replaceable></term>
                            <listitem>
                                <para>
                                     Sends a literalcommand to the readout program.
                                     In the case of the SBS Readout skeleton
                                     you might use this in e.g.
                                     <command>OnStart</command>
                                     to force the readout program to source some
                                     configuration script.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>SetReadoutProgram</command> <replaceable>host path</replaceable></term>
                            <listitem>
                                <para>
                                   Determines which readout program will be run
                                   next, and on which system. host specifies the
                                   target processor, and path should be the full
                                   absolute path to the program. If you have a
                                   relative path you can use the Tcl
                                   <command>file normalize</command>
                                   command to turn it into an absolute path.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>ExitReadoutProgram</command></term>
                            <listitem>
                                <para>
                                     Forces the readout program to exit. T
                                     his is done as follows:
                                     <orderedlist>
                                        <listitem><para>The 
                                        <command>end</command>
                                        command is sent to the program.
                                        </para></listitem>
                                        <listitem><para>The
                                        <command>exit</command>
                                        command is sent to the program.
                                        </para></listitem>
                                        <listitem><para>The pipe open to the
                                        readout program is closed.
                                        </para>
                                        </listitem>
                                     </orderedlist>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>StartReadoutProgram</command></term>
                            <listitem>
                                <para>
                                   Starts the readout program using the current
                                   target host and path. If the readout program
                                   is running it is stopped. This means that to
                                   programmatically change readout programs you
                                   can do something like this:
                                   <informalexample>
                                    <programlisting>
package require ReadoutControl

set newProgram ~/daq/Readout/Readout
set host       spdaq22
ReadoutControl::SetReadoutProgram $host [file normalize $newProgram]
ReadoutControl::StartReadoutProgram
                                    </programlisting>
                                   </informalexample>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>SetRun</command> <replaceable>runNumber</replaceable></term>
                            <listitem>
                                <para>
                                     Sends a command to the readout program to
                                     set the run number to number. You should
                                     normally use the functions in the package
                                     ReadoutState to do this, in order to maintain
                                     synchronization between the GUI and the
                                     Readout program state.
                                </para>
                                <para>
                                    If the ReadoutGui believes the readout
                                    program is in the
                                    <literal>NotRunning</literal> state, an
                                    error will be thrown.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>SetTitle</command> <replaceable>newTitleString</replaceable></term>
                            <listitem>
                                <para>
                                    Sends a message to the readout program to
                                    change its title. You should normally use
                                    the functions in the package ReadoutState to
                                    do this, in order to maintain synchronization
                                    between the GUI and the Readout program state.
                                </para>
                                <para>
                                     If the ReadoutGui believes the readout
                                     program is not in the
                                     <literal>NotRunning</literal>
                                     state, an error will be thrown.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>Begin</command></term>
                            <listitem>
                                <para>
                                    Sends a message to the readout software to
                                    start a run. You should normally use the
                                    functions in the package ReadoutState to do
                                    this, in order to maintain synchronization
                                    between the GUI and the Readout program state.
                                </para>
                                <para>
                                    If the ReadoutGui believes the readout
                                    program is not in the
                                    <literal>NotRunning</literal>
                                    state, an error will be thrown.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>End</command></term>
                            <listitem>
                                <para>
                                    Sends a message to the readout software
                                    ending any active run. You should normally
                                    use the functions in the package ReadoutState
                                    to do this, in order to maintain synchronization
                                    between the GUI and the Readout program state.
                                </para>
                                <para>
                                    If the ReadoutGui believes the readout
                                    program is in the
                                    <literal>NotRunning</literal>
                                    state, an error will be thrown.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>Pause</command></term>
                            <listitem>
                                <para>
                                    Pauses any active run. You should normally
                                    use the functions in the package ReadoutState
                                    to do this, in order to maintain synchronization
                                    between the GUI and the Readout program state.
                                </para>
                                <para>
                                    If the ReadoutGui believes the readout
                                    program is not in the
                                    <literal>Active</literal> state, an error will be thrown.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>Resume</command></term>
                            <listitem>
                                <para>
                                    Sends a message to the readout software to
                                    resume a paused run. You should normally use
                                    the functions in the package ReadoutState to
                                    do this, in order to maintain synchronization
                                    between the GUI and the Readout program state.
                                </para>
                                <para>
                                    If the ReadoutGui believes the readout
                                    program is not in the <literal>Paused</literal>
                                    state, an error will be thrown.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist> 
                </refsect3>
                <refsect3>
                    <title>Programmatic interface</title>
                    <subtitle>ReadoutGUI package</subtitle>
                    <para>
                        This package provides access to the functions that
                        the graphical user interface itself calls in response
                        to button pushes.  Often using these methods is the
                        safest way to do something as gthen you are duplicating the
                        action of the GUI elements.
                    </para>
                    <para>
                        All procs described here are in the
                        <literal>ReadoutGui::</literal> namespace.  If you don't
                        want to have to precede each function name with
                        <literal>::ReadoutGUI</literal>, use
                        <command>namespace import ::ReadoutGui::*</command>
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><command>Start</command></term>
                            <listitem>
                                <para>
                                    Simulates the
                                    <guimenu>File</guimenu>&#8594;<guisubmenu>Start</guisubmenu>
                                    menu selection. The Readout program selected
                                    is started on the target host without any
                                    attempt to stop any existing Readout.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>Restart</command></term>
                            <listitem>
                                <para>
                                     Simulates the
                                     <guimenu>File</guimenu>&#8594;
                                     <guisubmenu>Restart</guisubmenu>
                                     menu choice. This attempts to stop an
                                     existing Readout program before starting a
                                     new instance of the selected Readout program
                                     in the target host.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>Begin</command></term>
                            <listitem>
                                <para>
                                    Simulates a press of the Begin button. This
                                    attempts to start a run. Note that
                                    programmatically, there are no protections
                                    at this level against beginning a run that
                                    is already running. You should inquire the
                                    state of the system prior to attempting to
                                    start a run. For example:
                                </para>
                                <informalexample>
                                    <programlisting>

if {[ReadoutControl::getReadoutState] eq "NotRunning"} {
   ReadoutGui::Begin
} else {
   # Here recover from the fact that the run
   # Cannot be started at this point in time.
}
                                    </programlisting>
                                </informalexample>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>Pause</command></term>
                            <listitem>
                                <para>
                                    Simulates a press of the
                                    <guibutton>Pause</guibutton> button.
                                    as for <command>Begin</command> the state
                                    should be checked to ensure it is
                                    <literal>Active</literal> before invoking this.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>Resume</command></term>
                            <listitem>
                                <para>
                                    Simulates a click of the
                                    <guibutton>Resume</guibutton> button.
                                    Call <command>getState</command> to ensure
                                    the state is <literal>Paused</literal>
                                    before invoking this.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>End</command></term>
                            <listitem>
                                <para>
                                   Simulates a click of the
                                   <guibutton>End</guibutton> button. As before,
                                   ensure this is legal by comparing the return value of
                                   <command>getState</command> to either
                                   <literal>Paused</literal> or
                                   <literal>Active</literal>> (paused runs can
                                   be ended without resumption.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                </refsect3>
                <refsect3>
                    <title>Programmatic interface</title>
                    <subtitle>Controllling the GUI</subtitle>
                    <para>
                        The <literal>ReadougGUIPanel</literal> package
                        provides access to the graphical user interfaces
                        that make up the readout gui.  YOu can use this to
                        modify the state of existing widgets as well as to
                        add new widges of your own to the GUI.
                    </para>
                    <para>
                        All functions in this section  are in the
                        namespace <literal>ReadougGUIPanel</literal>.
                        To avoid needing to qualify each reference you can:
                        <command>namespace import ::ReadougGUIPanel::*</command>.
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><command>addUserMenu</command> <replaceable>ident label</replaceable></term>
                            <listitem>
                                <para>
                                    Allows you to add a user menu to the menubar
                                    of the GUI. The
                                    <replaceable>ident</replaceable> parameter is used as
                                    the last element of the menu widget path.
                                    <replaceable>label</replaceable> is the
                                    text string that will label the element.
                                </para>
                                <para>
                                    The actual full widget path of the menu
                                    created is returned. You can use this path
                                    to modify the menu configuration or to add
                                    elements to the menu.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>addUserFrame</command> <replaceable>ident</replaceable></term>
                            <listitem>
                                <para>
                                    Adds a frame to the bottom of the panel
                                    (you can add as many user frames as you want).
                                    By frame we mean a Tk frame widget.
                                    <replaceable>ident</replaceable>
                                    is the last element of the frame's widget
                                    path. The full path will be returned.
                                </para>
                                <para>
                                    At this time, the frame will span the width
                                    of the Readout GUI toplevel widget. Once
                                    you have created this frame you can stock
                                    it with whatever widgets you want. The
                                    example below is a bit silly.
                                </para>
                                <informalexample>
                                    <programlisting>

set frame [ReadougGUIPanel::addUserFrame myframe]
button $frame.beep -text Beep -command {puts beep}
button $frame.bop  -text Bop  -command {puts bop}
button $frame.beebop -text BeeBop -command {puts "Now that's rockin'"}
grid $frame.beep $frame.bop
grid $frame.beebop
                                    </programlisting>
                                </informalexample>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>getHost</command></term>
                            <listitem>
                                <para>
                                    Returns the host in which the readout program will be, or is running
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>getPath</command></term>
                            <listitem>
                                <para>
                                    Returns the path to the readout program that
                                    will be, or is running in the target host.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>setTitle</command> <replaceable>newTitle</replaceable></term>
                            <listitem>
                                <para>
                                    Sets the title string in the ReadoutGUI widget to
                                    <replaceable>newTitle</replaceable>.
                                    If a run is started via the GUI,
                                    <replaceable>newTitle</replaceable>
                                    will be the title of that run.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>getTitle</command></term>
                            <listitem>
                                <para>
                                    Returns the contents of the title widget in
                                    the GUI. Unless manually, or programmatically
                                    modified, this is the title of the next or
                                    current run.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>getRunNumber</command></term>
                            <listitem>
                                <para>
                                    Returns the contents of the run number widget.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>setRun</command> <replaceable>newRunNumber</replaceable></term>
                            <listitem>
                                <para>
                                    Sets the run number widget contents to
                                    <replaceable>newRunNumber</replaceable>
                                    this will be the run number for the next run.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>incrRun</command></term>
                            <listitem>
                                <para>
                                    Increments the run number (adds one to it).
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>setHost</command> <replaceable>hostname</replaceable></term>
                            <listitem>
                                <para>
                                    Sets the target host for the readout program to
                                    <replaceable>hostname</replaceable>.
                                    The next time the readout program is started,
                                    it will be run in
                                    <replaceable>hostname</replaceable>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>setPath</command> <replaceable>path</replaceable></term>
                            <listitem>
                                <para>
                                    Sets a new readout program to
                                    <replaceable>path</replaceable>.
                                    It is safest if this is the full path to the
                                    program or script to run. The file normalize
                                    command can be used to turn relative paths
                                    into absolute paths. For example:
                                </para>
                                <informalexample>
                                    <programlisting>

set absolutePath [file normalize ../Readout]
ReadougGUIPanel::setPath $absolutePath
                                    </programlisting>
                                </informalexample>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>recordOff</command></term>
                            <listitem>
                                <para>
                                    Turns off the Record checkbutton. Unless
                                    modified, the next run will not be recorded
                                    to disk.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>recordOn</command></term>
                            <listitem>
                                <para>
                                     Turns on the Record checkbutton. Unless
                                     modified, the next run will be recorded to
                                     disk.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>setScalers</command> <replaceable>channels period</replaceable></term>
                            <listitem>
                                <para>
                                    Sets the hint of the number of scalers and
                                    the scaler readout period. Unless modified,
                                    these parameter are fed to the readout
                                    program at the start of the next run.
                                    <replaceable>period</replaceable> is the
                                    integer number of seconds between scaler
                                    trigger. <replaceable>channels</replaceable>
                                    is the number of channels requested.
                                </para>
                                <para>
                                    Note that in the SBS readout framework it
                                    is up to application specific code to do
                                    something with these numbers.  The
                                    VM-USB and CC-USB frameworks configure the
                                    scaler readout period in the configuration
                                    file when setting up the scaler stack.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>getScalers</command></term>
                            <listitem>
                                <para>                                   
                                    Returns a two element list containing the
                                    ReadoutGui's understanding of the
                                    number of scalers to be read and the interval
                                    in seconds between scaler readouts.
                                </para>
                                <para>
                                    Once again these numbers could be completely
                                    meaningless depending on the use made of them
                                    by specific readout frameworks and any
                                    application specific code that may be
                                    grafted into those frameworks.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>recordData</command></term>
                            <listitem>
                                <para>
                                    Returns a
                                    <literal>true</literal>
                                    value if the Record checkbutton is checked.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>outputText</command> <replaceable>text</replaceable></term>
                            <listitem>
                                <para>
                                     Appends text to the GUI's text window. This
                                     window contains the output from the readout
                                     program as well as anything else put there
                                     via this call.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>isTimed</command></term>
                            <listitem>
                                <para>
                                    Returns a
                                    <literal>true</literal>
                                    value if the Timed Run check box is checked.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>setTimed</command> <replaceable>state</replaceable></term>
                            <listitem>
                                <para>
                                    Sets the Timed Run check button to
                                    <replaceable>state</replaceable>.
                                    This governs whether or not the next run is
                                    a timed run.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>getRequestedRunTime</command></term>
                            <listitem>
                                <para>
                                    Returns the length of a timed run if the
                                    Timed Run were set at the start of the run.
                                    The time is returned in seconds
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>setRequestedRunTime</command> <replaceable>seconds</replaceable></term>
                            <listitem>
                                <para>
                                   Sets the desired timed run duration to 
                                   <replaceable>seconds</replaceable>.
                                   This does not modify the state of the Timed
                                   Run check button however.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect3>
                
            </refsect2>
        </refsect1>
        <refsect1>
            <title>EXAMPLE</title>
            <para>
                The toy extension below logs state transitions and
                Readout startups to file.
            </para>
            <example>
                <title>Logging extension to readout gui</title>
                <programlisting>

set filename [file join ~ readout.log]

proc logToFile message {
   global filename
   
   set fd [open $filename "w+"]
   set timestamp [clock format [clock seconds]]
   puts $fd "$timestamp : $message"
   close $fd
}
proc OnBegin run {
   logToFile "Run $run Begun"
}
proc OnEnd run {
   logToFile "Run $run has ended"
}
proc OnPause run {
   logToFile "Run $run has been paused"
}
proc OnResume run {
   logToFile "Run $run has been resumed"
}
proc OnStart {} {
   logToFile "Readout program has been started"
}
                </programlisting>
            </example>
        </refsect1>
      </refentry>

<!-- /manpage -->
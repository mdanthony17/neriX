
#
#   Test suite for the Experiment package.
#   Note that some of this package may not be automatically testable
#   due to environmental constraints.  This is noted
#   in the comments preceding the 'tests that are not there.'
set here [file dirname [info script]]

# starting to just get too tough to do this without
# packaging:
package require tcltest

set auto_saved $auto_path
lappend auto_path $here
if {[file exists pkgIndex.tcl]} {
    file delete              pkgIndex.tcl.saved
    file rename pkgIndex.tcl pkgIndex.tcl.saved
}
pkg_mkIndex . *.tcl


#  Dummy packages:
#   We'll implement stubs as needed for the
#   procs used by the module under test.
#
package provide InstallRoot    0.0
package provide ReadoutControl 0.0
package require Diagnostics


#  Dummy package stubs:
#
namespace eval InstallRoot {}
proc InstallRoot::Where {} {
    global here
    return $here
}

set warningCalled 0

namespace eval Diagnostics {}
proc Diagnostics::Warning {args} {
    global warningCalled
    incr warningCalled
}
namespace eval ReadoutControl {}
namespace eval Diagnostics {}

package require Experiment
package require ExpFileSystemConfig
package require ExpFileSystem
package require DAQParameters


# Utility procs:
#

proc createTestStageArea {} {
    global env

    file delete -force stagearea]
    set top [ tcltest::makeDirectory stagearea]
    set env(EVENTS) $top
    set env(EXPDIR) [file join $env(EVENTS) .. experiment]

    ExpFileSystemConfig::setDefaults

    ExpFileSystemConfig::environmentOverrides


    DAQParameters::setDefaults


    # Make the directories and the event file.

    if {[catch {ExpFileSystem::CreateHierarchy} msg]} {
        puts "Could not create hierarchy: $msg"
    }

}

proc cleanupTestStageArea {} {
    global env

    file delete $env(EXPDIR)
    tcltest::removeDirectory $env(EVENTS)
}

proc makeTestRundirs {runs} {
    foreach run $runs {
        tcltest::makeDirectory [ExpFileSystem::WhereisRun $run]
    }
}

proc makeCurrentEventFile {run} {

    global env

    createTestStageArea

    #Make the event file

    set name [format run%d-4096.evt $run]

    set testfile [ tcltest::makeFile {} [file join $env(EVENTS)  current $name]]

    return $testfile
}

proc makeEventFileSet {run segments} {

    # Segment 0 is just a 'normal event file':

    set firstSegment [makeCurrentEventFile $run]
    set directory    [file dirname $firstSegment]

    for {set i 1} {$i < $segments} {incr i} {
       set name [ExpFileSystem::GenRunFile $run $i]
       tcltest::makeFile {} [file join $directory $name]
    }

}


#  Test the ability to create spectrodaq URL's.
#  There's a branch of the code that can't be tested
#  because we don't want to flip the /etc/services file.

tcltest::test Experiment-1.0 {Experiment::spectrudaqURL} {
    Experiment::spectrodaqURL localhost
} {tcp://localhost:2602/}

# Test waitFile:

tcltest::test Experiment-2.0 {Experiment::waitFile - file never shows up} {
    set result [Experiment::waitFile testfile 100 10]
} 0
tcltest::test Experiment-2.1 {Experiment::waitFile - file initially there:} {
    set name   [tcltest::makeFile {} testfiledoesnotexist]
    set result [Experiment::waitFile $name]
    tcltest::removeFile $name
    set result
} 1
tcltest::test Experiment-2.2 {Experiment::waitFile - file shows up later} {
    set name [tcltest::makeFile {} testfile];   # just to get path.
    tcltest::removeFile $name

    exec /bin/sh << "sleep 1; touch $name"

    set result [Experiment::waitFile $name 1000 5]

    file delete $name
    set result
} 1

#  Test makeEventLink  create stagearea directory for this.

tcltest::test Experiment-3.0 {Experiment::makeEventLink} {
    global env

    set testfile [makeCurrentEventFile 1]

    # Now we can run the function:

    Experiment::makeEventLink 1

    #  Checkby reading the link:

    set target [file readlink [file join $env(EVENTS) experiment  current run1-4096.evt]]

    #cleanup

    cleanupTestStageArea

    # check result

    string compare $target $testfile

} 0

# Tests for the callback function:

tcltest::test Experiment-4.0  {Experiment::callback - nosuch sub gives no error} {
    catch {Experiment::callback nosuchfunction 1}
} 0

proc Experiment::testcallback {run} {
    return $run;           # Will propagate back.
}
tcltest::test Experiment-4.1 {Experiment::callback - sub that returns run number} {
    Experiment::callback Experiment::testcallback 1234
} 1234

# Biggest run

tcltest::test Experiment-5.0 {Experiment::BiggestRun - no runs yet}   {
    createTestStageArea

    set result [Experiment::BiggestRun]

    cleanupTestStageArea

    set result
} 0
tcltest::test Experiment-5.1 {Experiment::BiggestRun - runs 0-4 contiguous}  {
    createTestStageArea

    makeTestRundirs [list 0 1 2 3 4]

    set result [Experiment::BiggestRun]

    cleanupTestStageArea

    set result
} 5
tcltest::test Experiment-5.2 {Experiment::BiggestRun - run0 run70 only}  {
    createTestStageArea
    makeTestRundirs [list 0 70]
    set result [Experiment::BiggestRun]
    cleanupTestStageArea
    set result
} 71


# Tests for finalizeEventData
#

tcltest::test Experiment-6.0 {Experiment::finalizeEventData only the event file} {

    set path [makeCurrentEventFile 2];      # Run 2.

    Experiment::finalizeEventData 2

    # We should have:
    #   - An empty current dir.
    #   - A run2 subdir in experiment
    #   - the event file in experiment.
    #   - A link in complete -> Event file in experiment.

    set tempStage [ExpFileSystem::WhereisCurrentEventData]
    set result 1;     # Everything will be just fine!!
    if {[glob -nocomplain [file join $tempStage run*]] != ""} {
        set result [list temp stage is not empty]
    }
    set runFile [ExpFileSystem::WhereisRunFile 2]
    if {![file exists $runFile]} {
        set result [list run event file $runFile missing]
    }
    set complete [ExpFileSystem::WhereareCompleteEventFiles]
    set name     [ExpFileSystem::GenRunFile 2]
    set completeFile [file join $complete $name]
    if {[catch {file readlink $completeFile} msg]} {
        set result [list link in complete could not be read $msg]
    } else {
        if {$msg != $runFile} {
            set result [list link in complet is bad reads $msg sb $runFile]
        }
    }

    cleanupTestStageArea
    set result
} 1
tcltest::test Experiment-6.1 {Experiment::finalizeEventData regular file in experiment/current}  {
    set path    [makeCurrentEventFile 3]
    set current [ExpFileSystem::WhereisCurrentData]
    set regular [ tcltest::makeFile {} [file join $current emptyFile]]

    Experiment::finalizeEventData 3

    # We assume everything from test 6.0 is still good.  Just need to check that our
    # emptyFile made it into the run dir:

    set rundir [ExpFileSystem::WhereisRun 3]
    set fullpath [file join $rundir [file tail $regular]]
    # Must exist:

    if {![file exists $fullpath]} {
        set result [list $fullpath could not be found.]
    } else {
        # Must be regular.

        if {![file isfile $fullpath]} {
            set result [list $fullpath is not a regular file]
        }
    }

    cleanupTestStageArea
    set result
} 1

tcltest::test Experiment-6.2 {Experiment::finalizeEventData symlink in experiment/current} {
    set path    [makeCurrentEventFile 4]
    set current [ExpFileSystem::WhereisCurrentData]
    set contents {Test data}
    set regular [ tcltest::makeFile $contents testdata]
    set link    [file join $current testdata]
    exec ln -s $regular $link

    Experiment::finalizeEventData 4

    # We assume that everything from 6.0, 6.1 is good.
    # Need to check that:
    #   - The run directory has a regular file named testdata
    #   - The contents of this file are $contents.
    #

    set rundir [ExpFileSystem::WhereisRun 4]
    set result 1
    set filename [file join $rundir testdata]
    if {![file exists $filename] } {
        set result [list $filename does not exist]
    } else {
        if {![file isfile $filename]} {
            set result [list $filename is not regular]
        } else {
            set fd [open $filename r]
            set data [read -nonewline $fd]
            close $fd
            if {$contents != $data} {
                set result {Data mismatch: is $data sb $contents}
            }
        }
    }

    # Cleanup:

    cleanupTestStageArea
    tcltest::removeFile $regular

    set result
} 1

tcltest::test Experiment-6.3 {Experiment::finalizeEventData nonempty dir in experiment/current}  {
    set path    [makeCurrentEventFile 5]
    set current [ExpFileSystem::WhereisCurrentData]
    set subdir  [file join $current subdir]
    tcltest::makeDirectory $subdir
    tcltest::makeFile {something} [file join $subdir testfile]

    Experiment::finalizeEventData 5

    # Assuming 6.0 - 6.2 work.  We just need to see that there's a file named
    # testfile in the subdir of the rundir.

    set rundir [ExpFileSystem::WhereisRun 5]
    set name [file join $rundir subdir testfile]

    if {[file exists $name]} {
        set result 1
    } else {
        set result [list $name does not exist]
    }


    # Cleanup etc:

    cleanupTestStageArea
    set result
} 1
tcltest::test Experiment-6.4 {Experiment::finalizeEventData sequence of event file} {
    makeEventFileSet 6 5;  # Run 6 with 5 segments.

    Experiment::finalizeEventData 6

    # Need to find all my files:

    set dir [ExpFileSystem::WhereisRun 6]
    set result 1
    for {set i 0} {$i < 5} {incr i} {
        set file [file join $dir [ExpFileSystem::GenRunFile 6 $i]]
        if {![file exists $file]} {
            set result [list no such file: $file]
            break
        }
    }
    cleanupTestStageArea

    set result

} 1

#  I cannot figure out how to test RunBeginning automatically as
#  it depends too heavily on starting the event logger.
#  In case tests can be figured out, Major  test 7.x is reserved
#  for these tests.

tcltest::test Experiment-7.x {Experiment::RunBeginning} {emptyTest} {
} 1

# Test RunEnded

set endrunCallout 0
tcltest::test Experiment-8.0 {Experiment::RunEnded - recording off} {
    global endrunCallout
    set endrunCallout 0

    createTestStageArea

    #  The following are ReadoutControl stubs for procs called
    # by RunEnded:

    proc ReadoutControl::GetRun {} {
        return 123
    }
    proc ReadoutControl::isTapeOn {} {
        return 0
    }
    proc OnEnd {run} {
        global endrunCallout
        set endrunCallout 1
    }
    Experiment::RunEnded

    cleanupTestStageArea

    #   The only thing that happens on end run with recording off is
    #  the callout:



    set endrunCallout
} 1


tcltest::test Experiment-8.1 {Experiment::RunEnded - recording on .done exists}  {
    global warningCalled
    createTestStageArea
    set warningCalled 0

    proc ReadoutControl::GetRun {} {
        return 456
    }
    proc ReadoutControl::isTapeOn {} {
        return 1
    }
    proc OnEnd {run} {}


    set file [ tcltest::makeFile {} .done]
    Experiment::RunEnded
    cleanupTestStageArea

    set warningCalled
} 0

tcltest::test Experiment-8.2 {Experiment::RunEnded - recording on .done never exists}  {
    global warningCalled
    createTestStageArea
    set warningCalled 0
    set Experiment::fileWaitTimeout 2

    proc ReadoutControl::GetRun {} {
        return 789
    }
    proc ReadoutControl::isTapeOn {} {
        return 1
    }
    proc OnEnd {run} {}

    Experiment::RunEnded
    cleanupTestStageArea

    set warningCalled

} 1


#  Test run paused/run resumed.. readoutstarting.. these just call callbacks.
#
#
set callbackCalled 0

proc OnPause {run} {
    global callbackCalled
    incr callbackCalled
}
proc OnResume {run} {
    global callbackCalled
    incr   callbackCalled
}
proc OnStart {} {
    global callbackCalled
    incr   callbackCalled
}
tcltest::test Experiment-9.0 {Experiment::RunPaused} {
    global callbackCalled
    set callbackCalled 0
    Experiment::RunPaused

    set callbackCalled


} 1
tcltest::test Experiment-9.1 {Experiment::RunResuming} {
    global callbackCalled
    set    callbackCalled 0
    Experiment::RunResuming

    set callbackCalled
} 1

tcltest::test Experiment-9.2 {Experiment::ReadoutStarting} {
    global callbackCalled
    set    callbackCalled 0
    Experiment::ReadoutStarting

    set callbackCalled
} 1

#  Test ability to see if a run file exists

tcltest::test Experiment-10.0 {Experiment::RunFileExists when it doesn't} {
    createTestStageArea
    set result [Experiment::RunFileExists 5]
    cleanupTestStageArea

    set result
} 0

tcltest::test Experiment-10.1 {Experiment::RunFileExists when it does} {
    makeTestRundirs 1
    tcltest::makeFile {} [ExpFileSystem::WhereisRunFile 1]
    set result [Experiment::RunFileExists 1]
    cleanupTestStageArea
    set result
} 1

# Cleanup

file delete pkgIndex.tcl
if {[file exists pkgIndex.tcl.saved]} {
    file rename pkgIndex.tcl.saved pkgIndex.tcl
}
set auto_path $auto_saved

package forget Experiment
package forget ExpFileSystem
package forget ExpFileSystemConfig
package forget DAQParameters
package forget InstallRoot
package forget ReadoutControl
package forget Diagnostics

tcltest::cleanupTests

#!/usr/bin/tclsh
#
#   This file contains tests for scripts and packages in this directory.
#
package require tcltest
set here [file dirname [info script]]

# starting to just get too tough to do this without
# packaging:

set auto_saved $auto_path
# lappend auto_path $here
set auto_path [concat $here $auto_path]
if {[file exists pkgIndex.tcl]} {
    file delete              pkgIndex.tcl.saved
    file rename pkgIndex.tcl pkgIndex.tcl.saved
}
pkg_mkIndex . *.tcl

package require ReadoutControl 2.0
package require ReadoutState
package require DAQParameters

ReadoutState::setDefaults
DAQParameters::setDefaults

# 1.x  Tests PathFind:
#    0   - No such file.
#    1   - Path exists.
# Assumptions:  here is the cwd.
#
tcltest::test ReadoutControl-1.0 {ReadoutControl::PathFind - no such file} {
    ReadoutControl::PathFind {Ron Fox did not make this file}
} {}

tcltest::test ReadoutControl-1.1 {ReadoutControl::PathFind - file exists} {
    global here
    set filename pathfindfile.testdata
    set file [tcltest::makeFile {} [file join $here $filename]]
    set result [ReadoutControl::PathFind $filename]
    tcltest::removeFile $file

    list [file dirname $result] [file tail $result]

} [list $here pathfindfile.testdata]


# 2.x tests isExecuting
#   0  - not executing
#   1  - executing

tcltest::test ReadoutControl-2.0 {ReadoutControl::isExecuting - is not} {
    set oldvalue $::ReadoutControl::State
    set ::ReadoutControl::State NotLoaded

    set result [::ReadoutControl::isExecuting]
    set ::ReadoutControl::State $oldvalue
    set result
} 0

tcltest::test ReadoutControl-2.1 {ReadoutControl::isExecuting - is} {
   set oldvalue $::ReadoutControl::State
    set ::ReadoutControl::State Inactive

    set result [::ReadoutControl::isExecuting]
    set ::ReadoutControl::State $oldvalue
    set result
} 1

# 3.x tests SendCommand - We can send data to a file!
#    0   - Send with no callback.
#    1   - Send with callback.


tcltest::test ReadoutControl-3.0  {ReadoutControl::SendCommand - no callback} {
    set file [tcltest::makeFile {} sendcommand.output]
    set fd [open $file w]
    set oldfd $ReadoutControl::PipeFd
    set ReadoutControl::PipeFd $fd
    set oldcallback $::ReadoutControl::CommandCallback
    set ReadoutControl::CommandCallback ::ReadoutControl::CmdNoOp

    ::ReadoutControl::SendCommand {Hello World}

    close $fd
    set ReadoutControl::CommandCallback $oldcallback
    set fd [open $file r]
    gets  $fd line
    close $fd
    set ReadoutControl::PipeFd $oldfd

    tcltest::removeFile $file

    set line


} {Hello World}

set callbacks 0
set cbline      ""
proc commandCallback {data} {
    global callbacks
    global cbline

    incr callbacks
    set cbline $data
}
tcltest::test ReadoutControl-3.1 {ReadoutControl:: - callback} {
    global cbline
    global callbacks

    set cbline ""
    set callbacks 0

    set file [tcltest::makeFile {} sendcommand.output]
    set fd [open $file w]
    set oldfd $ReadoutControl::PipeFd
    set ReadoutControl::PipeFd $fd
    set oldcallback $::ReadoutControl::CommandCallback
    set ReadoutControl::CommandCallback ::commandCallback

    ::ReadoutControl::SendCommand {Hello World}

    close $fd
    set ReadoutControl::CommandCallback $oldcallback
    set fd [open $file r]
    gets  $fd line
    close $fd
    set ReadoutControl::PipeFd $oldfd

    tcltest::removeFile $file

    list $callbacks $cbline
} [list 1 {Hello World}]

#  4.x tests ReadoutFileEvent:
#     .0 Callback and not eof.
#     .1 Callback and eof.
#
proc testInputCb {fd} {
    global cbline
    global callbacks

    incr callbacks
    gets $fd cbline
}
tcltest::test ReadoutControl-4.0 {ReadoutControl::ReadoutFileEvent not eof} {
    global cbline
    global callbacks

    set cbline ""
    set callbacks 0

    set testFilename rdofileevent.input
    set oldcb $ReadoutControl::InputCallback
    set oldfd $ReadoutControl::PipeFd]
    set filename [tcltest::makeFile {Howdy world} $testFilename]
    set ReadoutControl::PipeFd [open $filename r]
    set ReadoutControl::InputCallback ::testInputCb

    ReadoutControl::ReadoutFileEvent

    set $ReadoutControl::InputCallback $oldcb
    close $ReadoutControl::PipeFd
    set $ReadoutControl::PipeFd        $oldfd
    tcltest::removeFile $testFilename

    list $callbacks $cbline
} [list 1 {Howdy world}]

set priorstate Unknown
proc testExitCallback state {
    global priorstate
    set priorstate $state
}

tcltest::test ReadoutControl-4.1 {ReadoutControl::ReadoutFileEvent  eof} {
    global cbline
    global callbacks
    global priorstate

    set cbline ""
    set callbacks 0

    set testFilename rdofileevent.input
    set oldcb $ReadoutControl::InputCallback
    set oldecb $ReadoutControl::ExitCallback
    set oldfd $ReadoutControl::PipeFd]
    set filename [tcltest::makeFile {} $testFilename]
    exec cat $filename
    set ReadoutControl::PipeFd [open $filename r]
    set ReadoutControl::InputCallback ::testInputCb
    set ReadoutControl::ExitCallback  ::testExitCallback

    ReadoutControl::ReadoutFileEvent
    ReadoutControl::ReadoutFileEvent
    ReadoutControl::ReadoutFileEvent

    set ReadoutControl::InputCallback $oldcb
    set ReadoutControl::ExitCallback  $oldecb
    if {[catch {close $ReadoutControl::PipeFd}]} {
        incr callbacks -2
    }
    set $ReadoutControl::PipeFd        $oldfd
    tcltest::removeFile $testFilename

    list $callbacks $cbline $priorstate
} [list 0 {} NotLoaded]

#   5.0 Test for SetState.
#
tcltest::test ReadoutControl-5.0 {ReadoutControl::SetState} {
    set oldtitle [ReadoutState::getTitle]
    set oldrun   [ReadoutState::getRun]
    set oldscl   [ReadoutState::getScalerCount]
    set oldper   [ReadoutState::getScalerPeriod]
    set oldpipe  $ReadoutControl::PipeFd

    ReadoutState::setTitle       {My Title}
    ReadoutState::setRun         1234
    ReadoutState::setScalerCount   32
    ReadoutState::setScalerPeriod   5
    set testfile [tcltest::makeFile {} state.output]
    set testfd   [open $testfile w]
    set ReadoutControl::PipeFd $testfd

    ReadoutControl::SetState
    close $testfd

    ReadoutState::setTitle        $oldtitle
    ReadoutState::setRun          $oldrun
    ReadoutState::setScalerCount  $oldscl
    ReadoutState::setScalerPeriod $oldper
    set ReadoutControl::PipeFd    $oldpipe

    set testfd [open $testfile r]
    set contents [read -nonewline $testfd]
    close $testfd
    tcltest::removeFile $testfile

    set contents [split $contents "\n"]
} [list {set run 1234} {set title "My Title"} {set scaler 32} {set frequency 5}]

# 6.x  Tests for callback setting procs:
#   0  - BeginCallback
#   1  - EndCallback
#   2  - PauseCallback
#   3  - ResumeCallback
#   4  - LoadCallback
#   5  - ExitCallback
#   6  - InputCallback
#   7  - CommandCallback
#    Bad callbacks supplied:
#   8  - BeginCallback
#   9  - EndCallback
#   10  - PauseCallback
#   11  - ResumeCallback
#   12  - LoadCallback
#   13  - ExitCallback
#   14  - InputCallback
#   15  - CommandCallback




tcltest::test ReadoutControl-6.0 {ReadoutControl::SetOnBegin} {
    proc ::myBegin {run} {}
    set oldcb $ReadoutControl::BeginCallback
    ReadoutControl::SetOnBegin ::myBegin
    set newcb $ReadoutControl::BeginCallback
    set ReadoutControl::BeginCallback $oldcb

    set newcb
} ::myBegin

tcltest::test ReadoutControl-6.1 {ReadoutControl::SetOnEnd} {
    proc ::myEnd {run} {}
    set oldcb $ReadoutControl::EndCallback
    ReadoutControl::SetOnEnd ::myEnd
    set newcb $ReadoutControl::EndCallback
    set ReadoutControl::EndCallback $oldcb

    set newcb
} ::myEnd

tcltest::test ReadoutControl-6.2 {ReadoutControl::SetOnPause} {
    proc ::myPause {run} {}
    set oldcb $ReadoutControl::PauseCallback
    ReadoutControl::SetOnPause ::myPause
    set newcb $ReadoutControl::PauseCallback
    set ReadoutControl::PauseCallback $oldcb

    set newcb
} ::myPause

tcltest::test ReadoutControl-6.3 {ReadoutControl::SetOnResume} {
    proc ::myResume {run} {}
    set oldcb $ReadoutControl::ResumeCallback
    ReadoutControl::SetOnResume ::myResume
    set newcb $ReadoutControl::ResumeCallback
    set ReadoutControl::ResumeCallback $oldcb

    set newcb
} ::myResume

tcltest::test ReadoutControl-6.4 {ReadoutControl::SetOnLoad} {
    proc ::myLoad {} {}
    set oldcb $ReadoutControl::LoadCallback
    ReadoutControl::SetOnLoad ::myLoad
    set newcb $ReadoutControl::LoadCallback
    set ReadoutControl::LoadCallback $oldcb

    set newcb
} ::myLoad

tcltest::test ReadoutControl-6.5 {ReadoutControl::SetOnExit} {
    proc ::myExit {} {}
    set oldcb $ReadoutControl::ExitCallback
    ReadoutControl::SetOnExit ::myExit
    set newcb $ReadoutControl::ExitCallback
    set ReadoutControl::ExitCallback $oldcb

    set newcb
} ::myExit

tcltest::test ReadoutControl-6.6 {ReadoutControl::SetOnInput} {
    proc ::myInput {msg} {}
    set oldcb $ReadoutControl::InputCallback
    ReadoutControl::SetOnInput ::myInput
    set newcb $ReadoutControl::InputCallback
    set ReadoutControl::InputCallback $oldcb

    set newcb
} ::myInput

tcltest::test ReadoutControl-6.7 {ReadoutControl::setOnCommand} {
    proc ::myCommand {cmd} {}
    set oldcb $ReadoutControl::CommandCallback
    ReadoutControl::SetOnCommand ::myCommand
    set newcb $ReadoutControl::CommandCallback
    set ReadoutControl::CommandCallback $oldcb

    set newcb
} ::myCommand

                ### bad callbacks ###

tcltest::test ReadoutControl-6.8 {ReadoutControl::SetOnBegin - bad callback} {
    set oldcb $ReadoutControl::BeginCallback
    ReadoutControl::SetOnBegin myBadBegin
    set newcb $ReadoutControl::BeginCallback
    set ReadoutControl::BeginCallback $oldcb

    if {$oldcb != $newcb} {
        set result "sb: $oldcb was $newcb"
    } else {
        set result 1
    }
    set result
} 1

tcltest::test ReadoutControl-6.9 {ReadoutControl::SetOnEnd - bad callback} {
    set oldcb $ReadoutControl::EndCallback
    ReadoutControl::SetOnEnd myBadEnd
    set newcb $ReadoutControl::EndCallback
    set ReadoutControl::EndCallback $oldcb
    if {$oldcb != $newcb} {
        set result "sb: $oldcb was $newcb"
    } else {
        set result 1
    }
    set result
} 1


tcltest::test ReadoutControl-6.10 {ReadoutControl::SetOnPause - bad callback} {

    set oldcb $ReadoutControl::PauseCallback
    ReadoutControl::SetOnPause myBadPause
    set newcb $ReadoutControl::PauseCallback
    set ReadoutControl::PauseCallback $oldcb
    if {$oldcb != $newcb} {
        set result "sb: $oldcb was $newcb"
    } else {
        set result 1
    }
    set result
} 1

tcltest::test ReadoutControl-6.11 {ReadoutControl::SetOnResume - bad callback} {

    set oldcb $ReadoutControl::ResumeCallback
    ReadoutControl::SetOnResume myBadResume
    set newcb $ReadoutControl::ResumeCallback
    set ReadoutControl::ResumeCallback $oldcb

    if {$oldcb != $newcb} {
        set result "sb: $oldcb was $newcb"
    } else {
        set result 1
    }
    set result
} 1

tcltest::test ReadoutControl-6.12 {ReadoutControl::SetOnLoad - bad callback} {

    set oldcb $ReadoutControl::LoadCallback
    ReadoutControl::SetOnLoad myBadLoad
    set newcb $ReadoutControl::LoadCallback
    set ReadoutControl::LoadCallback $oldcb

    if {$oldcb != $newcb} {
        set result "sb: $oldcb was $newcb"
    } else {
        set result 1
    }
    set result
} 1

tcltest::test ReadoutControl-6.13 {ReadoutControl::SetOnExit - bad callback} {

    set oldcb $ReadoutControl::ExitCallback
    ReadoutControl::SetOnExit myExit
    set newcb $ReadoutControl::ExitCallback
    set ReadoutControl::ExitCallback $oldcb

    if {$oldcb != $newcb} {
        set result "sb: $oldcb was $newcb"
    } else {
        set result 1
    }
    set result
} 1

tcltest::test ReadoutControl-6.14 {ReadoutControl::SetOnInput - bad callback} {

    set oldcb $ReadoutControl::InputCallback
    ReadoutControl::SetOnInput myBadInput
    set newcb $ReadoutControl::InputCallback
    set ReadoutControl::InputCallback $oldcb

    if {$oldcb != $newcb} {
        set result "sb: $oldcb was $newcb"
    } else {
        set result 1
    }
    set result
} 1
tcltest::test ReadoutControl-6.15 {ReadoutControl::setOnCommand - bad callback} {

    set oldcb $ReadoutControl::CommandCallback
    ReadoutControl::SetOnCommand myBadCommand
    set newcb $ReadoutControl::CommandCallback
    set ReadoutControl::CommandCallback $oldcb

    if {$oldcb != $newcb} {
        set result "sb: $oldcb was $newcb"
    } else {
        set result 1
    }
    set result
} 1


# 7.0 - Check SetReadoutProgram.
#    Note this version requires the readout
#    program to exist and be executable so we need
#    to fabricate one with those characteristics... /usr/bin/true will do.
#
tcltest::test ReadoutControl-7.0 {ReadoutControl::SetReadoutProgram} {

    set host [DAQParameters::getSourceHost]
    set bin  [DAQParameters::getReadoutPath]

    DAQParameters::sourceHostIs localhost
    DAQParameters::readoutPathIs /usr/bin/test

    set newhost [DAQParameters::getSourceHost]
    set newbin  [DAQParameters::getReadoutPath]

    #  Need to be a bit dirty since the default readout host is not exec.

    DAQParameters::sourceHostIs $host
    set configuration::ReadoutPath $bin

    list $newhost $newbin

} [list localhost /usr/bin/test]

#  8.x - Get/SetRun - set the run number.
#    .0  - State == notrunning
#    .1  - State == NotLoaded
#    .2  - State == Running.
#    .3  - GetRun.

tcltest::test ReadoutControl-8.0 {ReadoutControl::SetRun - state notrunning} {
    set ::ReadoutControl::State "NotRunning"
    ReadoutControl::SetRun 52

    ::ReadoutState::getRun
} 52

tcltest::test ReadoutControl-8.1 {ReadoutControl::SetRun - state NotLoaded} {
    set ::ReadoutControl::State "NotLoaded"
    ReadoutControl::SetRun 25
    ::ReadoutState::getRun
} 25

tcltest::test ReadoutControl-8.2 {ReadoutControl::SetRun - state Running} {
    set ::ReadoutControl::State "Runing"
    catch {ReadoutControl::SetRun 111} msg
    set msg
} {Run is not halted}

tcltest::test ReadoutControl-8.3 {ReadoutControl::GetRun} {
    set ::ReadoutControl::State "NotRunning"
    ReadoutControl::SetRun 555
    ReadoutControl::GetRun
} 555

#   9.x  SetTitle/GetTitle
#     .0  - State == not running
#     .1  - state == NotLoaded
#     .2  - state == running
#     .3  = Gettitle

tcltest::test ReadoutControl-9.0 {ReadoutControl::SetTitle state == notrunning} {
    set ::ReadoutControl::State "NotRunning"
    ReadoutControl::SetTitle {The state is notrunning}
    ::ReadoutState::getTitle

} {The state is notrunning}

tcltest::test ReadoutControl-9.1 {ReadoutControl::SetTitle state == notloaded} {
    set ::ReadoutControl::State "NotLoaded"
    ReadoutControl::SetTitle {The state is not loaded}
    ::ReadoutState::getTitle
} {The state is not loaded}

tcltest::test ReadoutControl-9.2 {ReadoutControl::SetTitle state == running} {
    set ::ReadoutControl::State "Runnning"
    catch {ReadoutControl::SetTitle failure} message

    set message
} {Run is not halted}

tcltest::test ReadoutControl-9.3 {ReadoutControl::GetTitle} {
    set ::ReadoutControl::State NotRunning
    ReadoutControl::SetTitle {This is a test of GetTitle}
    ReadoutControl::GetTitle

} {This is a test of GetTitle}

#  10.x Enable recording
#      .0   State == not running
#      .1   State == not loaded
#      .2   State == running.
#
tcltest::test ReadoutControl-10.0 {ReadoutControl::EnableTape State == not running} {
    set ReadoutControl::Taping 0
    set ReadoutControl::State NotRunning
    ReadoutControl::EnableTape

    set ReadoutControl::Taping
} 1

tcltest::test ReadoutControl-10.1 {ReadoutControl::EnableTape State == not loaded} {
    set ReadoutControl::Taping 0
    set ReadoutControl::State  NotLoaded
    ReadoutControl::EnableTape

    set ReadoutControl::Taping
} 1

tcltest::test ReadoutControl-10.2 {ReadoutControl::EnableTape State == Running} {
    set ReadoutControl::Taping 0
    set ReadoutControl::State Running
    catch {ReadoutControl::EnableTape} message

    set message
} {Run is not halted}

#  11.x Disable recording - similar test structure to test 10.x

tcltest::test ReadoutControl-11.0 {ReadoutControl::DisableTape state == not running} {
    set ReadoutControl::Taping 1
    set ReadoutControl::State NotRunning

    ReadoutControl::DisableTape
    set ReadoutControl::Taping
} 0

tcltest::test ReadoutControl-11.1 {ReadoutControl::DisableTape state == not loaded} {
    set ReadoutControl::Taping 1
    set ReadoutControl::State NotLoaded

    ReadoutControl::DisableTape
    set ReadoutControl::Taping

} 0

tcltest::test ReadoutControl-11.2 {ReadoutControl::DisableTape state == Running} {
    set ReadoutControl::Taping 0
    set ReadoutControl::State Running
    catch {ReadoutControl::DisableTape} message

    set message
} {Run is not halted.}

#  12.x  - isTapeOn
#  12.0  - it is.
#  12.1  - it isn't.

tcltest::test ReadoutControl-12.0 {ReadoutControl::isTapeOn yes} {
    set ReadoutControl::State NotRunning
    ReadoutControl::EnableTape

    ReadoutControl::isTapeOn
} 1

tcltest::test ReadoutControl-12.1 {ReadoutControl::isTapeOn no} {
    set ReadoutControl::State NotRunning
    ReadoutControl::DisableTape

    ReadoutControl::isTapeOn
} 0

#  13.x   Begin:
#    .0 - Begin when not running.
#    .1 - Begin when halted.
#    .2 - Begin when not running, callback exists.
#

tcltest::test ReadoutControl-13.0 {ReadoutControl::Begin when halted} {
    set testfile [tcltest::makeFile {} output.pipeline]
    set fdold $ReadoutControl::PipeFd
    set oldstate $ReadoutControl::State
    set ReadoutControl::PipeFd [open $testfile w]
    set ReadoutControl::State  "NotRunning"

    ReadoutControl::Begin

    close $ReadoutControl::PipeFd
    set   $ReadoutControl::PipeFd $fdold

    set   fd [open $testfile r]
    set   data [read -nonewline $fd]
    set   lines [split $data "\n"]
    set result [lindex $lines end]

    close $fd
    lappend result $ReadoutControl::State
    set ReadoutControl::State $oldstate
    tcltest::removeFile $testfile

    set result

} [list begin Active]

tcltest::test ReadoutControl-13.1 {ReadoutControl::Begin when not halted} {
    set oldstate $ReadoutControl::State
    set ReadoutControl::State "Active"
    if {![catch {ReadoutControl::Begin} msg]} {
        set msg {Begin worked when already active}
    }
    set msg
} {Run is active}

proc stateCallback {} {
    global callbacks
    incr callbacks
}
tcltest::test ReadoutControl-13.2 {ReadoutControl::Begin when halted, and have callback} {
    set oldcb  ReadoutControl::BeginCallback
    ReadoutControl::SetOnBegin ::stateCallback
    set testfile [tcltest::makeFile {} output.pipeline]
    set fdold $ReadoutControl::PipeFd
    set oldstate $ReadoutControl::State
    set ReadoutControl::PipeFd [open $testfile w]
    set ReadoutControl::State  "NotRunning"
    set callbacks 0

    ReadoutControl::Begin

    close $ReadoutControl::PipeFd
    set   ReadoutControl::PipeFd $fdold
    set   ReadoutControl::BeginCallback $oldcb
    set ReadoutControl::State $oldstate
    tcltest::removeFile $testfile

    set callbacks

} 1

# 14.x  End tests similar structure to Begin
#   .0  State legal.
#   .1  State illegal
#   .2  Callback
#

tcltest::test ReadoutControl-14.0 {ReadoutControl::End when good state} {
    set testfile [tcltest::makeFile {} output.pipeline]
    set fdold $ReadoutControl::PipeFd
    set oldstate $ReadoutControl::State
    set ReadoutControl::PipeFd [open $testfile w]
    set ReadoutControl::State  "Active"

    ReadoutControl::End

    close $ReadoutControl::PipeFd
    set   $ReadoutControl::PipeFd $fdold

    set   fd [open $testfile r]
    set   data [read -nonewline $fd]
    set   lines [split $data "\n"]
    set result [lindex $lines end]

    close $fd
    lappend result $ReadoutControl::State
    set ReadoutControl::State $oldstate
    tcltest::removeFile $testfile

    set result
} [list end NotRunning]

tcltest::test ReadoutControl-14.1 {ReadoutControl::End when bad state} {
    set oldstate $ReadoutControl::State
    set ReadoutControl::State "NotRunning"
    if {![catch {ReadoutControl::End} msg]} {
        set msg {End worked when already halted}
    }
    set msg
} {Run is already halted}

tcltest::test ReadoutControl-14.2 {ReadoutControl::End when callbacks} {
    set oldcb  ReadoutControl::EndCallback
    ReadoutControl::SetOnEnd ::stateCallback
    set testfile [tcltest::makeFile {} output.pipeline]
    set fdold $ReadoutControl::PipeFd
    set oldstate $ReadoutControl::State
    set ReadoutControl::PipeFd [open $testfile w]
    set ReadoutControl::State  "Active"
    set callbacks 0

    ReadoutControl::End

    close $ReadoutControl::PipeFd
    set   ReadoutControl::PipeFd $fdold
    set   ReadoutControl::EndCallback $oldcb
    set ReadoutControl::State $oldstate
    tcltest::removeFile $testfile

    set callbacks
} 1

#  15.x   - same drill as above but for Pause:

tcltest::test ReadoutControl-15.0 {ReadoutControl::Pause in good state} {
    set testfile [tcltest::makeFile {} output.pipeline]
    set fdold $ReadoutControl::PipeFd
    set oldstate $ReadoutControl::State
    set ReadoutControl::PipeFd [open $testfile w]
    set ReadoutControl::State  "Active"

    ReadoutControl::Pause

    close $ReadoutControl::PipeFd
    set   $ReadoutControl::PipeFd $fdold

    set   fd [open $testfile r]
    set   data [read -nonewline $fd]
    set   lines [split $data "\n"]
    set result [lindex $lines end]

    close $fd
    lappend result $ReadoutControl::State
    set ReadoutControl::State $oldstate
    tcltest::removeFile $testfile

    set result
} {pause Paused}

tcltest::test ReadoutControl-15.1 {ReadoutControl::Pause in bad state} {
    set oldstate $ReadoutControl::State
    set ReadoutControl::State "NotRunning"
    if {![catch {ReadoutControl::Pause} msg]} {
        set msg {Pause worked when not active}
    }
    set msg
} {Run is not active}

tcltest::test ReadoutControl-15.2 {ReadoutControl::Pause with callouts} {
    set oldcb  ReadoutControl::PauseCallback
    ReadoutControl::SetOnPause ::stateCallback
    set testfile [tcltest::makeFile {} output.pipeline]
    set fdold $ReadoutControl::PipeFd
    set oldstate $ReadoutControl::State
    set ReadoutControl::PipeFd [open $testfile w]
    set ReadoutControl::State  "Active"
    set callbacks 0

    ReadoutControl::Pause

    close $ReadoutControl::PipeFd
    set   ReadoutControl::PipeFd $fdold
    set   ReadoutControl::PauseCallback $oldcb
    set ReadoutControl::State $oldstate
    tcltest::removeFile $testfile

    set callbacks
    } 1
# 16.x  tests the resume command with organization as before.

tcltest::test ReadoutControl-16.0 {ReadoutControl::Resume in good state} {
    set testfile [tcltest::makeFile {} output.pipeline]
    set fdold $ReadoutControl::PipeFd
    set oldstate $ReadoutControl::State
    set ReadoutControl::PipeFd [open $testfile w]
    set ReadoutControl::State  "Paused"

    ReadoutControl::Resume

    close $ReadoutControl::PipeFd
    set   ReadoutControl::PipeFd $fdold

    set   fd [open $testfile r]
    set   data [read -nonewline $fd]
    set   lines [split $data "\n"]
    set result [lindex $lines end]

    close $fd
    lappend result $ReadoutControl::State
    set ReadoutControl::State $oldstate
    tcltest::removeFile $testfile

    set result
} [list resume Active]

tcltest::test ReadoutControl-16.1 {ReadoutControl::Resume in bad state} {
    set oldstate $ReadoutControl::State
    set ReadoutControl::State "NotRunning"
    if {![catch {ReadoutControl::Resume} msg]} {
        set msg {Resume worked when not paused}
    }
    set msg
} {Run is not paused}

tcltest::test ReadoutControl-16.2 {ReadoutControl::Resume with callbacks} {
    set oldcb  ReadoutControl::ResumeCallback
    ReadoutControl::SetOnResume ::stateCallback
    set testfile [tcltest::makeFile {} output.pipeline]
    set fdold $ReadoutControl::PipeFd
    set oldstate $ReadoutControl::State
    set ReadoutControl::PipeFd [open $testfile w]
    set ReadoutControl::State  "Paused"
    set callbacks 0

    ReadoutControl::Resume

    close $ReadoutControl::PipeFd
    set   ReadoutControl::PipeFd $fdold
    set   ReadoutControl::PauseCallback $oldcb
    set ReadoutControl::State $oldstate
    tcltest::removeFile $testfile

    set callbacks
} 1


# Cleanup

package forget ReadoutControl
package forget ReadoutState
package forget DAQParameters

file delete pkgIndex.tcl
if {[file exists pkgIndex.tcl.saved]} {
    file rename pkgIndex.tcl.saved pkgIndex.tcl
}
set auto_path $auto_saved


tcltest::cleanupTests

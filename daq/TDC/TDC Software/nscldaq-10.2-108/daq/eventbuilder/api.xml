<!-- chapter frameworks -->
<chapter>
    <title>Event orderer and its user interface</title>
    <para>
        The NSCL event builder is a two stage pipeline.  The first stage of the
        pipeline puts event fragments from an arbitrary number of event sources
        into a total time order.  A mechanism exists to allow analysis
        applications to look at
        these fragments directly.  The second stage of the pipeline assembles
        fragments that lie within some specified coincidence window into
        events.
    </para>
    <para>
        This chapter describes:
    </para>
    <itemizedlist>
        <listitem><para>The philososphy of the event orderer</para></listitem>
        <listitem><para>How to start up the event orderer using the standard
            start script</para></listitem>
        <listitem><para>How to write an event orderer startup script</para></listitem>
        <listitem><para>The set of packages available to scripts that interact
            with the event orderer.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        In addition to this chapter, please see the reference information in
        the part <emphasis>1evb</emphasis>.  That part of the reference
        material provides detailed information about the event builder
        Tcl package.
    </para>
    <section>
        <title>Event orderer design philosophy.</title>
        <para>
            The event orderer was designed to support user written extensions
            and user interfaces.  Support for this was in the specification from
            the start.  One reason is the wide variety of possible meanings
            that can be attributed to exceptional conditions like data late,
            or mixed and incomplete barriers.
        </para>
        <para>
            The orderer accomplishes this by wrapping it's C/C++ core with a
            Tcl/Tk interface.  Furthermore some standard Tk components are
            provided along with a Tcl application program interface that
            allowws you to intervene at key points in the event orderer's
            execution.
        </para>
        <para>
            If you think of the event orderer as a set of Tcl commands that
            encpasulate the C/C++ core you'll have a good picture of the
            final structure.
        </para>
    </section>
    <section>
        <title>Using the standard event orderer startup script</title>
        <para>
            Since the event orderer is a library wrapped by Tcl commands, it is
            necessary to use a Tcl script to start the event orderer.  If the
            standard monitoringand user interface is sufficent, you can use the
            <firstterm>standard event orderer startup script</firstterm>..
            If the data acquisition system is installed in <filename>DAQROOT</filename>,
            you can start the event orderer using the standard startup script:
        </para>
        <informalexample>
            <programlisting>
$DAQROOT/bin/startOrderer
            </programlisting>
        </informalexample> 
        <para>
           It is also possible to start up more than one event orderer.  Each
           event orderer must have a unique name.  Supply that name on the
           command line e.g.:
        </para>
        <informalexample>
           <programlisting>
$DAQROOT/bin/startOrderer  aName
           </programlisting>
        </informalexample>
        <para>
          Event orderer names are automatically qualified by your login name.
          There is therefore no supported way to connect clients to another
          user's event orderer.  
        </para>
    </section>
    <section>
        <title>Writing an event orderer startup script</title>
        <para>
            This section provides skeletal information that should guide you
            in writing your own event orderer startup script.  If you actually
            decide to take that plunge you'll want to look at the reference
            material in <emphasis>1evb</emphasis>.  You'll also want to look at
            the next section which provides a broad brush overview of the
            user interface elements provided with the software.
        </para>
        <para>
            The best way to get an feel for what you need to do is to look
            at the standard startup script as of the time this document was written:
        </para>
        <example>
            <title>The standard startup script explained</title>
            <programlisting>
#!/bin/bash
# Start Tclsh \                             <co id='orderstart_tclstart' />
exec tclsh8.5 ${0} ${@}


lappend auto_path [file join /usr/opt/daq/10.2 TclLibs] <co id='orderstart_pkgpath' />

package require EventBuilder
package require EVB::connectionList      <co id='orderstart_pkgloads' />
package require EVB::GUI


                                <co id='orderstart_start' />

if {$argc > 0} {
    EVB::Start [lindex $argv 0]
} else {
    EVB::Start
}





EVB::createGui .test
pack .test                             <co id='orderstart_makegui' />

EVB::maintainGUI .test                 <co id='orderstart_maintain' />

            </programlisting>
            
        </example>
        <calloutlist>
            <callout arearefs='orderstart_tclstart'>
                <para>
                    This is a standard Tcl trick to start up the Tcl interpreter.
                    Note that the actual version of Tcl to start is determined
                    by the NSCLDAQ installer and is normally the highest version
                    installed in a 'standard location'.  This magic incantation
                    gets around issues that can occur if Tcl is not enabled as a
                    system shell.
                </para>
                <para>
                    If you have the Tcl documentation installed on your system
                    do a <command>man tclsh</command> and read the section
                    <literal>SCRIPT FILES</literal>.  Note that the example
                    in that section is for the <filename>sh</filename> shell
                    rather than <filename>bash</filename> and that acounts for
                    the minor syntactical differences.
                </para>
            </callout>
            <callout arearefs='orderstart_pkgpath'>
                <para>
                    The NSCLDAQ auto configuration/installer modifies this
                    line as well.  The purpose of the line is to add the
                    NSCLDAQ Tcl package library directory tree to the set
                    of paths that are searched for packages by the
                    <command>package require</command> command.
                </para>
                <para>
                    This is done because the event builder/event orderer
                    software is basically a set of Tcl packages.
                </para>
            </callout>
            <callout arearefs='orderstart_pkgloads'>
                <para>
                    This set of lines loads the packages that make up the
                    event builder/orderer and its user interface:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><filename>EventBuilder</filename></term>
                        <listitem>
                            <para>
                                Provides a set of procedures in the
                                <literal>EVB::</literal> namespace that
                                support setting up and controlling the
                                event builder/orderer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><filename>EVB::connectionList</filename></term>
                        <listitem>
                            <para>
                               This package provides code that implements
                               a list of the clients connected to the server
                               component of the event orderer.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><filename>EVB::GUI</filename></term>
                        <listitem>
                            <para>
                                The user standard user interface components.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </callout>
            <callout arearefs='orderstart_start'>
                <para>
                    Does everything needed to start the event orderer package.
                    Note that the first command parameter, if present is passed
                    as an optional parameter to the 
                    <command>EVB::Start</command> as the name of the event
                    builder. 
                    Once started you have a pair of choices:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            Enter the event loop via a <command>vwait</command>
                            command.  The event builder is event driven and
                            entering the event loop ensures events a delivered
                            to the correct components.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Load <literal>Tk</literal> directly or indirectly
                            as that installs an event loop in the application.
                        </para>
                    </listitem>
                </itemizedlist>
            </callout>
            <callout arearefs='orderstart_makegui'>
                <para>
                    The command <literal>EVB::createGui .test</literal> creates
                    the event orderer's default user interface/monitoring
                    interface.  <literal>.test</literal> is the name of the
                    uppermost window of the user interface.  If you are doing
                    a custom script, you could incorporate this in with your
                    user interface by e.g. creating a frame and specifying the
                    name of a window that would live inside of the frame.
                </para>
                <para>
                    The <command>pack</command> command makes the standard user
                    interface visible inside its parent window (in this case the
                    initial top level window <literal>.</literal>).
                </para>
            </callout>
            <callout arearefs='orderstart_maintain'>
                <para>
                    Starts an <command>after</command> rescheduling procedure
                    that fetches statistics from the orderer and updates
                    the appropriate chunks of the user interface.
                </para>
            </callout>
        </calloutlist>
        <para>
            In general the part that is mutable is going to be what, if any
            hooks you make use of after starting the event orderer and
            how you handle the user interface an its maintenance.
            Refer to the reference section for more information about the
            hooks that area available and how to make use of them.
        </para>
    </section>
    <section>
        <title>Event orderer packages</title>
        <para>
            This section describes the set of packages that make up the
            event builder application programming interface.  There are additional
            packages and interfaces that are considered internal and should not
            referenced by user code, as these interfaces are not guaranteed to
            be stable across different versions of the event orderer.
        </para>
        <para>
            If you need something that is provided as an internal interface,
            ask about it so that a public interface can be added to meet your
            needs.  In this way your code is less likely to break as the
            event orderer evolves...
        </para>
        <para>
            The remainder of this section is a list of the package names and
            a brief description of each package and the services or user
            interface elements it provides.
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>EVB::barriers</literal></term>
                <listitem>
                    <para>
                        Provides graphical user interface elements that can be
                        used to monitor barrier statistics.  Barriers are
                        sets of event fragments that collectively indicate some
                        sort of synchronization has occured between the data sources.
                        
                    </para>
                    <para>
                        Each source is expected to contribute a barrier.
                        Barrier fragments also have a barrier type.
                        The user interfaces support the display of barrier
                        statistics in summary, by source as well as exceptional
                        cases such as barriers with mixed types and barriers
                        with sources that did not participate within the
                        fragment ordering timeout.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EVB::CallbackManager</literal></term>
                <listitem>
                    <para>
                        This package is not normally used by application code
                        but is a stable and usable interface.  It provides
                        a mechanism for registering a set of callback methods,
                        supplying scripts with substitutions and invoking
                        those callbacks with strings that will replace
                        the substitution strings.
                    </para>
                    <para>
                        A typical use-case would be to implement the callbacks in
                        a mega widget implemented in e.g. snit or itk.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EVB::connectionList</literal></term>
                <listitem>
                    <para>
                        Provides an auto-updating widget that displays the
                        set of connections to the event orderer by data source
                        clients.  For each client, the source node, the
                        connection description supplied at connection time, the
                        state and whether or not the connection appears stalled
                        are displayed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EVB::GUI</literal></term>
                <listitem>
                    <para>
                        Provides several top level user interface elements that
                        can be used to implement a monitoring interface for
                        the event orderer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EVB::inputStatistics</literal></term>
                <listitem>
                    <para>
                        Provides user interface elements that support the display
                        of statistics describing the fragments received by
                        the event orderer from the data sources.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EVB::Late</literal></term>
                <listitem>
                    <para>
                        Provides user interface elements that allow applications
                        to display statistics on late fragments.  A late fragment
                        is one that is received sufficiently late in time that
                        when it is emitted it breaks the total ordering of timestamps
                        in the output fragments.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EVB::outputStatistics</literal></term>
                <listitem>
                    <para>
                        Provides user interface elements that support the display
                        of output statistics.  In addition to displaying summary
                        statistics, these user interface elements can display the
                        output statistics by data source as well as the
                        <firstterm>hottest</firstterm> and <firstterm>coldest</firstterm>
                        sources. <footnote><para>The hottest data source is defined
                        as the one which has emitted the most fragments while
                        similarly the coldest data source is the one which has
                        emitted the fewest fragments.
                        </para>
                        </footnote>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EVBUtilities</literal></term>
                <listitem>
                    <para>
                        Provides some useful utility procs and classes.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EventBuilder</literal></term>
                <listitem>
                    <para>
                        Provides useful procs for starting the event orderer and
                        registering specific callbacks with the builder.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>Observer</literal></term>
                <listitem>
                    <para>
                       Provides a snit type that suppports the implementation
                       of the Observer pattern.  See e.g.
                       <ulink url='http://en.wikipedia.org/wiki/Observer_pattern'>
                        http://en.wikipedia.org/wiki/Observer_pattern</ulink>
                       for a description of this pattern.
                    </para>
                    <para>
                        Note that contrary to what the wikipedia description of
                        this pattern might imply, the use of this sort of observer
                        is not restricted to object oriented constructions.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>EVBOrderer</literal></term>
                <listitem>
                    <para>
                        This package represents commands that influence the
                        action of the event builder compiled fragment handler
                        code. Note that many of the commands defined by this package
                        also have Tcl jackets.  Where this is true you should
                        use the jackets instead as they may take care of other
                        issues that may not be trivial to deal with.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
</chapter>
<chapter>
    <title>Event builder client framework</title>
    <para>
        <link linkend='evbapi_chap' endterm='evbapi_chaptitle' /> describes a low
        level API to the NSCL Event builder.  In many cases if you write software
        directly to this you will find that code patterns repeat over and over again.
        The Event builder client framwework captures this and allows you to
        concentrate on getting data from your data source, turning the
        logic of the event builder interface to the framework itself.
    </para>
    <para>
        Recall that a typical library is a set of functions and classes used
        by a program while an application framework is a program that needs a
        user written library to perform application specific functions.
        This chapter will describe
    </para>
    <itemizedlist>
        <listitem><para>
            The 'library' that must be provided to the framework
            to produce a new data source.
            </para></listitem>
        <listitem><para>
            How to build a new event builder data source from your library and
            the framework.  This section will also describe some features
            of the framework that support slightly more advanced applications.
            </para></listitem>
        <listitem><para>
            How to run an event builder client that was built on the framework.
            </para></listitem>
    </itemizedlist>
    <para>
        Reference material is also available for these and other topics:
    </para>
    <itemizedlist>
        <listitem><para>
            <link linkend='daq3-evbclientfw-usercode' endterm='daq3-evbclientfw-usercode-title' /> provides
            reference material that describes the base class on which
            the application code for the event builder is based.
        </para></listitem>
        <listitem><para>
            <link linkend='daq1-evbclientfw-run' endterm='daq1-evbclientfw-run-title' />
            provides reference material that desribes the event builder command
            options and parameters.
        </para></listitem>
    </itemizedlist>
    <section>
        <title>Application specific code for the event builder</title>
        <para>
            The application specific code must:
        </para>
        <itemizedlist>
            <listitem><para>Perform one-time initialization</para></listitem>
            <listitem><para>Determine if data are ready to be read from the source</para></listitem>
            <listitem><para>Provide events to the framework along with their timestamps</para></listitem>
            <listitem><para>Perform any required shutdown operations</para></listitem>
        </itemizedlist>
        <para>
            The framework programmer provides these actions by:
            <orderedlist>
                <listitem><para>Subclassing the <classname>CEVBClientApp</classname>
                    class
                </para></listitem>
                <listitem><para>
                    Writing implementations for all <firstterm>pure virtual</firstterm>
                    methods of <classname>CEVBClientApp</classname>.
                    </para></listitem>
                <listitem><para>
                    Writing overrides for default implementations provided
                    by <classname>CEVBClientApp</classname> if appropriate
                    to the application.
                    </para></listitem>
            </orderedlist>
        </para>
        <para>
            Below is the definition of the <classname>CEVBClientApp</classname>
            abstract base class:
        </para>
        <example>
            <title><classname>CEVBClientApp</classname> definition</title>
            <programlisting>
class CEVBClientApp {
public:
  CEVBClientApp();
  ~CEVBClientApp();

  // The interface:

public:
  virtual void initialize();        <co id="evbfw-base-initialize" />
  virtual bool dataReady(int ms) = 0;     <co id="evbfw-base-dataready" />
  virtual void getEvents() = 0;     <co id="evbfw-base-getevents" />
  virtual void shutdown();          <co id="evbfw-base-shutdown" />
};
                
            </programlisting>
        </example>
        <para>
            In the example above, data members private to <classname>CEVBClientApp</classname>
            are not shown for the sake of brevity.  The interface methods
            that are application specific are virtual and are used as follows:
        </para>
        <calloutlist>
            <callout arearefs="evbfw-base-initialize" >
                <para>
                    Called to perform one-time initialization.  This is called
                    after the entire framework has been created and initialized.
                    It is safe to invoke any support method at this time.
                    This is not necessarily the case during construction.
                </para>
            </callout>
            <callout arearefs="evbfw-base-dataready">
                <para>
                    This method is called from time to time to determine if
                    there is any data.  It should block at most
                    <parameter>ms</parameter> milliseconds.    If at the
                    end of that time no data are avaialble on the data source,
                    return <literal>false</literal>.  If data becomes available,
                    return <literal>true</literal>.
                </para>
            </callout>
            <callout arearefs="evbfw-base-getevents" >
                <para>
                    Called at some point after <methodname>dataReady</methodname>
                    returns <literal>true</literal>. Events that are available
                    from the data source should be read by this method and
                    submitted to the framework for transmission to the
                    event builder.
                </para>
                <para>
                    The mechanism for providing events to the framework is
                    described in the next set of examples.
                </para>
            </callout>
            <callout arearefs="evbfw-base-shutdown">
                <para>
                    Called just prior to the framework shutting down.
                    At this time once more, all framweork services are still
                    avaialble.  This is not true when the object's
                    destructor is called.
                </para>
            </callout>
        </calloutlist>
        <section>
            <title>Sample ring <classname>EVBClientApp</classname> class.</title>
            <para>
                This section incrementally develops an application that
                can take data from a ring buffer and submit it to the
                event builder.  This  is not really a production quality effort,
                it is designed to illustrate several points.  Little bits of code
                and <filename>#include</filename> directives are also not shown
                in order to keep these examples understandable.
            </para>
            <para>
                Let's start by writing a definition of the
                <classname>CEVBRingClientApp</classname> class. For this
                example the ring URL will be gotten from the RINGURL
                environment variable (a production version would probably
                use a command line option but that's beyond the scope of this example.
            </para>
            <example>
                <title>The <classname>CEVBRingClientApp</classname> class
                definition.
                </title>
                <programlisting>
class CRingBuffer;
class CEVBRingClientApp : public CEVBClientApp {
private:
   CRingBuffer* m_pRing;
public:
  virtual void initialize();
  virtual bool dataReady(int ms) = 0;
  virtual void getEvents() = 0;
  virtual void shutdown();

};
                </programlisting>
            </example>
            <para>
                There should be no surprises here. All methods have been
                declared as concrete rather than leaving <methodname>dataReady</methodname>
                and <methodname>getEvents</methodname> as pure virtual. Furthermore,
                <varname>m_pRing</varname> has been declared as a pointer to
                a ring buffer object.  For illustrative purpose, we'll
                create the <classname>CRingBuffer</classname> in the
                <methodname>initialize</methodname> method and
                destroy it in <methodname>shutdown</methodname>.
                These operations could just as easily be done in a
                constructor/destructor pair.
            </para>
            <para>
                Having said this, the <methodname>initialize</methodname>
                and <methodname>shutdown</methodname> methods should
                be pretty easy to write:
            </para>
            <example>
                <title>The <classname>CEVBRingClientApp</classname> <methodname>initialize</methodname>
                and <methodname>shutdown</methodname> methods.
                </title>
                <programlisting>
void
CEVBRingClientApp::intialize()
{
    const char* pRingName = getenv("RINGURL");
    m_pRing = CRingAccess::daqConsumeFrom(std::string(pRingName));
}

void
CEVBRingClientApp::shutdown()
{
    delete m_pRing;
}
                </programlisting>
            </example>
            <para>
                There should clearly be more error checking in
                <methodname>initialize</methodname> however these should also
                be pretty clear. <methodname>initialize</methodname>
                translates the <literal>RINGURL</literal> environment variable
                and opens a ring using using the URL in that environment
                variable.
            </para>
            <para>
                The <methodname>dataReady</methodname> method is a bit tricky.
                We'd rather not burn the CPU by polling.  What we'll here is
                first check to see if there's at least a ring header in the
                ring.  If so, we return <literal>true</literal> if not,
                we block for the number of requested milliseconds and
                check again.
            </para>
            <example>
                <title>The <classname>CEVBRingClientApp</classname>
                <methodname>dataReady</methodname> method.</title>
                <programlisting>
bool
CEVBRingClientApp::dataReady(int ms)
{
    if (haveHeader()) return true;
    usleep(ms*1000);
    return haveHeader();
}

// Added utility function:

bool
CEVBRingClientApp::haveHeader()
{
    return m_pRing->availableData() >= sizeof(RingItemHeader);
}
                </programlisting>
            </example>
            <para>
                Note that we have invented a helper method that
                determines if there's at least a ring header worth of
                data in the ring for us.
            </para>
            <para>
                For <methodname>getEvents</methodname> we will get the minimum
                of <literal>100</literal> events or until there is no more
                data left in the ring.  The events will be bundled into
                a EventFragmentList and submitted to the event builder
                framework using the <classname>CEVBClientFramework::submitFragmentList</classname>.
                Note that each element of the list is a <structname>ClientEventFragment</structname>
                and contains:
            </para>
            <variablelist>
                <varlistentry>
                    <term><fieldsynopsis><type>uint64_t</type> <varname>s_timestamp</varname></fieldsynopsis></term>
                    <listitem>
                        <para>
                            The timestamp associated with the event fragment.
                            This must be extracted from the event itself.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><fieldsynopsis><type>uint32_t</type> <varname>s_sourceId</varname></fieldsynopsis></term>
                    <listitem>
                        <para>
                            The data source id associated with the fragment.
                            A client can submit data from more than one data source.
                            The source Id is used to tag the fragments in events
                            that are finally assembled from the ordered event
                            fragments.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis><type>uint32_t</type><varname>s_size</varname></fieldsynopsis></term>
                    <listitem>
                        <para>
                            The size of the event fragment payload
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><fieldsynopsis><type>void*</type> <varname>s_pPayload</varname></fieldsynopsis></term>
                    <listitem>
                        <para>
                            Pointer to the payload itself.  In our case,
                            the payload will be the full <type>RingItem</type>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                See
                <link linkend='daq3-evbclientfw-api' endterm='daq3-evbclientfw-apititle' />
                for reference information on the framework API methods and data
                structures.
            </para>
            <para>
                For simplicity we are not going to worry about the heterogeneous
                nature of ring items.
            </para>
            <example>
                <title>The <classname>EVBRingClientApp</classname> <methodname>getEvents</methodname>
                implementation.
                </title>
                <programlisting>
void
CEVBRingClientApp::getEvents()
{
    CEVBEventList events;              <co id='evb-clientfw-get-list' />
    int           eventCount = 0;
    CAllButPredicate all;
    
    while(m_pRing->availableData()) {  <co id='evb-clientfw-get-while' />
                                       <co id='evb-clientfw-get-itemprep' />
        CRingItem* pItem = CRingItem::getFromRing(*m_pRing, all);
        ClientEventFragment frag;
        frag.s_timestamp = getTimestamp(pItem);
        frag.s_sourceId  = 1;
        frag.s_size      = pItem->getItemPointer()->s_header.s_size;
        frag.s_payload   = pItem->getItemPointer();
        events.push_back(frag);
        
        eventCount++;                <co id='evb-clientfw-get-limit' />
        if (eventCount >= 100) break;
    }
    if (events.size()) {             <co id='evb-clientfw-get-submit' />
        CEVBClientFramework::submitFragmentList(events);
        
        while(!events.empty()) {    <co id='evb-clientfw-get-cleanup' />
            EventFragmentList fragment = events.front();
            CRingItem* pItem = reinterpret_cast&lt;CRingItem*&gt;(fragment.s_pPayload);
            delete pItem;
            events.pop_front();
        }
    }
}
                </programlisting>
            </example>
            <para>
                Since <methodname>getEvents</methodname> is the most complicated
                method we've seen so far, lets break it down into its component
                pieces.
            </para>
            <calloutlist>
                <callout arearefs='evb-clientfw-get-list'>
                    <para>
                        The <classname>CEVBEventList</classname> is a list
                        of <structname>ClientEventFragment</structname> structs.
                        By list we mean list in the same sense as
                        <classname>std::list</classname>.  Since we are using
                        <methodname>CEVBClientFramework::submitFragmentList</methodname>
                        we need to put our fragments into one of these.
                    </para>
                </callout>
                <callout arearefs='evb-clientfw-get-while'>
                    <para>
                        The main loop condition for our code is to run
                        until we've pulled all the items from the ring.
                        See <link linkend='evb-clientfw-get-limit' >
                        below however.</link>
                    </para>
                </callout>
                <callout arearefs='evb-clientfw-get-itemprep'>
                    <para>
                        This is the heart of the loop. Each pass through the loop,
                        an event is gotten from the ring. A
                        <structname>ClientEventFragment</structname> is filled in.
                        The <structfield>s_timestamp</structfield> is gotten
                        via a utility method that we will not show here.
                        The <structfield>s_sourceId</structfield> has been
                        hard coded to <literal>1</literal>.
                    </para>
                </callout>
                <callout arearefs='evb-clientfw-get-limit' >
                    <para>
                        Once the limit of <literal>100</literal> events have
                        been added to <varname>events</varname>, we break out of
                        the loop to submit the events to the event builder framework.
                    </para>
                </callout>
                <callout arearefs='evb-clientfw-get-submit'>
                    <para>
                        This condition avoids doing anything if for some reason
                        we never got any events.  The call to
                        <methodname>CEVBClientFramework::submitFragmentList</methodname>
                        is what actually causes the fragments to be transmitted
                        to the eventbuilder.
                    </para>
                </callout>
                <callout arearefs='evb-clientfw-get-cleanup'>
                    <para>
                        The <classname>CRingItem</classname> objects we got
                        from the ring are dynamically allocated.  This
                        loop destroys them.  The list elements themselves
                        are destroyed automatically when the function
                        returns.
                    </para>
                </callout>
            </calloutlist>
        </section>
    </section>
    <section id="evbclient-get-and-build">
        <title id='evbclient-get-and-build-title'>Building event builder clients.</title>
        <para>
            Event builder clients based on the framework consist of
            a skeleton application, user code and a Makefile that builds the
            executable program that you run.  In the previous section we looked
            at what is in the user code.  In this section we will look at
            the last bits of customization you need to do in the skeleton application
            as well as how to modify the Makefile so that it will build your
            event builder client program correctly.
        </para>
        <para>
            The framework skeleton application should be copied from
            <filename>$DAQROOT/skeletons/evbclient</filename>.
            <filename>$DAQROOT</filename> is the top level installation
            directory of NSCLDAQ-10.2 or higher.
        </para>
        <para>
            In the last section we saw how to write a <classname>CEVBClientApp</classname>
            class that provides data source specific code to get fragments from
            a data source and make them available to the event builder.
            The framework skeleton application provides a file
            <filename>Main.cpp</filename> that starts the framework code.
            One thing we need to do is to create an instance of our data
            source code.   The data source code's base class constructor
            makes itself known to the framework.
        </para>
        <para>
            This is shown in the highlighted parts of the code from
            <filename>Main.cpp</filename> below.  The highlighted parts
            must be added by you:
        </para>
        <example>
            <title>Configuring the event builder client framework</title>
            <programlisting>
...
#include &lt;EVBFramework.h&gt;
#include "CEVBMyClient.h"           <co id='evbclientfw-main-include' />
...
int
main(char** argv, int argc)
{
    CEVBMyClient myCode;           <co id='evbclientfw-main-instance' />
    CEVBClientFramework::main(argv, argc);  
}
            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs='evbclientfw-main-include'>
                <para>
                    You will need to include the header for your data source
                    application.  If your program provides several data
                    sources, you need to include the header for each of them.
                </para>
            </callout>
            <callout arearefs='evbclientfw-main-instance'>
                <para>
                    Creating an instance of your class is sufficent to register
                    it with the framework (the base class constructor takes
                    care of that).
                </para>
            </callout>
        </calloutlist>
        <para>
            Note that the call to <methodname>CEVBClientFramework::main(argv, argc)</methodname>
            passes in the command line parameters.
        </para>
        <para>
            The Makefile is organized so that you can easily add your code by
            simply defining a few Makefile variables.  These variables are:
        </para>
        <variablelist>
            <varlistentry>
                <term><varname>USER_OBJECTS</varname></term>
                <listitem>
                <para>
                    The names of the object files generated by compiling your
                    source files.  If you have several object files they should be
                    separated by whitespace.
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><varname>USER_CXXFLAGS</varname></term>
                <listitem>
                    <para>
                        If you have any C++ Compilation switches you want
                        added add them here.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><varname>USER_CCFLAGS</varname></term>
                <listitem>
                    <para>
                        If you you haave any C compilation switches you want
                        added, add them here.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><varname>USER_LDFLAGS</varname></term>
                <listitem>
                    <para>
                        If you have any loader flags you want added,
                        add them here.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        
    </section>
    <section id='evb-using-client'>
        <title>Running event builder clients</title>
        <para>
            Once built you will have to run your event builder clients.
            To successfully run the clients, the event builder itself must
            also be running.  The event builder supports several command
            line options.  These are defined by the file
            <filename>options.ggo</filename>, and can be extended by you
            as well.  This file is an input file to the
            <command>gengetopt</command> command line parser package.
        </para>
        <para>
            A Makefile rule to compile this file and create header is
            already present.  The format of this file is described in the
            <command>gengetopt</command> manual at:
            <ulink url='http://www.gnu.org/software/gengetopt/gengetopt.html'>
                http://www.gnu.org/software/gengetopt/gengetopt.html</ulink>.
        </para>
        <para>
            The pre-defined options are:
        </para>
        <variablelist>
            <varlistentry>
                <term><option>--help</option></term>
                <listitem>
                    <para>
                        Prints the a summary of the command line options
                        that are supported by the program.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--evbhost</option>=<replaceable>hostname</replaceable></term>
                <listitem>
                    <para>
                        Provides the name (or IP address) of the host on which
                        the event builder is running.  This switch is mandatory.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--evbport</option>=<replaceable>tcpport</replaceable></term>
                <listitem>
                    <para>
                        Provides the port on which the event builder is listening.
                        If not provided, the NSCLDAQ Port manager is used to
                        automatically locate the event builder.  In general you
                        should not need this switch.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--evbname</option>=<replaceable>eventbuilder-name</replaceable></term>
                <listitem>
                     <para>
                        Provides the name of the event builder to which this
                        client will provide fragments.  If this is omitted, the
                        client will provide fragments to the default event
                        builder for the user.
                     </para>
                 </listitem>
            </varlistentry>
        </variablelist>
    </section>
    <section id='sec_ringfragsrc'>
        <title id='sec_ringfragsrc_title'>ringFragmentSource - a prepackaged client for ringbuffer data sources</title>
        <para>
            The <filename>ringFragmentSource</filename> program provides a mostly pre-packaged
            program that efficiently gets data from a ring buffer and efficiently
            submits it to an event builder.  Since event data in a ring buffer
            may have arbitrary format, the user must supply software to extract
            the timestamp from each event. This software is supplied in the form
            of a shared object library.
        </para>
        <para>
            A pre-packaged timestamp extraction library for the S800 is supplied
            and will be maintained in
            <filename>$DAQROOT/lib/libS800TimeExtractor.so</filename>
        </para>
        <para>
            In addition to the standard ring client framework command options,
            the following switches are are required.
        </para>
        <variablelist>
            <varlistentry>
                <term><option>--ring</option>=<replaceable>ring-uri</replaceable></term>
                <listitem>
                    <para>
                        Defines the ring from which data will be acquired.  This can
                        be local (<filename>tcp://localhost/</filename><replaceable>ringname</replaceable>),
                        or remote (<filename>tcp://</filename><replaceable>somwhere</replaceable><filename>.nscl.msu.edu/</filename><replaceable>ringname</replaceable>)
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--timestampextactor</option>=<replaceable>file-path</replaceable></term>
                <listitem>
                    <para>
                        Specifies the path to the shared library you have built
                        that extracts timestamps from ring events.
                        For the s800 pre-built extractor this should be
                        <filename>$DAQHOST/lib/libS800TimeExtractor.so</filename>
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <section id='sec_tsextractors'>
            <title id='sec_tsextractors_title'>Writing and building timestamp extractors.</title>
            <para>
                This section describes how to write timestamp extractors.
                The source code for the s800 timestamp extractor is also
                given as an annotated example.
            </para>
            <para>
                Timestamp extractors must provide an entry point named
                <function>timestamp</function>.  This function takes a single
                argument; the pointer to the Physics Ring Item which must
                be analzed.  The function must return a 64 bit timestamp as
                its result (<type>uint64_t</type>).
            </para>
            <para>
                If the timestamp extractor is written in C++, you must declare
                the <function>timestamp</function>
                function as <literal>extern "C"</literal>. You do not need
                to do this if <function>timestamp</function> is writte in C.
            </para>
            <para>
                Let's look at the timestamp extractor for the S800.  We are not
                going to bother with the <filename>s800.h</filename> header
                file.  The actual values of each symbol defined in that file
                are unimportant.  We'll just explain the meaning of the symbols
                it defines that we need.
            </para>
            <example>
                <title>S800 timestamp extractor (<filename>s800timestamp.c</filename></title>
                <programlisting>
#include "s800.h"                       <co id="s800tstamp_include" />
#include &lt;DataFormat.h&gt;           <co id="s800tstamp_datafmtinclude" />
#include &lt;assert.h&gt;
#include &lt;stdint.h&gt;


uint64_t
timestamp(pPhysicsEventItem item)      <co id='s800tstamp_timestampentry' />
{
  pS800event pFullEvent;
  pS800timestamp pTimestamp;
  ppacket    pNextPacket;
  uint16_t*  pWords;
  int64_t   nRemaining;
  int        nPktSize;


  pFullEvent = (pS800event)(item-&gt;s_body);  <co id='s800tstamp_body_ptr' />
  assert(pFullEvent-&gt;s_type == S800_PACKET);
  uint16_t versionWord = pFullEvent-&gt;s_version;  <co id='s800tstamp_checkversion' />
  versionWord = (versionWord &amp; S800_OUTERVSNMASK) &gt;&gt; S800_OUTERVSNSHIFT;
  assert(versionWord == S800_OUTERVERSION);


  nRemaining = pFullEvent-&gt;s_size * sizeof(uint16_t); <co id='s800tstamp_iterationsetup' />
  pNextPacket= &amp;(pFullEvent-&gt;s_firstPacket);
  nRemaining -= sizeof(S800event) - sizeof(packet);



  while(nRemaining &gt; 0) {
    if (pNextPacket-&gt;s_type == S800_TIMESTAMP_PACKET) {
      pTimestamp = (pS800timestamp)pNextPacket;        <co id='s800tstamp_extract_ts' />
      return (pTimestamp-&gt;s_timestamp);
    }

    nPktSize = pNextPacket-&gt;s_size;                 <co id='s800tstamp_nextpacket' />
    pWords   = (uint16_t*)pNextPacket;
    pNextPacket = (ppacket)(pWords + nPktSize);
    nRemaining -= nPktSize*sizeof(uint16_t);
  }

  assert(0);                                        <co id='s800tstamp_failed' />


}
                </programlisting>
            </example>
            <para>
                Before annotating the example, a few words about the event format.
                The S800 ring item body leads off with a 32 bit event size.
                The entire S800 event is encapsyualted in an S800 packet consisting
                of a word count and a 16 bit constant:
                <literal>S800_PACKET</literal>.  The s800 packet
                includes a 16bit version word.   The most significant four bits
                of that word are the overall event format while the bottom
                12 bits are the experiment format version.
            </para>
            <para>
                Following that, a set of 'packets' appear.  Each packet has
                a 16 bit word size a 16 bit type and a payload whose size,
                when added to the size of the packet header equals the
                packet size word.  One of these packets of type,
                <literal>S800_TIMESTAMP_PACKET</literal> constains
                the timestamp.
            </para>
            <para>
                The numbers in the list of comments below refer to the corresponding
                numers in the program listing.
            </para>
            
            <calloutlist>
                <callout arearefs="s800tstamp_include">
                    <para>
                        The <filename>s800.h</filename> header defines the structure
                        of the minimal set of packet definitions required to pull
                        the timestamp out of an S800 event.  It is based on
                        information provided by the operations technical group.
                    </para>
                </callout>
                <callout arearefs="s800tstamp_datafmtinclude">
                    <para>
                        The <filename>DataFormat.h</filename> header defines
                        all of the ring item data structures.  We will only be
                        using physics event items in this code.
                    </para>
                </callout>
                <callout arearefs='s800tstamp_timestampentry'>
                    <para>
                        This code declares the function that will be called
                        by the event fragment data source for each physics
                        ring item.  If this were written in C++ (or even
                        compiled with the C++ compiler), the entire
                        function would need to be declared <literal>extern "C"</literal>:
                        <informalexample>
                            <programlisting>
extern "C" {
uint64_t
timestamp(pPhysicsEventItem item) 
{
... // function body
}   // end function body
}   // end extern "C" section.
                            </programlisting>
                        </informalexample>
                    </para>
                </callout>
                <callout arearefs='s800tstamp_body_ptr'>
                    <para>
                        The function is given a pointer to the entire ring item.
                        In the case of the S800, we only care about the event
                        body.  This line of code produces a pointer to the event
                        body.
                    </para>
                    <para>
                        The typecast makes that pointer (normally a <type>void*</type>)
                        a pointer to a struct that represents the outermost
                        layer of an S800 event.
                    </para>
                </callout>
                <callout arearefs='s800tstamp_checkversion'>
                    <para>
                        The outermost event structure includes a format
                        version level.  The top four bits of this version indicate
                        the revision level of the outer packet format.  This is
                        checked.  If different than what was expected, the
                        <literal>assert()</literal> call will cause the entire
                        program to exit.
                    </para>
                    <para>
                        This drastic action is taken becaus if we cannot
                        ensure that the version is one we know about, we can't
                        ensure that the correct timestamp can be extracted from
                        the events.   Even worse than failing later on would be
                        to send events with bad timestamp values.
                    </para>
                </callout>
                <callout arearefs='s800tstamp_iterationsetup'>
                    <para>
                        This section sets up to iterate through the set of packets
                        in the event.
                    </para>
                </callout>
                <callout arearefs='s800tstamp_extract_ts'>
                    <para>
                        If the next packet is a timestamp packet, the timestamp is
                        extracted from it and returned to the caller.  
                    </para>
                </callout>
                <callout arearefs='s800tstamp_nextpacket'>
                    <para>
                        If the current packet is not the timestamp packet,
                        the pointer to the next packet is computed and
                        the search continues.
                    </para>
                </callout>
                <callout arearefs='s800tstamp_failed'>
                    <para>
                        If, after all packets in the event are examined,
                        no timestamp packet is seen, this <literal>assert</literal>
                        exits the program.  The assumption is that something is
                        very seriously wrong either with the event format
                        or with the timestamp extractor.
                    </para>
                </callout>
            </calloutlist> 
            
        </section>
    </section>
</chapter>
<!-- /chapter -->
<!-- chapter libraries -->
<chapter id='evbapi_chap'>
    <title id='evbapi_chaptitle'>
        Event builder client API
    </title>
    <para>
        The NSCL Event builder is made of of two distinct stages.  These
        stages:
        <orderedlist>
            <listitem>
                <para>
                    A fragment orderer which accepts chunks of event,
                    or <firstterm>fragments</firstterm> from the data sources
                    and produces as output fragments that are ordered
                    by timestamps that are associated with the fragments.
                </para>
            </listitem>
            <listitem>
                <para>
                    A builder stage that clumps event fragments with timestamps
                    that are within a coincidence window into events.
                </para>
            </listitem>
        </orderedlist>
    </para>
    <section>
        <title>C++ Client API</title>
        <para>
            This section provides tutorial information that describes the
            client C++ API to the event orderer/builder.
            <link linkend='daq3-ceventorder' endterm='daq3-ceventorder-title' />
            provides reference material for the class we are discussing here.
        </para>
        <para>
            The interface is encapsulated in a single class named
            <classname>CEventOrderClient</classname>.  In the remainder of this
            chapter we will describe:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend='evb-using-client'>Making <classname>CEventOrderClient</classname> available
                within your program.</link>
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend='evb-connecting'>
                    How to form a connection with the event orderer.
                    </link>
                </para>
            </listitem>
        </itemizedlist>
        </section>
        <section>
            <title>Incorporating the event builder client library</title>
            <para>
                Incorporating event builder client software in your program requires
                that you <literal>#include</literal> the event builder client
                header in source files that use <classname>CEventOrderClient</classname>.
                You must also:
                <itemizedlist>
                    <listitem>
                        <para>
                            Provide the appropriate <literal>-I</literal> switch so
                            that your compilations will locate the header.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Provide the appropriate linker switches so that your
                            program will link with the event builder client libraries
                            and so that the Linux dynamic loader can locate them
                            at run-time.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                As we have done throughout this manual, assume that <literal>DAQROOT</literal>
                is an environment variable that points to the root directory of the
                NSCLDAQ installation.
            </para>
            <para>
                The header for the event builder is named after the class as usual.
                Your source files will need a line like:
            </para>
            <informalexample>
                <programlisting>
    #include &lt;CEventOrderClient.h&gt;
                </programlisting>
            </informalexample>
            <para>
                To locate this, your compilations will need to specify
                <literal>-I$DAQROOT/include</literal>
            </para>
            <para>
                At link time you need to specify three switches:
                <literal>-L$DAQROOT/lib -lEventBuilder -Wl,"-rpath=$DAQROOT/lib"</literal>.
                The first of these adds the NSCLDAQ library directory to the linker
                library search path.  The second requests that
                <filename>libEventBuilder.so</filename> be searched to resolve
                undefined symbols.  The last adds the NSCLDAQ library to the list
                of libraries searched for loadable libraries when the program
                starts.
            </para>
            <para>
                If in fact you did define an environment variables DAQROOT, and this
                is used within a Makefile you should use
                <literal>$(DAQROOT)</literal> wherever <literal>$DAQROOT</literal>
                is used above.
            </para>
        </section>
        <section id="evb-connecting">
            <title>Connecting to the event builder.</title>
            <para>
                The code below shows how to connect to the event builder as
                a client:
            </para>
            <example>
                <title>
                    Connecting to the event builder as a data source.
                </title>
                <programlisting>
    #include &lt;CEventOrderClient&gt;                     <co id='evbc-connect-include' />
    ...
    std::string eventBuilderHost;                          <co id='evbc-connect-hostname' />
    ...
    unsigned int evbPort;                                  <co id='evbc-connect-getport' />
    try {
        evbPort = CEventOrderClient::Lookup(eventBuilderHost);
    }
    catch (CErrnoException&amp; e) {                      <co id='evbc-connect-lookuperr' />
    ...
    }
    
    CEventOrderClient evb(eventBuilderHost, evbPort);    <co id='evbc-connect-create' />
    try {
        evb.Connect();                                   <co id='evbc-connect-connect' />
    }
    catch (CErrnoException&amp; e) {                     <co id='evbc-connect-connecterr' />
    ...
    }
                </programlisting>            
            </example>
            <calloutlist>
                <callout arearefs='evbc-connect-include'>
                    <para>
                        As previously described, this <literal>#include</literal>
                        is required to define the client class.
                    </para>
                </callout>
                <callout arearefs='evbc-connect-hostname'>
                    <para>
                        To connect to the event builder you will need to know
                        the host on which it was started.  For the sake of this
                        example, assume thie variable will be filled in later on
                        with the correct hostname.
                    </para>
                </callout>
                <callout arearefs='evbc-connect-getport'>
                    <para>
                        This segment of code looks up the TCP/IP port
                        on which the event builder is listening for connections.
                        The event builder
                        obtains a service port via the NSCLDAQ Port manager.
                        The port manager, in turn, advertises the event buuilder service.
                    </para>
                </callout>
                <callout arearefs='evbc-connect-lookuperr'>
                    <para>
                        If the port cannot be looked up an exception is thrown.
                        Normally you would fill in some error reporting code here.
                    </para>
                </callout>
                <callout arearefs='evbc-connect-create'>
                    <para>
                        The connection to the event builder will be encapsulated
                        in a <classname>CEventOrderClient</classname> therefore
                        one of these is created.  Note that this does
                        <emphasis>not</emphasis> connect to the event builder.
                    </para>
                </callout>
                <callout arearefs='evbc-connect-connect'>
                    <para>
                        The <methodname>Connect</methodname> method actually attempts
                        to perform the connection to the event builder.
                    </para>
                </callout>
                <callout arearefs='evbc-connect-connecterr'>
                    <para>
                        As with <methodname>Lookup</methodname> an exception is
                        thrown if the connection could not be established.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Disconnecting from the event builder.</title>
            <para>
                The event builder defines a 'clean' disconnect protocol.  If the
                the client simply closes the socket without following this protocol,
                the event builder can consider this an abnormal client termination
                and report an alarm.
            </para>
            <para>
                The disconnect protocol is initiated by either
            </para>
            <itemizedlist>
                <listitem><para>
                    Destroying a connected <classname>CEventOrderClient</classname>
                    object or
                    </para></listitem>
                <listitem><para>
                    Invoking the <methodname>destroy</methodname> method on a
                    connected <classname>CEventOrderClient</classname> object.
                    </para></listitem>
            </itemizedlist>
            <para>
                The code snippet below illustrates the first of these methods.
                <varname>*pEvb</varname> is a pointer to a dynamically allocated
                connected
                <classname>CEventOrderClient</classname> at the start of the
                snippet.
            </para>
            <example>
                <title>Closing an event builder connection</title>
                <programlisting>
delete *pEvb;
                </programlisting>
            </example>
    </section>
    <section>
        <title>Sending data to the event builder.</title>
        <para>
            The event builder allows you to send <firstterm>chains</firstterm> of
            event fragments to it.  A chain is essentially a linked list of
            event fragments.  Each fragment itself consists of a
            header and a body. These data structures are all described in the
            <filename>&lt;fragment.h&gt;</filename> header file.
        </para>
        <para>
            The Event builder client API in turn contains several utilities
            that allow you to send data to the event builder from any of several
            internal representatinos.  In all cases these representations are
            converted to a chain which is then sent to the event builder.
        </para>
        <para>
            Regardless of the representation you choose, you will need
            to fill in the contents of each fragment header.  This data structure
            contains the following fields.
        </para>
        <variablelist>
            <varlistentry>
                <term><fieldsynopsis><type>uint64_t</type> <varname>s_timestamp</varname></fieldsynopsis></term>
                <listitem>
                    <para>
                        Each event must have an extracted timestamp. The
                        first stage of the event builder does an absolute
                        total time ordering of all input fragments by increasing
                        timestamp.
                    </para>
                    <para>
                        The timestamp must be synchronized between
                        all data sources to a high degree of accuracy if this
                        total ordering is going to represent a true time
                        ordering of fragments, since the second stage of the
                        event builder builds events by matching fragments that
                        live within a coincidence window.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><fieldsynopsis><type>uint32_t</type> <varname>s_sourceId</varname></fieldsynopsis></term>
                <listitem>
                    <para>
                        Each data source has a unique id chosen by the source
                        itself.  Furthermore, each client can represent several
                        data sources (all sourcdes system wide must be unique).
                        This field contains the source id that corresponds to the
                        fragment data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><fieldsynopsis><type>uint32_t</type> <varname>s_size</varname></fieldsynopsis></term>
                <listitem>
                    <para>
                        Contains the size of the fragment payload in bytes.
                        this size does not include the size of this fragment
                        header.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            The <filename>&lt;fragment.h&gt;</filename> header also defines
            a <type>Fragment</type> type which contains
            the fields <varname>s_header</varname> which is a a
            <type>FragmentHeader</type> and a
            <fieldsynopsis><type>void*</type> <varname>s_pBody</varname></fieldsynopsis>
            which is a pointer to the body of the event described by
            <varname>s_header</varname>.
        </para>
        <para>
            Finally the <type>FragmentChain</type> contains the fields
            <varname>s_pNext</varname> which is a
            <type>pFragmentChain</type> and points to the next item in the
            chain, and <varname>s_pFragment</varname> which points to a single
            fragment. The last item in the chain has a
            <varname>s_pNext</varname> that is a null pointer.  Fragment chains
            are required to be in timestamp order by event source. 
        </para>
        <para>
            Several overloaded <methodname>submitFragments</methodname> are
            defined in the <classname>CEventOrderClient</classname> class:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis><type>void</type> <methodname>submitFragments</methodname>
                        <methodparam><type>pFragmentChain</type>
                            <parameter>pChain</parameter></methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        <parameter>pChain</parameter> is a pointer to the first
                        element of the fragment chain that will be sent to the
                        event builder
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis><type>void</type> <methodname>submitFragments</methodname>
                    <methodparam><type>size_t</type> <parameter>nFragments</parameter></methodparam>
                    <methodparam><type>pFragment</type> <parameter>ppFragments</parameter></methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        <parameter>nFragmnents</parameter> is the number of
                        fragments to submit while <parameter>ppFragments</parameter>
                        is a pointer to the first element of an array
                        of <type>Fragment</type>s.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis><type>void</type> <methodname>submitFragments</methodname>
                    <methodparam><type>FragmentPointerList</type> <parameter>fragments</parameter></methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        <parameter>fragments</parameter> is an STL <type>list</type>
                        whose elements are <type>pFragment</type>, pointers to
                        <type>Fragment</type>s.
                    </para>
                </listitem>
            </varlistentry>
            
        </variablelist>
    </section>
    <section>
        <title>The Event orderer/event builder API</title>
        <para>
            The event builder itself is a loadable Tcl package rather than
            a program.  This allows experiment designers to:
            <itemizedlist>
                <listitem><para>
                    Provide application dependent user interfaces on top of
                    and around those provided by the event builder.
                    </para></listitem>
                <listitem><para>
                    Tailor the operation of the event builder to meet application
                    specific requirements.
                    </para></listitem>
            </itemizedlist>
        </para>
        <section>
            <title>Starting the event builder/orderer</title>
            <para>
                The example below is a Tcl script fragment that shows
                how to start the event builder. The code assumes that the
                environment variable DAQROOT has been set to the
                top installation directory of the NSCLDAQ being used
                (version 10.2 or later).
            </para>
            <example>
                <title>Starting the event builder</title>
                <programlisting>
lappend auto_path [file join $::env(DAQROOT) TclLibs]   <co id='evb_start_ap' />
package require EventBuilder        <co id='evb_start_require' />

EVB::Start    ?name?                      <co id='evb_start_start' />
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='evb_start_ap'>
                    <para>
                        Adds the Tcl Library directory of the NSCLDAQ to the
                        list of directories searched for packages.  This could
                        also have been done by defining the
                        <literal>TCLLIBS</literal> environment variable.
                        <literal>TCLLIBS</literal> is a space separated list
                        of directories trees that will be added to
                        <varname>auto_path</varname> when
                        <application>tclsh</application> or
                        <application>wish</application> starts.
                    </para>
                </callout>
                <callout arearefs='evb_start_require'>
                    <para>
                        Loads the event builder Tcl package. This package defines
                        the <literal>::EVB::</literal> namespace.  The event
                        builder API lives in this namespace to prevent name
                        conflicts with your application variables and procs.
                    </para>
                </callout>
                <callout arearefs='evb_start_start' >
                    <para>
                        Starts the event builder.  The event builder will use
                        the DAQ Port manager to allocate a Tcp/IP server
                        port as well as to advertise itself to potential
                        clients.  The optional <parameter>name</parameter>
                        parameter specifies the event builder name. Note that
                        if you provide a duplicate name,the script will attempt
                        to pop up a Tk dialog prompting you to continue or not.
                    </para>
                    <para>
                        When this proc has returned, the event builder is listening
                        for connections on that port and the client library will
                        be able to find the event builder.
                    </para>
                    <para>
                        This proc must be called prior to any other
                        procs in the <literal>EVB::</literal> namespace.
                    </para>
                </callout>
            </calloutlist>
          </section>
        </section>
        <section>
            <title>Callbacks</title>
            <para>
                The event builder supports wide variety of callbacks that allow
                user code to intervene when meaningful events occur.  This
                section describes these callbacks and how to set them up.
            </para>
            <section>
                <title>Connection callbacks</title>
                <para>
                    The connection callback invokes user code when a new client
                    has connected to the event builder as a source of event
                    fragments.
                </para>
                <para>
                    When you write the callback, keep in mind that the
                    script you provide will have the host and client
                    description appended to it.  This implies that
                    most event builder connection callbacks wil be
                    <command>proc</command>s
                </para>
                <example>
                    <title>Establishing the connection callback</title>
                    <programlisting>

proc Connection  {host description}  {          <co id="evb_connection_cb" />
    puts "$host just connected: $description"
}

EVB::setConnectionCallback Connection          <co id="evb_connection_cb_establish" />

                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs="evb_connection_cb">
                        <para>
                            This is a sample connection callback proc.  All it
                            does is output information about the connection
                            that was just processed.
                        </para>
                    </callout>
                    <callout arearefs='evb_connection_cb_establish'>
                        <para>
                            The connection callback is established using the
                            <function>EVB::setConnectionCallback</function>
                            procecedure.
                        </para>
                        <para>
                            Note that <function>EVB:Start</function> must have been
                            called prior to this cvall.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section>
                <title>Establishing the disconnect callback</title>
                <para>
                    The disconnect callback is invoked when a data source disconnects.
                    The callback is invoked for both normal and abnormal
                    disconnects (there is a disconnect protocol prior to closing
                    the link if the link closes without that protocol being followed,
                    it is considered an abnormal disconnect).
                </para>
                <para>
                    The disconnect callback is passed the host and description of the
                    source that has disconnected.
                </para>
                <example>
                    <title>Setting up the disconnect callback</title>
                    <programlisting>
proc disconnect {host description} {                    <co id='evb_disconnect_cb' />
    puts "$description disconnected ($host)"
}

EVB::setDisconnectCallback disconnect                   <co id='evb_disconnect_cb_establish' />
                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs='evb_disconnect_cb'>
                        <para>
                            This is a simple sample disconnecdt callback.
                            It just prints information about the disconnect
                            on stdout.
                        </para>
                    </callout>
                    <callout arearefs='evb_disconnect_cb_establish'>
                        <para>
                            This call establishes the callback.  Note that
                            prior to invoking this command,
                            <function>EVT::Start</function> must have been
                            called.
                        </para>
                    </callout>
                </calloutlist>
        </section>
    </section>
</chapter>

<!-- /chapter -->

<!-- manpage 3daq -->
	 <refentry id="daq3-evbclientfw-usercode">
       <refmeta>
          <refentrytitle id='daq3-evbclientfw-usercode-title'>CEvbClientApp</refentrytitle>
          <manvolnum>3daq</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CEvbClientApp</refname>
          <refpurpose>Framework event builder client application.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
#include &lt;CEVBClientApp.h&gt;
class   <ooclass><classname>CEVBClientApp</classname></ooclass> {
        <constructorsynopsis>
        <methodname>CEVBClientApp</methodname>
            <void />
        </constructorsynopsis>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type> <methodname>initialize</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>bool</type> <methodname>dataReady</methodname>
            <methodparam><type>int</type> <parameter>ms</parameter></methodparam>
            <modifier> = 0</modifier>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type> <methodname>getEvents</methodname>
            <void /><modifier> = 0</modifier>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>virtual</modifier><type>void</type><methodname>shutdown</methodname>
        </methodsynopsis>
};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <classname>CEvbClientApp</classname> is an abstract base class for
            applications that use the Event builder data source application
            framework.  This class conatains an interface definition
            that consists of some methods that are pure virtual
            and others for which there is a default implementation.
          </para>
          <para>
            See METHODS below for a description of the base class methods
            as well as the interface methods.
            <link linkend='daq3-evbclientfw-api' endterm='daq3-evbclientfw-apititle' />
            for more information about the methods that are available for your
            custom code to interface with the remainder of the framework.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CEVBClientApp</methodname>
                            <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        The base class constructor is responsible
                        for registering objects that are constructed with the
                        framework.  Note that all objects of this type that are
                        created will be registered allowing for
                        <firstterm>super sources</firstterm> to be created.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier> <type>void</type> <methodname>initialize</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is invoked by the framework exactly once.
                        Almost all of your one-time intialization should be
                        performed here.  The base class provides an empty
                        default implementation so that you do not need to override
                        this method if you do not require any one-time initialization.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier> <type>bool</type> <methodname>dataReady</methodname>
                        <methodparam><type>int</type> <parameter>ms</parameter></methodparam>
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called to determine if the data source you are managing
                        has data to process.  <parameter>ms</parameter> is an
                        estimate of the maximum amount of time you should block
                        prior to returning.
                    </para>
                    <para>
                        Return <literal>true</literal> if there is data to
                        be read (in which case <methodname>getEvents</methodname>
                        will soon be called),  otherwise return <literal>false</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier> <type>void</type> <methodname>getEvents</methodname>
                        <void /><modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called to read events from the data source and
                        submit them to the evenbuilder via one or more calls
                        to <methodname>CEVBClientFramework::submitFragmentList</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier><type>void</type><methodname>shutdown</methodname>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called when the client is being properly shutdown.
                        You should release any resources that were dynamically
                        allocated by your event source.  This is
                        especially important for resources that involve
                        inter-process communications so that they don' have
                        to close down via a timeout.
                    </para>
                </listitem>
            </varlistentry>
         </variablelist>
       </refsect1>
        <refsect1>
           <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
           <para>
            Two types are often used by event fragment sources:
            <type>ClientEventFragment</type> represents the
            metadata for an event fragment along with a pointer to the
            fragment itself.
            <classname>CEVBEventList</classname> is a list of
            <type>ClietEventFragment</type> objects.  It is actually a specific
            <type>std::list</type> and has all of the methods of that class.
           </para>
           <para>
            The <type>ClientEventFragment</type> type is a struct with the
            following members:
           </para>
           <variablelist>
            <varlistentry>
                <term><fieldsynopsis><type>uint64_t</type> <varname>s_timestamp</varname></fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The event fragment timestamp.  For event ordering/building
                        to work, the timestamp for all sources must come from a
                        common timebase and be synchronized.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><fieldsynopsis><type>uint32_t</type> <varname>s_sourceId</varname></fieldsynopsis></term>
                    <listitem>
                        <para>
                            Identifies the source.  In the output of both the
                            event orderer and the builder, each fragment will
                            be tagged with its source id.  Source Ids:
                            <itemizedlist>
                                <listitem>
                                    <para>
                                        Should be unique from source to source.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        Should produce fragments that are
                                        time ordered.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        Each have their own fragment queue. You
                                        therefore do not need to order fragments
                                        across event source only within sources.
                                    </para>
                                </listitem>
                            </itemizedlist>
                        </para>
                    </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <fieldsynopsis><type>uint32_t</type> <varname>s_size</varname></fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The number of bytes in the fragment data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <fieldsynopsis><type>void*</type> <varname>s_payload</varname>
                    </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        A pointer to the event fragment.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>
     </refentry>     
	 <refentry id="daq3-evbclientfw-api">
       <refmeta>
          <refentrytitle id='daq3-evbclientfw-apititle'>CEVBClientFramework</refentrytitle>
          <manvolnum>3daq</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CEVBClientFramework</refname>
          <refpurpose>Event builder client framework.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
#include &lt;EVBFramework.h&gt;
class   <ooclass><classname>CEVBClientFramework</classname></ooclass> {
    <methodsynopsis>
        <modifier>static</modifier>
        <type>void</type><methodname>submitFragmentList</methodname>
        <methodparam>
            <modifier>static</modifier>
            <type>CEVBEventList&amp;</type> <parameter>fragmentList</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier>
        <type>const struct gengetopt_args_info*</type>
        <methodname>getProgramOptions</methodname>
        <void />
    </methodsynopsis>
};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            The event builder framework offers services to the user code
            via the <classname>CEVBClientFramework</classname> class.
            Many of these interfaces are provided as static methods.
            METHODS below describe the interfaces proviced.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type><methodname>submitFragmentList</methodname>
                        <methodparam>
                            <modifier>static</modifier>
                            <type>CEVBEventList&amp;</type> <parameter>fragmentList</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Allows you to submit a list of event fragments to the
                        event orderer.  <parameter>fragmentList</parameter>
                        containst that list of fragments.  For more information
                        about the <classname>CEVBEventList</classname> data type,
                        see
                        <link endterm='daq3-ceventorder-title'
                              linkend='daq3-ceventorder' />.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static</modifier>
                        <type>const struct gengetopt_args_info*</type>
                        <methodname>getProgramOptions</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is used if you extend the command option
                        definition file.  The return value is a pointer to the
                        struct that is created by <application>gengetopt</application>
                        from that file.  The contents of this struct will
                        depend on the final set of command switches, however
                        the struct will be defined in
                        <filename>cmdline.h</filename> which will be created
                        when you first build your application.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>

     </refentry>     
<refentry id="daq3-ceventorder">
<refmeta>
 <refentrytitle id="daq3-ceventorder-title">CEventOrderClient</refentrytitle>
 <manvolnum>3daq</manvolnum>
</refmeta>
<refnamediv>
 <refname >CEventOrderClient</refname>
 <refpurpose>Client of the event orderer</refpurpose>
</refnamediv>

<refsynopsisdiv>

   <synopsis>
#include &lt;CEventOrderClient.h&gt;
#include &lt;fragment.h&gt;

class   <ooclass><classname>CEventOrderClient</classname></ooclass> {
  <constructorsynopsis>
 <methodname>CEventOrderClient</methodname>
 <methodparam><type>std::string</type> <parameter>node-name</parameter></methodparam>
 <methodparam><type>unsigned int</type> <parameter>port</parameter></methodparam>
  </constructorsynopsis>
  <methodsynopsis>
 <type>void</type>
    <methodname>Connect</methodname>
    <methodparam>
        <type>std::string</type><parameter>description</parameter>
    </methodparam>
    <methodparam>
        <type>const char*</type><parameter>pEvbName</parameter>
        <initializer>0</initializer>
    </methodparam>
    <exceptionname>CErrnoException</exceptionname>
  </methodsynopsis>
  <methodsynopsis>
    <type>void</type><methodname>disconnect</methodname>
    <void />
  </methodsynopsis>
    <methodsynopsis><type>void</type> <methodname>submitFragments</methodname>
        <methodparam><type>pFragmentChain</type>
            <parameter>pChain</parameter></methodparam>
    </methodsynopsis>
    <methodsynopsis><type>void</type> <methodname>submitFragments</methodname>
    <methodparam><type>size_t</type> <parameter>nFragments</parameter></methodparam>
    <methodparam><type>pFragment</type> <parameter>ppFragments</parameter></methodparam>
    </methodsynopsis>
    <methodsynopsis><type>void</type> <methodname>submitFragments</methodname>
    <methodparam><type>FragmentPointerList</type> <parameter>fragments</parameter></methodparam>
    </methodsynopsis>
     
  <methodsynopsis>
    <modifier>static</modifier>
    <type>int</type>
    <methodname>Lookup</methodname>
    <methodparam>
        <type>std::string</type><parameter>host</parameter>
    </methodparam>
  </methodsynopsis>
  <exceptionname>
    CErrnoException
  </exceptionname>
  
};
   </synopsis>
</refsynopsisdiv>
<refsect1>
 <title>DESCRIPTION</title>
 <para>
    Provides the client API to the event fragment orderer component of the
    event builder.  The normal operation sequence would be to use the
    <methodname>Lookup</methodname> static method to locate the event builder
    server port, create a <classname>CEventOrderClient</classname> instance
    and invoke <methodname>Connect</methodname> to connect to the event
    builder.
 </para>
 <para>
    Once connected, <methodname>submitFragments</methodname> would be used to send data to the
    server until it's time to disconnect at which time
    the connection is dropped either by destroying the object or by
    calling the <methodname>Disconnect</methodname> method.
 </para>
</refsect1>
<refsect1>
 <title>
METHODS
 </title>
 <variablelist>
    <varlistentry>
        <term>
            <constructorsynopsis>
                <methodname>CEventOrderClient</methodname>
                <methodparam><type>std::string</type> <parameter>node-name</parameter></methodparam>
                <methodparam><type>unsigned int</type> <parameter>port</parameter></methodparam>
            </constructorsynopsis>
        </term>
        <listitem>
            <para>
                Constructs an instance of an event order client object.
                The <parameter>node-name</parameter>
                and <parameter>port</parameter> define the Tcp/IP
                of the connection that will be made with the event builder.
            </para>
            <para>
                The connection is not actually made until the
                <methodname>Connect</methodname> method is invoked
                (see below).
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <methodsynopsis>
              <type>void</type><methodname>disconnect</methodname>
              <void />
            </methodsynopsis>
        </term>
        <listitem>
            <para>
                Disconnect a connected client object.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>int</type>
                <methodname>Lookup</methodname>
                <methodparam>
                    <type>std::string</type><parameter>host</parameter>
                </methodparam>
                <methodparam>
                    <type>const char*</type><parameter>pEvbName</parameter>
                    <initializer>0</initializer>
                </methodparam>
              </methodsynopsis>
              <exceptionname>
                CErrnoException
              </exceptionname>
        </term>
        <listitem>
            <para>
                Attempts to look up the port on which an event builder for the
                current user is running.  This is done by contacting the
                NSCL port manager on the specified <parameter>host</parameter>.
             </para>
             <para>
                If the optional <parameter>pEvbName</parameter> parameter is
                supplied and is not a null pointer, it is taken to be the name
                of the event builder to which the connection should be made.
                If this parameter is null or missing, the port looked up is
                that of the default event orderer for the caller's username.
            </para>
            <para>
                On failure, a <classname>CErrnoException</classname> is thrown
                which will describe the reason and context of the error.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>
            <methodsynopsis>
            <type>void</type>
               <methodname>Connect</methodname>
               <methodparam>
                   <type>std::string</type><parameter>description</parameter>
               </methodparam>
               <exceptionname>CErrnoException</exceptionname>
             </methodsynopsis>
        </term>
        <listitem>
            <para>
                Attempts to connect to the event builder described
                by the constructor parameters.
                <parameter>description</parameter> will be passed to the
                event builder as a description of the event source.
                The description will be used on the event builder GUI.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
         <term>
             <methodsynopsis><type>void</type> <methodname>submitFragments</methodname>
                 <methodparam><type>pFragmentChain</type>
                     <parameter>pChain</parameter></methodparam>
             </methodsynopsis>
         </term>
         <listitem>
             <para>
                 <parameter>pChain</parameter> is a pointer to the first
                 element of the fragment chain that will be sent to the
                 event builder
             </para>
         </listitem>
     </varlistentry>
     <varlistentry>
         <term>
             <methodsynopsis><type>void</type> <methodname>submitFragments</methodname>
             <methodparam><type>size_t</type> <parameter>nFragments</parameter></methodparam>
             <methodparam><type>pFragment</type> <parameter>ppFragments</parameter></methodparam>
             </methodsynopsis>
         </term>
         <listitem>
             <para>
                 <parameter>nFragmnents</parameter> is the number of
                 fragments to submit while <parameter>ppFragments</parameter>
                 is a pointer to the first element of an array
                 of <type>Fragment</type>s.
             </para>
         </listitem>
     </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
    <title>DATA STRUCTURES</title>
    <para>
        The <filename>fragment.h</filename> header defines several event
        fragment related data structures:
    </para>
    <para>
        The <type>FragmentHeader</type> data type is the main data type.
        It defines the struct that contains meta-data about an event fragment:
This data structure
            contains the following fields.
    </para>
    <variablelist>
        <varlistentry>
            <term><fieldsynopsis><type>uint64_t</type> <varname>s_timestamp</varname></fieldsynopsis></term>
            <listitem>
                <para>
                    Each event must have an extracted timestamp. The
                    first stage of the event builder does an absolute
                    total time ordering of all input fragments by increasing
                    timestamp.
                </para>
                <para>
                    The timestamp must be synchronized between
                    all data sources to a high degree of accuracy if this
                    total ordering is going to represent a true time
                    ordering of fragments, since the second stage of the
                    event builder builds events by matching fragments that
                    live within a coincidence window.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><fieldsynopsis><type>uint32_t</type> <varname>s_sourceId</varname></fieldsynopsis></term>
            <listitem>
                <para>
                    Each data source has a unique id chosen by the source
                    itself.  Furthermore, each client can represent several
                    data sources (all sourcdes system wide must be unique).
                    This field contains the source id that corresponds to the
                    fragment data.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><fieldsynopsis><type>uint32_t</type> <varname>s_size</varname></fieldsynopsis></term>
            <listitem>
                <para>
                    Contains the size of the fragment payload in bytes.
                    this size does not include the size of this fragment
                    header.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
    <para>
        The <filename>&lt;fragment.h&gt;</filename> header also defines
        a <type>Fragment</type> type which contains
        the fields <varname>s_header</varname> which is a a
        <type>FragmentHeader</type> and a
        <fieldsynopsis><type>void*</type> <varname>s_pBody</varname></fieldsynopsis>
        which is a pointer to the body of the event described by
        <varname>s_header</varname>.
    </para>
    <para>
        Finally the <type>FragmentChain</type> contains the fields
        <varname>s_pNext</varname> which is a
        <type>pFragmentChain</type> and points to the next item in the
        chain, and <varname>s_pFragment</varname> which points to a single
        fragment. The last item in the chain has a
        <varname>s_pNext</varname> that is a null pointer.  Fragment chains
        are required to be in timestamp order by event source. 
    </para>
</refsect1>
<refsect1>
    <title>EXCEPTIONS</title>
    <para>
        The following exception types can be thrown:
    </para>
    <variablelist>
        <varlistentry>
            <term>CErrnoException</term>
            <listitem>
                <para>
                    Reports Linux system service errors.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
 </refsect1>
</refentry>

<!-- /manpage -->
<!-- manpage 1evb -->

    <refentry id="evb1_barrierstats_incomplete">
      <refmeta>
         <refentrytitle>EVB::BarrierStats::incomplete</refentrytitle>
         <manvolnum>1evb</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>EVB::BarrierStats::incomplete</refname>
         <refpurpose>Display incomplete barrier statistics</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <cmdsynopsis>
        <command>
package require EVB::barriers
        </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
EVB::BarrierStats::incomplete <replaceable>window ?options?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>window</replaceable> configure | cget  <replaceable>?options?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>window</replaceable> setItem <replaceable> key value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>window</replaceable> clear <replaceable>?value?</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>window</replaceable> reinit
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>window</replaceable>idlist
            </command>
        </cmdsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>DESCRIPTION</title>
         <para>
            Provides a user interface element that can display the number
            of times event sources did not participate in a barrier prior
            to the barrier timeout.  Each count represents an exceptional
            condition that is most likely an error.
         </para>
         <para>
            The visual appearance of this widget is a scrolling list two columns
            wide.  The left column contains a set of source ids while the right
            columns contains the number of times that source did not participate
            in a barrier.
         </para>
      </refsect1>
      <refsect1>
         <title>
            OPTIONS
         </title>
         <variablelist>
            <varlistentry>
                <term><option>-title</option></term>
                <listitem>
                    <para>
                        The text of a title that is displayed above the entire
                        widget.  This defaults to <literal>Missing barrier frags</literal>
                        if not configured.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-lefttitle</option></term>
                <listitem>
                    <para>
                        Supplies a title above the column containing the source id.
                        If not configured this defaults to <literal>Srcid</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-righttitle</option></term>
                <listitem>
                    <para>
                        Supplies a title above the column containing
                        the counters.  If not configured, this defaults to
                        <literal>Missing</literal>
                    </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect1>
      <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <command><replaceable>window</replaceable> setItem
                    <replaceable>source count</replaceable>
                    </command>
                </term>
                <listitem>
                    <para>
                        Sets the missing fragment count for the specified
                        <parameter>source</parameter> to
                        <parameter>count</parameter>.  If necessary
                        a new entry is made for the source in the widget.
                    </para>
                    <para>
                        The widget always maintains the sources sorted by
                        id.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command><replaceable>window</replaceable> clear
                    <replaceable>?value?</replaceable>
                    </command>
                </term>
                <listitem>
                    <para>
                        Without the <parameter>value</parameter> parameter,
                        all counters in all sourcdes are set to zero.  If
                        a value is supplied it is used to set the value of
                        all of the counters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command><replaceable>window</replaceable> reinit</command></term>
                <listitem>
                    <para>
                        Removes all source id/counter pairs fromt the widget.
                        This returns the widget to the visual state it was in
                        prior to the first <command>setItem</command>
                        method call.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command><replaceable>window</replaceable> idlist</command></term>
                <listitem>
                    <para>
                        Returns a list of the sources that exist in the
                        widget.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
      </refsect1>
    </refentry>
      <refentry id="evb1_barrierstats_queueBarriers">
        <refmeta>
           <refentrytitle>EVB::BarrierStats::queueBarriers</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>EVB::BarrierStats::queueBarriers</refname>
           <refpurpose>Displays per queue barrier statistics</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require EVB::barriers
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::BarrierStats::queueBarriers <replaceable>window ?options?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>window</replaceable> setStatistic <replaceable>source type count</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>window</replaceable> clear
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>window</replaceable> reset
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides a widget in which per source barrier statistics can be
            displayed.  A barrier is a set of fragments with a non-zero
            barrier type and indicates some sort of global synchronization.
           </para>
           <para>
            The appearance of this widget is a scrolling list of ids on
            the left each linked to a scrolling list containing barrier type/
            barrier count paitrs.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
                <varlistentry>
                    <term><option>-text</option></term>
                    <listitem>
                        <para>Provides a title for the overall widget.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-lefttitle</option></term>
                    <listitem>
                        <para>Title for the widget's left column (source ids).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-righttitle</option></term>
                    <listitem>
                        <para>Title for the widget's right column
                            (per type statistics widget).
                        </para>
                    </listitem>
                </varlistentry>   
           </variablelist>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term><command>setStatistic
                    <replaceable>src type count</replaceable></command></term>
                    <listitem>
                        <para>
                            Sets the number of times, <parameter>count</parameter>,
                            a specific barrier type,
                            <parameter>type</parameter>,
                            has been emitted by a source who's id is
                            <parameter>src</parameter>.
                        </para>
                        <para>
                            If necessary new source widgets are created or new
                            barrier type rows in existing source widgets.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>clear</command></term>
                    <listitem>
                        <para>
                            Clears counters on all barrier types for all sources.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>reset</command></term>
                    <listitem>
                        <para>
                            Empties the widget of all statistics.  The appearance
                            of the widget will be as if
                            <command>setStatistic</command> has never been
                            called.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
      </refentry>
      <refentry id="evb1_barrierstats_Summary">
        <refmeta>
           <refentrytitle>EVB::BarrierStats::Summary</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>EVB::BarrierStats::Summary</refname>
           <refpurpose>UI element to summarize barrier statistics.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
EVB::BarrierStats::Summary <replaceable>window ?options?</replaceable>
            </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides a user interface element that can be used to display a
            summary of the set of barrier statistics that have been seen by
            the event orderer.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-completecount</option></term>
                <listitem>
                    <para>
                        Provides the number of complete barriers that have been
                        processed.  A  barrier is complete if it has contributions
                        from all event sources within the timeout.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-incompletecount</option></term>
                <listitem>
                    <para>
                        Proivdes the number of barriers that havwe been processed
                        that are missing contributions from at least one
                        event source.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-heterogenouscount</option></term>
                <listitem>
                    <para>
                        Provides the number of barriers that are heterogenous
                        (complete or not).  A heterogenous barrier is one that has
                        fragments with more than one distinct barrier type.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>
      <refentry id="evb1_callbackmanager">
        <refmeta>
           <refentrytitle>EVB::CallbackManager</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>EVB::CallbackManager</refname>
           <refpurpose>Object that manages callback sets.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
EVB::CallbackManager <replaceable>name</replaceable>
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> define <replaceable>callback-name</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> register <replaceable>callback-name script</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> get <replaceable>callback-name</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> invoke <replaceable>callback-name substitutions values</replaceable>
                </command>
            </cmdsynopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Manages a set of callbacks.  This can be used by megawidgets and
            supports script substitution patterns.  
           </para>
           <para>
            The conceptual idea is that the application instantiates a callback
            manager and uses <methodname>define</methodname> to define
            callbacks.  As callback scripts are supplied they are inserted
            into the callback manager using <methodname>register</methodname>.
            When it is time to run a callback, <methodname>invoke</methodname>
            allows you to do so specifying a set of substition keys  and the
            values to substitute for those keys in the script.
           </para>
           <para>
            <methodname>invoke</methodname> runs callbacks at level 0 using
            <command>uplevel #0</command>.
           </para>
           <para>
            When constructing a manager, supply a single parameter that provides
            a name for the callback manager object.  The special name
            <literal>%AUTO%</literal> allocates a unique name for the object
            for you.  Construction returns the name of the object.  The following
            idiom is therefore best used when using <literal>%AUTO%</literal>:
           </para>
           <informalexample>
            <programlisting>
set cbManager [EVB::CallbackManager %AUTO%]
$cbManager define mycallback;    # e.g.
            </programlisting>
           </informalexample>
        </refsect1>
        <refsect1>
           <title>
              METHODS
           </title>
           <variablelist>
                <varlistentry>
                    <term><command>define <replaceable>callback-name</replaceable></command></term>
                    <listitem>
                        <para>
                            Defines a callback.   Clients can only register callback
                            scripts for callbacks that have been defined via this
                            method.  Furthermore, only define callbacks can be
                            <methodname>invoked</methodname> without an error
                            being thrown.  Callbacks have names (<parameter>callback-name</parameter>).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>register <replaceable>callback-name script</replaceable></command></term>
                    <listitem>
                        <para>
                            Registers a <parameter>script</parameter> for the
                            callback <parameter>callback-name</parameter>.
                        </para>
                        <para>
                            If <parameter>script</parameter> is empty, the
                            callback is assumed to have no script.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>get <replaceable>callback-name</replaceable></command></term>
                    <listitem>
                        <para>
                            Returns the script that is registered on the
                            <parameter>callback-name</parameter>.  If there is no
                            script registered, an empty string is returned.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>invoke <replaceable>callback-name substitutions values</replaceable></command></term>
                    <listitem>
                        <para>
                            Invokes the callback registered on <parameter>callback-name</parameter>.
                            If the registered script is empty, this is a no-op.
                            Prior to executing the script, all occurences of
                            the strings in the list <parameter>substitutions</parameter>
                            are replaced by corresponcing elements in the list
                            <parameter>values</parameter>
                        </para>
                        <para>
                            This mechanism allows callers to supply information to
                            the callback as desired by that callback.
                        </para>
                    </listitem>
                </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>
      <refentry id="evb1_evb_cconnectionlist">
        <refmeta>
           <refentrytitle>EVB::connectionList</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>EVB::connectionList</refname>
           <refpurpose>List event builder connections</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require EVB::connectionList
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::connectionList <replaceable>window ?options?</replaceable>
                </command>
            </cmdsynopsis>


        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides an auto updating widget that displays the set of data
            source connection clients that are attached to the event builder
            fragmento orderer.  Creating the widget also schedules a repeating
            task to update the contents of the widget.
           </para>
           <para>
            The widget displays a table with several columns:
           </para>
           <variablelist>
            <varlistentry>
                    <term>Host</term>
                    <listitem><para>IP address of connected clients</para></listitem>
            </varlistentry>
            <varlistentry>
                <term>Description</term>
                <listitem><para>The connection description sent to the server when the
                    client connected.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>State</term>
                <listitem><para>The connection state of the client</para></listitem>
            </varlistentry>
            <varlistentry>
                <term>Stalled</term>
                <listitem><para>Indicates if the source has not sent fragments
                    recently while other sources have.
                    </para></listitem>
            </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
                <varlistentry>
                    <term><option>-updaterate</option></term>
                    <listitem>
                        <para>
                            The number of seconds between updates
                            (must be an integer).
                        </para>
                    </listitem>
                </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>
      <refentry id="evb1_GUI_procs">
        <refmeta>
           <refentrytitle>EVB::GUI procs</refentrytitle>
           <manvolnum>evb1</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>EVB::GUI procs</refname>
           <refpurpose>Standard monitor UI procs.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require EVB::GUI                
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::createGui <replaceable>window</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::maintainGUI <replaceable>window update-ms</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            These commands support creating and maintaining the default
            Event orderer monitoring gui.  See PROCEDURES below for
            information about each of the <command>proc</command> and their
            parameters.
           </para>
        </refsect1>
        <refsect1>
           <title>
              PROCEDURES
           </title>
           <variablelist>
            <varlistentry>
                <term><command>EVB::createGui <replaceable>window</replaceable></command></term>
                <listitem>
                    <para>
                        Creates a new instance of the standard event orderer
                        monitor widget set.  This is a tabbed notebook where each
                        page of the notebook displays a different set of statistics.
                        <parameter>windowM</parameter> is the Tk window path
                        for the top of the window hierarchy created by this
                        command.
                    </para>
                    <para>
                        You must <command>pack</command>, <command>grid</command>
                        or <command>place</command> <parameter>window</parameter> to
                        position it within a container widget (e.g. a frame or
                        toplevel widget).  Until you do the window is off-screen.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>EVB::maintainGUI <replaceable>window update-ms</replaceable></command></term>
                <listitem>
                    <para>
                        Starts a repeating task to maintain the contents of a
                        standard Event Orderer.  <parameter>window</parameter>
                        is the window that is at the top of the hierarchy of
                        windows created by a call to <command>EVB::createGui</command>.
                        <parameter>update-ms</parameter> is the number of milliseconds
                        between user interface updates.  <parameter>update-ms</parameter>
                        should be on the order of a second or more.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>
      <refentry id="evb1_inputstatistics_statusdisplay">
        <refmeta>
           <refentrytitle>EVB::inputStatistics::statusDisplay</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>EVB::inputStatistics::statusDisplay</refname>
           <refpurpose>Widget to display input statitics</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require EVB::inputStatistics
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::inputStatistics::statusDisplay <replaceable>window ?options?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> configure <replaceable>options</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> cget <replaceable>?option-name?</replaceable> 
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable>  addDataSource <replaceable>id ?args?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable>  removeDataSource <replaceable>id</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> updateDataSource <replaceable>id args</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> getDataSource <replaceable>id</replaceable>
                </command>
            </cmdsynopsis>

            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable>  listSources
                </command>
            </cmdsynopsis>


        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides a megawidget that displays queue input statistics.  The
            widget is made up of a summary region and a region that is a dynamic
            number of source queue widgets (see
            <link linkend='evb1_inputstatistics_queuedisplay'
                endterm='evb1_inputstatistics_queuedisplay_title' />
            for more information).
           </para>
           <para>
            The summary display is managed via configuration options (see
            OPTIONS below), while methods are provided to manage the contents
            of the detailed per queue statistics displays (see METHODS below).
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-fragments</option></term>
                <listitem>
                    <para>
                        Sets the number of fragments that are in all queues.
                        This is intended to be the total number of fragments
                        awaiting output.  It appears in the summary part of the
                        widget.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-oldest</option></term>
                <listitem>
                    <para>Sets the timestamp of the oldest fragment in all queues.
                        This appears in the summary display part of the widget.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-newest</option></term>
                <listitem>
                    <para>
                        Sets the timestamp of the newest fragment in all queues.
                        This appears in the summary display part of the widget.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-deepestid</option></term>
                <listitem>
                    <para>
                        Sets the source id of the input queue that currently has the
                        most fragments in it.
                        This appears in the summary display part of the widget.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-deepestdepth</option></term>
                <listitem>
                    <para>
                        Sets the number of fragments in the the queue that has
                        the most fragments.
                        This appears in the summary display part of the widget.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-columns</option></term>
                <listitem>
                    <para>
                        The per queue statistic displays are organized into a table.
                        This option defines the number of columns in that table.
                        The number of rows is determined by the number of source
                        queues that are displayed.   The default for
                        <option>-columns</option> is <literal>1</literal>.
                        This option is dynamic.  When changed, the table layout of
                        the table immediately changes.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <variablelist>
                <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::inputStatistics::statusDisplay <replaceable>window ?options?</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a new status display.  The <parameter>window</parameter>
                        parameter is a Tk window path and represents a frame that
                        encloses the megawidget.  It also represents the
                        object when invoking the methods described in this section.
                    </para>
                    <para>
                        The remainder of the parameters are configuration options
                        and their values.  See the OPTIONS section above for
                        a description of the allowed options.
                    </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> configure <replaceable>options</replaceable>
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Changes the valueo of one or more configuration options
                            described by the list of <parameter>options</parameter>.
                            The legal options are described above in the
                            OPTIONS section of this manpage.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> cget <replaceable>?option-name?</replaceable> 
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If an <parameter>option-name</parameter> is provided,
                            the value of that option is returned.  If no option
                            name is provided the value of all options are returned.
                        </para>
                        <para>
                            See OPTIONS above for the set of options supported by
                            this widget.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable>  addDataSource <replaceable>id ?args?</replaceable>
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a new data source queue widget to the per queue
                            statistics table.  The <parameter>id</parameter> parameter
                            is the input source id this queue statistics display
                            will represent.
                        </para>
                        <para>
                            If <parameter>args</parameter> is supplied,
                            it should be additonal option/value pairs for an
                            <literal>EVB::inputstatsitics::queueDisplay</literal>
                            widget.  For information about the options that are
                            supported, see the OPTIONS section of
                             <link linkend='evb1_inputstatistics_queuedisplay'
                                    endterm='evb1_inputstatistics_queuedisplay_title' />.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable>  removeDataSource <replaceable>id</replaceable>
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Removes the data source <parameter>id</parameter> from
                            the data source statistics display.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> updateDataSource <replaceable>id args</replaceable>
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Updates the contents of one of the source queue
                            statistics.  <parameter>id</parameter> is the
                            queue identifier for the statistics widget to update.
                            <parameter>args</parameter> are option/value pairs
                            for the <literal>EVB::inputstatsitics::queueDisplay</literal>
                            widget.  For information about the options that are
                            supported, see the OPTIONS section of
                             <link linkend='evb1_inputstatistics_queuedisplay'
                                    endterm='evb1_inputstatistics_queuedisplay_title' />.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> getDataSource <replaceable>id</replaceable>
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the widget that corresponds to the
                            source queue statistics widget <parameter>id</parameter>.
                            For more information about what can be done with this
                            widget see
                            <link linkend='evb1_inputstatistics_queuedisplay'
                                  endterm='evb1_inputstatistics_queuedisplay_title' />
                            For information about the options that are
                            supported, see the OPTIONS section of
                             <link linkend='evb1_inputstatistics_queuedisplay'
                                    endterm='evb1_inputstatistics_queuedisplay_title' />.
                        </para>
                        <para>
                            Note that you should not <command>destroy</command>
                            this widget manually but shouild use the
                            <command>removeDataSource</command> method of this
                            widget instead.  If you do not heed this advice
                            errors will almost certainly result.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable>  listSources
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a list of the data source ids that
                            correspond to queue widgets that exist.
                            Each one of these can be used in a call
                            to e.g. <command>gtDataSource</command> without
                            an error.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect1>
      </refentry>
      <refentry id="evb1_inputstatistics_queuestats">
        <refmeta>
           <refentrytitle id='evb1_inputstatistics_queuestats_title'>
            EVB::inputStatistics::queueStats</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>EVB::inputStatistics::queueStats</refname>
           <refpurpose>Per queue input statistics widget</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require EVB::inputStatistics
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::inputStatistics::queueStats window <replaceable>?options?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> updateQueue <replaceable>source depth oldest output-count</replaceable>
                    </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> clear
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> reset
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides a widget that can dipslay per queue input statistics.
            This is an <command>EVB::utility::sortedWidget</command>, where
            each of the widgets is an
            <command>EVB::inputStatistics::queueDisplay</command> widget.
           </para>
           <para>
            See <link endterm='evb1_utility_sortedwidget'
            linkend='evb1_utility_sortedwidget_title' /> for information about
            the <command>sortedWidget</command> UI element.  See
            <link endterm='evb1_inputstatistics_queuedisplay'
                  linkend='evb1_inputstatistics_queuedisplay_title' /> for
            information about the <command>queueDisplay</command> widget.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-title</option></term>
                <listitem>
                    <para>
                        Provides a title for the widget.  This is displayed
                        on the upper margin of the widget.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-lefttitle</option></term>
                <listitem>
                    <para>
                        Provides a title for the source id column of the
                        widget (leftcolumn).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-righttitle</option></term>
                <listitem>
                    <para>
                        Provides a title for the column that contains the
                        queue display widgets (right column).
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            EVB::inputStatistics::queueStats window <replaceable>?options?</replaceable>
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates the widget.  The <parameter>window</parameter>
                            command parameter is the window name for the
                            top level of the widget hierarchy this creates.
                            This must not be the path to an existing widget.
                        </para>
                        <para>
                            If <parameter>options</parameter> are supplied, they
                            represent configuration options described in the
                            OPTIONS section above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> updateQueue <replaceable>source depth oldest output-count</replaceable>
                                </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Updates the statistics in a queueDisplay widget.
                            <parameter>source</parameter> represents the data source
                            and selects which queueDisplay widget to update.
                            If there is no queueDisplay widget associated with
                            <parameter>source</parameter> a new one is made.
                        </para>
                        <para>
                            The remainder of the parameters are statistics
                            value to put in the widget. <parameter>depth</parameter>
                            is intended to be the number of fragments currently in
                            that queue.  <parameter>oldest</parameter> is intende to
                            be the timestamp of the fragment at the head of the queue
                            and <parameter>output-count</parameter> is intended
                            to be the number of fragments that have been removed
                            from the front of the queue (because they were sorted
                            and emitted to the output stage).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> clear
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Zeroes the statistics on all of the output
                            queue widgets.  To zero a specific widget
                            use <command>updateQueue</command> and pass in 0
                            for all of the counter values.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> reset
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Destroys all of the per queue statistics user interface
                            elements.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
      </refentry>
      <refentry id="evb1_inputstatistics_queuedisplay">
        <refmeta>
           <refentrytitle id='evb1_inputstatistics_queuedisplay_title'>
            ::EVB::inputStatistics::queueDisplay
           </refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>::EVB::inputStatistics::queueDisplay</refname>
           <refpurpose>Display input queue statistics</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require EVB::inputStatistics
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
::EVB::inputStatistics::queueDisplay <replaceable>window ?options?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>window</replaceable> configure <replaceable>options</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>window</replaceable> cget <replaceable>option-name</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides a widget that can display input queue statistics.  The
            Widget displays the queue id, the number of fragments in the
            queue (depth), the timestamp of the element at the head of the queue
            and the count of the number of elements emitted from the queue.
           </para>
           <para>
            The process maintaining the UI is expected to update the contents
            of this widget (it does not auto-update).  This is done by
            using the <command>configure</command> method to set the configuration
            options described in the OPTIONS section below.
           </para>      
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-id</option></term>
                <listitem>
                    <para>
                        The id of the input queue.  This appears as a title
                        on the inside margin of the widget.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-depth</option></term>
                <listitem>
                    <para>
                        Specifies the number of fragments to display in the
                        <literal>Depth</literal> statistic for the widget.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-oldest</option></term>
                <listitem>
                    <para>
                        Specifies the timestamp that should appear in the
                        <literal>Oldest:</literal> statistic of the widget.
                    </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-outcount</option></term>
                    <listitem>
                        <para>
                            Speicfies the number of fragments that have been
                            output from a queue. This appears as the
                            <literal>Out frags</literal> statistic.
                        </para>
                    </listitem>
                </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>
      
      <refentry id="evb1_inputstatistics_summarydisplay">
        <refmeta>
           <refentrytitle id='evb1_inputstatistics_summarydisplay_title'>EVB::inputStatistics::summaryDisplay</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>EVB::inputStatistics::summaryDisplay</refname>
           <refpurpose>Summary of input statistics.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
EVB::inputStatistics::summaryDisplay <replaceable>window ?options?</replaceable>
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> configure <replaceable>options</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> cget <replaceable>?option-nanme?</replaceable>
                </command>
            </cmdsynopsis>


        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides a widget in which summary statistics for input queues can
            be displayed.  The summary statistics consist of the oldest an
            newest in-flight timestamps, the source id of the input queue with
            the most in-flight fragments and the number of fragments in that
            <firstterm>deepest</firstterm> queue.
           </para>
           <para>
            The actual statistic values displayed are set by using configuration
            options.  See OPTIONS below for more information about these.  The
            widget has no public methods.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-fragments</option></term>
                <listitem>
                    <para>
                        Specifies the value to display as the total number
                        of queued fragments (across all queues).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-oldest</option></term>
                <listitem>
                    <para>
                        Specifies the value to display as the
                        timestamp of the oldest fragment in flight.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-newest</option></term>
                <listitem>
                    <para>
                        Specifies the value to display as the timestamp of the
                        newest in-flight fragment.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-deepestid</option></term>
                <listitem>
                    <para>
                        Specifies the value to display as the source id with the
                        most fragments in its queue (deepest queue).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-deepestdepth</option></term>
                <listitem>
                    <para>
                        Specifies the value to display as the number of fragments
                        in the deepest queue.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>



      <refentry id="evb1_latefragments">
        <refmeta>
           <refentrytitle id='evb1_latefragments_title'>EVB::lateFragments</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>EVB::lateFragments</refname>
           <refpurpose>Late fragment statistics</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require EVB::Late
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::LateFragments <replaceable>window ?options?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> configure <replaceable>options</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> cget <replaceable>?option-name?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> source <replaceable>id count late</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> clear
                </command>
            </cmdsynopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides a widget that displays data late statistics.   A data late
            event is one where a fragment arrives sufficiently late relative
            to its cohorts in time that when it is emitted it will result in
            a break in total ordering of timestamps.
           </para>
           <para>
            The widget itself is divided into a pair of subwidgets.  A summary
            and per input queue statistics.  The summary data are controlled by
            widget options while the per-queue information is controlled by
            method calls.  See the OPTIONS and METHODS sections below
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-count</option></term>
                <listitem>
                    <para>
                        Sets the total number of late fragments as displayed in
                        the summary part of the widget.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-worst</option></term>
                <listitem>
                    <para>
                        Sets the worst case timestamp difference between the
                        a late fragment and the time limit for when it should have
                        been received.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <para>
                The <command>configure</command> and <command>cget</command>
                methods operate just like  the Tk widget
                <command>configure</command> and <command>cget</command>
                methods for all widgets.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> source <replaceable>id count late</replaceable>
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Specifices the <parameter>count</parameter> of late fragments and the largest
                            time difference for <parameter>lateM</parameter> fragments for a specific
                            data source <parameter>id</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> clear
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Removes all per source statistics entries from
                            the per-queue section of the widget.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
            
      </refentry>



      <refentry id="evb1_latesummary">
        <refmeta>
           <refentrytitle id='evb1_latesummary_title'>EVB::lateSummary</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>EVB::lateSummary</refname>
           <refpurpose>Widget to display summar of data late fragments.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
EVB::lateSummary <replaceable>window ?options?</replaceable>
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> configure <replaceable>options</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> cget <replaceable>?option-name?</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides a widget that can display a summary of data late cases.
            The widget contents are completely controlled by configuration
            options.  See OPTIONS below.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-count</option></term>
                <listitem>
                    <para>
                        Sets the contents of the total late fragment count
                        field of the widget.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-worst</option></term>
                <listitem>
                    <para>
                        Sets the contents of the worst case timestamp difference
                        field of the widget.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>
      <refentry id="evb1_outputstatistics">
        <refmeta>
           <refentrytitle>::EVB::outputStatistics</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>::EVB::outputStatistics</refname>
           <refpurpose>Complete output statistics widget</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require EVB::outputStatistics
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
::EVB::outputStatistics <replaceable>window ?options?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> configure <replaceable>options</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> cget <replaceable>?option-name?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> addSource <replaceable>srcid fragments</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> clear <replaceable>?value?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable>  reinit                
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> listSources
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This megawidget displays statistics about the fragments that have
            been removed from source queues.  It consists of a summary region
            that shows the total number of fragments and a per-queue area
            that shows the fragments removed from each queue.
           </para>
           <para>
            See the OPTIONS and METHODS sections below for information that
            describes how to control the contents of those sections.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-totalfragments</option></term>
                <listitem>
                    <para>
                        Sets the total number of fragments emitted.  This value
                        appears in the summary region of the widget.
                    </para>
                </listitem>
                </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <para>
                The <command>configure</command> and <command>cget</command>
                methods operate just like those methods for any other
                Tk widget.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> addSource <replaceable>srcid fragments</replaceable>
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets source output statistics.  <parameter>srcid</parameter>
                            is the id of a dta source.  <parameter>fragments</parameter>
                            is the number of fragments ordered from that queue
                            (and output).  If necessary, a new row in the
                            per source statistics region is created for this
                            data source.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> clear <replaceable>?value?</replaceable>
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Clears the output counts on all sources.  If
                            the optional parameter <parameter>value</parameter>
                            is supplied all source counts are set to that value.
                            Otherwise all source counts are set to zero.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable>  reinit                
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reinitializes the per-source region of the widget
                            by removing all sources ids and their associated
                            counter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> listSources
                            </command>
                        </cmdsynopsis>
                        
                    </term>
                    <listitem>
                        <para>
                            Returns a list of the source ids that are
                            currently known to the per source statistics.
                            region.  Note that if called just after a
                            <command>reinit</command>, this will return
                            an empty list.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>

      </refentry>
      <refentry id="evb1_outputsummary">
        <refmeta>
           <refentrytitle>::EVB::outputSummary</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>::EVB::outputSummary</refname>
           <refpurpose>Summarize output statistics</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require outputStatistics
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
::EVB::outputSummary <replaceable>window ?options?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> configure <replaceable>options</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> cget <replaceable>?option-name</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Supplies a widget that summarizes the output traffic of the event
            orderer. The contents of this widget are completely controlled by
            the configuration options described in OPTIONS below.
            The <command>configure</command> and
            <command>cget</command> methods do exactly what their
            Tk counterparts do.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-fragments</option></term>
                <listitem>
                    <para>
                        Determines the value displayed for the total number
                        of output fragments.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-hottestid</option></term>
                <listitem>
                    <para>
                        Determines the value displayed for the
                        <firstterm>hottest</firstterm> source id.
                        The hottest source is the one that has output the most
                        fragments.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-hottestcount</option></term>
                <listitem>
                    <para>
                        Determines the value displayed for the number of
                        fragments output by the hottest source.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-coldestid</option></term>
                <listitem>
                    <para>
                        Determines the value displayed for the
                        <firstterm>coldest</firstterm> source id.  The
                        coldest source id is the one that has output the fewest
                        fragments.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-coldestcount</option></term>
                <listitem>
                    <para>
                        Determines the value displayed for the number of fragments
                        output by the coldest source.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>
      <refentry id="evb1_utillity_sortedpair">
        <refmeta>
           <refentrytitle id="evb1_utillity_sortedpair_title">
                ::EVB::utility::sortedPair</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>::EVB::utility::sortedPair</refname>
           <refpurpose>Key value pair widget</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require EVButilities
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::utility::sortedPair <replaceable>window ?options?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> configure <replaceable>options</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> cget <replaceable>?option-name</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable>  setItem <replaceable>key value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> clear <replaceable>?value?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> reinit
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> idlist
                </command>
            </cmdsynopsis>


        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This is a utility widget that provides a dynamic scrolling list
            of label pairs.   The value in the left label in each pair is called the
            <firstterm>key</firstterm>.  The list is maintained sorted by key
            values.
           </para>
           <para>
            Use cases for this widget are for a set of counters that are
            associated with some set of things (in the event fragment sorter
            e.g. the source id).
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-title</option></term>
                <listitem>
                    <para>
                        Supplies a title for the top of the widget.  This title
                        is text that is intended to show what the widget is for.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-lefttitle</option></term>
                <listitem>
                    <para>
                        Provides a title for the left column (the column of
                        key values).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-righttitle</option></term>
                <listitem>
                    <para>
                        Provides the title for the right column (the column of
                        values associted with the key).
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        <refsect1>
           <title>
              METHODS
           </title>
           <variablelist>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        <replaceable>$window</replaceable>  setItem <replaceable>key value</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Defines a
                        <parameter>key</parameter>/<parameter>value</parameter>
                        pair.  If the key already exists,
                        the label associated with the key is just modified.  If
                        the key does not exist, a new pair of labels is
                        created with the specified key and value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        <replaceable>$window</replaceable> clear <replaceable>?value?</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets all of the value labels to <parameter>value</parameter>
                        if that optional paremeter is specified.  If not, all value
                        labels are set to <literal>0</literal>, the key labels are
                        not affected by this.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        <replaceable>$window</replaceable> reinit
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Reinitializes the widget so that there are no key/value
                        pairs.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        <replaceable>$window</replaceable> idlist
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a list of the key values present in the
                        widget.
                    </para>
                </listitem>
            </varlistentry>

           </variablelist>
        </refsect1>

      </refentry>
      <refentry id="evb1_utility_sortedwidget">
        <refmeta>
           <refentrytitle id="evb1_utility_sortedwidget_title">::EVB::utility::sortedWidget</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>::EVB::utility::sortedWidget</refname>
           <refpurpose>General key/widget sorted list</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require EVBUtilities
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::utility::sortedWidget <replaceable>window ?options?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> configure <replaceable>options</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> cget <replaceable>?option-name?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> listids
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> getWidget <replaceable>id</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> update <replaceable>id value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$window</replaceable> reset
                </command>
            </cmdsynopsis>


        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
                This provides a widget that is a generalized version of
                <link linkend='evb1_utillity_sortedpair' endterm='evb1_utillity_sortedpair_title' />.
                Where <command>EVB::utility::sortedPair</command> provides a pair of labels, this
                widget provides for the use of an aribtray widget in place of the label.
                (actually <command>EVB::utility::sortedPair</command> is implemented in terms of this
                widget).
           </para>
           <para>
                A bit of discussion is in order.  In order for this widget to
                work, the client must
                supply callback scripts (see OPTIONS below).  These callback
                scripts are called to create a value widget, set its internal state
                and optionally take action just prior to the destruction of a
                value widget.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-title</option></term>
                <listitem>
                    <para>
                        Provides a title for the entire widget.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-lefttitle</option></term>
                <listitem>
                    <para>
                        Provides a title for the left column of the widget
                        pair.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-righttitle</option></term>
                <listitem>
                    <para>
                        Provides a title for the right column of the widget.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-create</option></term>
                <listitem>
                    <para>
                        Provides a callback script that is called when a new
                        right side widget needs to be created.  The
                        desired window name and corresponding key are
                        appended to this script fragment in that order.
                    </para>
                    <para>
                        If this script is not defined at the time the first new
                        widget must be created, an error is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-update</option></term>
                <listitem>
                    <para>
                        Provides a callback script that is called when a
                        right side widget must be updated.  The widget and
                        the value from the <command>update</command> method
                        are appended, in that order, to the script.
                    </para>
                    <para>
                        If this script is not defined at the time the state
                        of a right column widget needs to be filled in,
                        an error will be thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-destroy</option></term>
                <listitem>
                    <para>
                        Provides an optional script that is called just
                        prior to the destruction of a right side widget.
                        It is legal to not define this script.  You only need
                        to supply it if you are maintaining state external to the
                        widget itself that needs to be cleaned up.
                    </para>
                    <para>
                        The window name and the key id value are both appended
                        to the script in that order.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        <refsect1>
            <title>METHODS</title>
            <para>
                The <command>configure</command> and <command>cget</command>
                methods operate just like all the corresponding methods for
                Tk widgets.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> listids
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lists the set of key (id) values that are currently
                            defined for the widget.  These are all the ids
                            for which <command>update</command> was called
                            since the most recent <command>reset</command>
                            call.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> getWidget <replaceable>id</replaceable>
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Gets the widget associated with
                            the key <parameter>id</parameter>.
                            If <parameter>id</parameter> does not yet exist,
                            an error is thrown.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> update <replaceable>id value</replaceable>
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Updates the widget associated with the key <parameter>id</parameter>
                            in the manner dictated by the <parameter>value</parameter>.
                            If there is not yet a widget for <parameter>id</parameter>
                            the <option>-create</option> script is first called
                            to create it.
                        </para>
                        <para>
                            The actual widget update is accomplished by invoking the
                            <option>-update</option> script.  If more than one
                            piece of information is required you can pass
                            a list for <parameter>value</parameter> .
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <cmdsynopsis>
                            <command>
            <replaceable>$window</replaceable> reset
                            </command>
                        </cmdsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Destroys all the id/widget pairs.  For each widget,
                            just prior to its destruction, the
                            <option>-destroy</option> script is invoked,
                            if it has been defined.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
      </refentry>
      <refentry id="evb1_eventbuilder">
        <refmeta>
           <refentrytitle>EventBuilder</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>EventBuilder</refname>
           <refpurpose>Event builder utility <command>proc</command>s</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require Tk
package require EventBuilder
             </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::getConnections
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::setDisconnectCallback <replaceable>script</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::setConnectionCallback <replaceable>script</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::Start ?name?
                </command>
            </cmdsynopsis>

<!-- New for Issues #1347, #1384, #1383, #1385 -->
            <cmdsynopsis>
                <command>
EVB::setSourceTimeout <replaceable>timeout</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::getSourceTimeout
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::startRingFragmentSource <replaceable>url tsex id desc exitmsg</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::startS800FragmentSource <replaceable>url id ?desc?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::startGretinaFragmentSource <replaceable>url id ?desc?</replaceable>
                </command>
            </cmdsynopsis>



        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides a procedural interface to the event builder.
           </para>
        </refsect1>
        <refsect1>
           <title>
              PROCs
           </title>
           <variablelist>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::getConnections
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a list of information about connected clients.
                        Each element of the list is itself a sublist
                        containing the following elements in order:
                        <itemizedlist>
                            <listitem>
                                <para>
                                    The host name of the client.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    Description of the client as supplied
                                    by the client when it connected.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    The connection state.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    Either an empty string or <literal>yes</literal>
                                    if the connection has not recently sent any
                                    fragments but other source clients
                                    have.  This datum is called the
                                    <firstterm>stalled flag</firstterm>.
                                    When <literal>yes</literal> it is possible
                                    that the source has failed without exiting.
                                </para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::setDisconnectCallback <replaceable>script</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets a new <parameter>script</parameter> that will be
                        called when an event
                        source disconnects.  The host and description of the
                        connection will be appended in that order to
                        <parameter>script</parameter> prior to invoking it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::setConnectionCallback <replaceable>script</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets a new <parameter>script</parameter> that will be
                        called when the event builder receives a new
                        data source client connection. The host and description
                        will be appended, in that order, to the <parameter>script</parameter>
                        prior to invoking it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::Start ?name?
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Starts the event builder.  Naturally this must
                        be the first thing called as without it the event
                        builder does not yet exist.  The optional
                        <parameter>name</parameter> parameter supplies the
                        event builder name.  <command>EVB::Start</command> will
                        pop up a Tk dialog warning you if you choose a duplicat name.
                    </para>
                </listitem>
            </varlistentry>
<!-- New for Issues #1347, #1384, #1383, #1385 -->

            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::setSourceTimeout <replaceable>timeout</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the source stall timeout.  If other sources are
                        contributing data any source that is not contributing
                        data for more than <parameter>timeout</parameter>
                        seconds is considered stalled.
                    </para>
                    <para>
                        A source becomes un-stalled by sending a fragment.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::getSourceTimeout
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the source stall timeout as the command
                        result.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::startRingFragmentSource <replaceable>url tsex id desc exitmsg</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Starts an event fragment source that takes data from
                        an NSCLDAQ ring, extracts timestamps and inserts the
                        data into the event orderer.  The fragment source
                        runs on the same system as the event builder but, of
                        course the ring buffer could be remote.
                    </para>
                    <para>
                        <parameter>url</parameter> speceifies the source data
                        ring. <parameter>tsex</parameter> specifies the
                        shared library that extracts timestamps from event
                        fragments. <parameter>id</parameter> specifies the
                        source id that will be used for data from this ring
                        and <parameter>desc</parameter> specifies the description
                        the source will provide the event builder when it starts.
                    </para>
                    <para>
                        The event source runs as a child process whose
                        stdout and stderr are a pipeline that is monitored.
                        If an end of file is sensed on that pipe, a message
                        including <parameter>exitmsg</parameter> is displayed
                        as a dialog on the UI.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::startS800FragmentSource <replaceable>url id ?desc?</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        This is really a call to
                        <command>EVB::startRingFragmentSource</command>
                        with the time stamp extractor set to a library that
                        is suitable for S800 data and an exit message that
                        indicates the S800 event source exited.
                    </para>
                    <para>
                        The larger implications of this are that the connection
                        between the S800 DAQ and the producer for this ring
                        are not setup by this command.  Typically that is done
                        in readout callouts for the ReadoutGUI.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::startGretinaFragmentSource <replaceable>url id ?desc?</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Really a call to <command>EVB::startRingFragmentSource</command>
                        supplying a timestamp extractor suitable for most
                        GRETINA event data.  The exit message in this case
                        indicates the GRETINA data source has exited.
                    </para>
                    <para>
                        Typically the producer for the ring is set up by a
                        readoucallouts extension in the Readout GUI.
                    </para>
                    <para>
                        The actual timestamp used is the timestamp of the first
                        fragment in the <literal>glomm</literal>ed data
                        from the ring.k
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>
      <refentry id="evb1_observer">
        <refmeta>
           <refentrytitle>Observer</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Observer</refname>
           <refpurpose>Support the Observer pattern</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <cmdsynopsis>
                <command>
package require Observer
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
Observer <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>

          <cmdsynopsis>
              <command>
<replaceable>$name</replaceable> addObserver  <replaceable>script</replaceable>
              </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$name</replaceable> removeObserver <replaceable>script</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>$name</replaceable> invoke <replaceable>?args?</replaceable>
                </command>
            </cmdsynopsis>
            

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides an implementation of the observer pattern
            described in
            <ulink url='http://en.wikipedia.org/wiki/Observer_pattern'>
                        http://en.wikipedia.org/wiki/Observer_pattern</ulink>.
           </para>
           <para>
            The observer pattern provides a mechanism for decoupling action
            from stimulus.  The idea is that an object using the observer
            pattern will maintain an ordered list of observer objects which.
            When the appropriate stimulus occurs, these objects are invoked in
            order.
           </para>
           <para>
             A trivial use case is statistics matinenance.  Statistics objects
             can be registered as an Observer which increments appropriate counters
             when invoked.  Observers can also be used to implement a chain of
             responsibility.
           </para>
           <para>
                See EXAMPLES below for ideas of how to incorporate observers into
                snit class like objects (<command>snit::type</command> e.g.).
           </para>
        </refsect1>
        <refsect1>
           <title>
              METHODS
           </title>
           <variablelist>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                         <command>
         Observer <replaceable>name</replaceable>
                         </command>
                     </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Create a new observer object named <parameter>name</parameter>
                        If the name is the special word
                        <literal>%AUTO%</literal>, a unique object name is assigned.
                        This constructor also returns the object name so constructs
                        like
                        <informalexample>
                            <programlisting>
set observer [Observer %AUTO%]
                            </programlisting>
                        </informalexample>
                        are pretty normal.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
          <replaceable>$name</replaceable> addObserver  <replaceable>script</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds an observer <parameter>script</parameter> to the end
                        of the list of observer scripts maintained by the
                        object <parameter>name</parameter>.  If the observer's
                        <command>invoke</command> method is called, this script
                        will be invoked.
                    </para>
                    <para>
                        Several scripts can be registered to observe the event.
                        Scripts are called in the order in which they were
                        registered.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        <replaceable>$name</replaceable> removeObserver <replaceable>script</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes <parameter>script</parameter> from the observer
                        list for the observer <parameter>name</parameter>.
                        It is an error to remove a script that is not registered
                        as an observer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        <replaceable>$name</replaceable> invoke <replaceable>?args?</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Invokes the observers that have been registered on
                        <parameter>name</parameter>.  The observers are invoked
                         in the order in which they were registered.  If additional
                         command line parameters,
                         <parameter>args</parameter>, are supplied, they are
                         passed to each observer script.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
            <title>EXAMPLES</title>
            <example>
                <title>Supporting an observer in a snit type or widget</title>
                <para>
                    Snit's delegation capability allows you to integrate
                    observers into snit class like objects (e.g.
                    <command>snit::widget</command>s) in a very natural way.
                    This example shows how to implement a single observer within
                    a <command>snit::type</command>
                </para>
                <programlisting>
snit::type ObservedType {
    component observers
    delegate addObserver to observers
    delegate removeObserver to observers
    ...
    constructor args {
     ...
        install observers using Observer %AUTO%
     ...
    }
}
                </programlisting>
            </example>
            <para>
                This example installs an <classname>Observer</classname>
                object and exposes its <command>addObserver</command>
                and <command>removeObserver</command> methods as
                methods of <classname>observedType</classname>.
                That is the function of delegation in snit.
            </para>
            <example>
                <title>Supporting multiple observers in a snit type or widget</title>
                <para>
                    In some cases you may want to build an object that supports
                    more than one set of observers.  Suppose, for exmample
                    you want to build a snit::widget that consists of two buttons
                    and you want to support a list of scripts to be invoked when
                    each button is clicked.  Naturally the set of scripts will
                    differ between the buttons.
                </para>
                <para>
                    This example shows how to install two observers.  In this
                    case the <firstterm>as</firstterm> form of the
                    <command>delegate</command> command is used to
                    provide methods to add scripts to each observer.
                </para>
                <programlisting>
snit::type MultipleObservers {
    component observer1
    component observer2
    
    delegate addObserver    to observer1 as addSomeTypeOfObserver
    delegate removeObserver to observer1 as removeSomeTypeOfObserver
    
    delegate addObserver    to observer2 as addSomeOtherObserver
    delegate removeObserver to observer2 as removeSomeOtherObserver
    
    ...
    constructor args {
        ...
        install observer1 using Observer %AUTO%
        install observer2 using Obserer %AUTO%
        ...
    }
}
                </programlisting>
            </example>
        </refsect1>
      </refentry>

      <refentry id="evb1_evborderer">
        <refmeta>
           <refentrytitle id='evb1_evborderer_title'>EvbOrderer</refentrytitle>
           <manvolnum>1evb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>EvbOrderer</refname>
           <refpurpose>Event orderer compiled commands.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
package require EvbOrderer
            </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::inputStats
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::outputStats <replaceable>get | clear</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::dlatestats
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::onDataLate <replaceable>?newScript?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::barrierTrace <replaceable>sub-command ?script?</replaceable> 
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::source <replaceable>?socket id1...?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::deadsource <replaceable>id</replaceable>   
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::reviveSocket <replaceable>socket</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::flushqueues
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::reset
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::barrierstats 
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::config set <replaceable>name value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
EVB::config get <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
                This package supplies the commands that influence the behavior
                of the compiled fragment handling code.  Several of the
                commands in this package are not generally intended for
                application use.  These will be pointed out.  Other commands
                are available to allow the user to tailor the event builder monitor
                displays they might want to create.  
           </para>
           <para>
            For the comprehensive description of the commands supplied
            by this package see COMMANDS below.
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>
           <variablelist>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::inputStats
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns information about input queue statistics.
                        The data are returned as a list.  The elements of the
                        list are in order:
                        <itemizedlist>
                            <listitem>
                                <para>The oldest timestamp of all the
                                    in-flight fragments the input queues.
                                </para>
                            </listitem>
                            <listitem>
                                <para>The newest timestamp of all the
                                in-flight fragments in the input queues.
                                </para>
                            </listitem>
                            <listitem>
                                <para>The total number of in-flight fragments
                                    over all input queues.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    A list of elements for each source queue.
                                    Each element of this list is itself a sublist
                                    that contains in order, the source id,
                                    the number of fragments in the queue
                                    (depth) and the oldest fragment in the queue.
                                </para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::outputStats <replaceable>get | clear</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        The operation of this command depends on its subcommand.
                        If the first command word after the command is
                        <literal>clear</literal> the output queue counters held
                        by the compiled code are all cleared.
                    </para>
                    <para>
                        If the second word of this command is <literal>get</literal>
                        The command
                        returns statistics about the fragments that have been
                        removed from the input queues.  Note that a fragment gets
                        removed from an input queue because it is known how to order
                        it into the output of the event builder.
                    </para>
                    <para>
                        The return value of this command is a list that
                        contains in order:
                        <itemizedlist>
                            <listitem>
                                <para>Total number of fragments de-queued for
                                    transmission.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    Statistics for each input queue.  This is
                                    a list of two element sublists.  The first
                                    element of each sublist is the source id.
                                    The second element is the number
                                    of fragments that have been de-queued from
                                    this input queue.
                                </para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::dlatestats
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns statistics about the data late fragments.
                        A fragment is considered late if dequeueing it is
                        gauranteed to create an error in the total ordering of
                        the output fragments.  Normally fragments are only
                        emitted after they have been either held in the queues
                        for some minimum time or when there are fragments
                        in all input queues.  If a data source is slow
                        sending fragments fragments may arrive with timestamps
                        that are smaller than the fragments that have already
                        been emitted.
                    </para>
                    <para>
                        A large number of data late cases implies you
                        should change the event building window.  See
                        the <command>config</command> command below
                        for a description of how to do this.
                    </para>
                    <para>
                        The return value of this command is a list with the
                        following elements on it in order:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>Total number of data late fragments.</para>
                        </listitem>
                        <listitem>
                            <para>Worst case data late (biggest difference
                            between the arrival time of the late fragment and
                            the end of the window in which it should have been
                            emitted.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Per data source dta liate counts.  This is
                                a list of two element lists containnig the
                                data source id and the number of late fragments
                                it emitted.  Only data sources that have been
                                late are represented in this list (no zeroes).
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Per source worst case late time differences.
                                For each source that has exhibited at least one
                                data late condition, this list has a two element
                                sublist containing the source id and the worst
                                case time difference.
                            </para>
                        </listitem>
                    </itemizedlist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::onDataLate <replaceable>?newScript?</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        This command allows you to provide a script that can be
                        notified of a data late condition.
                    </para>
                    <para>
                        If <parameter>newScript</parameter> is supplied,
                        it replaces any existing data late handler script.
                        If <parameter>newScript</parameter> is empty
                        any prior script is removed and there will be no
                        data late script handler.  If <parameter>newScript</parameter>
                        is not supplied, no change to the script is performed.
                        Regardless, the command returns handler script
                        (possibly empty) as it was prior to executing the command.
                        This allows you to support multiple scripts by implementing
                        a chaining mechanism.
                    </para>
                    <para>
                        When a handler script is called the following items
                        are appended to it:
                        <itemizedlist>
                            <listitem>
                                <para>The source ide of the source that is at fault.</para>
                            </listitem>
                            <listitem>
                                <para>The timestamp of th source</para>
                            </listitem>
                            <listitem>
                                <para>The most recent timestamp seen</para>
                            </listitem>
                            <listitem>
                                <para>A binary byte array containing the
                                    fragment body.  You can use
                                    <command>binary scan</command> to retrieve
                                    elements from this item.
                                </para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::barrierTrace <replaceable>sub-command ?script?</replaceable> 
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Allows you to establish a script that is executed when
                        a barrier occurs.  The <replaceable>sub-command</replaceable>
                        indicates whether the trace is for
                        <literal>complete</literal> or <literal>incomplete></literal>
                        barriers.
                    </para>
                    <para>
                        If the sub-command is <literal>complete</literal> the
                        trace on complete barriers is queried or modified.
                        A complete barrier is one for which all sources contribute
                        a barrier event fragment within the timeout.  It is not
                        necessary that all barrier fragments be of the same type.
                        If they are not, this case is called a
                        <firstterm>heterogeneous barrier</firstterm>.
                    </para>
                    <para>
                        If the sub-command is <literal>incomplete</literal> the
                        trace on incomplete barriers is queried or modified.
                        An incomplete barrier is one or which at least one data
                        source did not contribute a barrier fragment within the
                        sorting time window.
                    </para>
                    <para>
                        In all cases, if the script is an empty string the
                        corresponding barrier event will no longer have a script
                        attached to it.  If the script is omitted completely,
                        the trace is not changed.  All versions of the command
                        return the selected trace script as it was prior
                        to the command.
                    </para>
                    <para>
                        Complete barrier scripts have appended to them a list
                        of pairs.  Each pair contains a data source id and
                        the barrier type for that source id.  Incomplete barrier
                        scripts have two argument appended to them. The first
                        is the same as what is appended to complete barrier
                        scripts (but only for the source ids that actually
                        contributed a barrier fragment), the second is
                        a list of the sources that were missing from the
                        barrier event.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::source <replaceable>?socket id1...?</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates new source queues associated with a socket.
                        This is normally not intended to be used by application
                        code.  <parameter>socket</parameter> is a file descriptor
                        open on a client socket.  <parameter>id1..</parameter>
                        are source ids.  An input queue is created for each
                        source id and bound to the socket.  Note that
                        you must be <emphasis>very</emphasis> careful using
                        this in applications since creating sources that don't
                        exist can result in incomplete barriers if you are using
                        barriers.
                    </para>
                    <para>
                        If the <parameter>socket</parameter> and
                        <parameter>source</parameter> are not supplied the
                        command returns the list of source ids..
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::deadsource <replaceable>id</replaceable>   
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Marks the event source <parameter>id</parameter> as dead.
                        A dead source is not expected to participate in any
                        barrier events.  A dead source will become alive again
                        if it's client contributes any data for that source.
                        Sources can also be resurrected if <command>revieSocket</command>
                        is called on the socket to which they are bound.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::reviveSocket <replaceable>socket</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Revies a socket.  All of the event sources associated with
                        that socket are marked alive again.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::flushqueues
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Flushes the contents of all queues to the output.
                        This can be called when you are pretty certain there
                        won't be any more data in the near future (e.g. the
                        run just ended).  The command causes all remaining
                        in-flight data to be sorted and output.  If you don't call
                        this it doesn't really matter, the time window will
                        eventually ensure the data are output.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::reset
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Resets timestamps back to the initial state.  This
                        needs to be done if there's something that can cause
                        the event sources to reset their timstamps as part of their
                        synchronization process.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::barrierstats 
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the barrier statistics.  The barrier statistics
                        consist of a two element list.  The
                        first element describes complete barriers and
                        is in turn a list containing in order:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>The total number of barriers encountered</para>
                        </listitem>
                        <listitem>
                            <para>The number of homgeneous barriers</para>
                        </listitem>
                        <listitem>
                            <para>The number of heterogeneous barriers.</para>
                        </listitem>
                        <listitem>
                            <para>The number of fragments of each barrier type
                                This is a list of pairs of barrier type
                                and number of fragments of that type.
                            </para>
                        </listitem>
                        <listitem>
                            <para>Statistics by event source, which is a list
                                each item of which is a list containning
                                in order The source id, the numbder of
                                barrier fragments seen from this source and
                                a list of pairs containning fragment type
                                and number of associated fragments of that type.
                            </para>
                        </listitem>
                    </itemizedlist>
                    <para>
                        The second element describes the incomplete barriers.
                        This is a list whose elements are in order:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>Number of incomplete barriers</para>
                        </listitem>
                        <listitem>
                            <para>Number of homgeneous incomplete barriers</para>
                        </listitem>
                        <listitem>
                            <para>Number of heterogenous incomplete barriers</para>
                        </listitem>
                        <listitem>
                            <para>A list of pairs containing barrier type and
                                the number of times it occurs.
                            </para>
                        </listitem>
                        <listitem>
                            <para>Source statistics which are a list of pairs.
                                Each pair is a source id and the number of times
                                it was absent from a barrier.
                            </para>
                        </listitem>
                    </itemizedlist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::config set <replaceable>name value</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>Sets a configuration variable.  <parameter>name</parameter>
                        determines which configuration variable will be modified
                        and <parameter>value</parameter> provides the new value.
                    </para>
                    <para>
                        Currently the only supported configuration name is
                        <literal>window</literal> which sets the time window
                        in which fragments are accumulated before builds can
                        occur.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        EVB::config get <replaceable>name</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of a configuration parameter
                        <parameter>name</parameter>.  The
                        only name supported at this time is
                        <literal>window</literal> which returns the build time
                        window.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>


<!-- /manpage -->

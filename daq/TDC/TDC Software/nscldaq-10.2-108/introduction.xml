<!-- chapter introduction -->

<chapter>
    <title>Introduction</title>
    <para>
        This chapter provides introductory material on the NSCL Ring buffer
        data acuisition system.  In this chapter we will describe:
    </para>
    <itemizedlist>
        <listitem><para>
            What a ring buffer is and what the ringbuffer data acquisition
            system is.
            </para>
        </listitem>
        <listitem>
            <para>
                Some of the useful ring buffer utilities that can help you
                understand what is going on in the ring buffer
                data acquisition.
            </para>
        </listitem>
        <listitem><para>
            A roadmap of the documentation.
        </para></listitem>
    </itemizedlist>
    <section>
        <title>How does the ring buffer data acquisition system work</title>
        <para>
            This section describes the ring buffer data acquisition system.
            Specifically:
        </para>
        <itemizedlist>
            <listitem>
                <para>Ring buffers are defined and described
                </para>
            </listitem>
            <listitem>
                <para>Proxy rings are described and how they are used
                    to send data from the data source to other systems.
                </para>
            </listitem>
            <listitem>
                <para>
                    The <application>RingMaster</application> process is
                    described and its role in the system.
                </para>
            </listitem>
        </itemizedlist>
        <section>
            <title>What is a ring buffer?</title>
            <para>
                This section defines a ring buffer.  First, for simplicity,
                we'll describe a single producer, single consumer
                ring buffer.  Finally we'll show how this can be generalized
                to a single producer multi-consumer ring buffer.
            </para>
            <para>
                Suppose we have a chunk of memory which is shareable between
                processes and within which we are going to use modulo addressing.
                Using modulo addressing means that if we have a pointer
                sequentially accessing this memory, when the pointer would run
                off the end of this memory region instead it returns to the
                beginning.
            </para>
            <para>
                You can therefore think of this memory as an 'endless' ring of
                addresses.  A <firstterm>ringbuffer</firstterm>..
            </para>
            <para>
                For a ring buffer to be useful as a mechanism for exchanging
                data we need a bit more information.  Specifically, we need a
                <firstterm>put pointer</firstterm> and a <firstterm>get pointer</firstterm>.
                As we will see we also need some concept of flow control.
            </para>
            <para>
                Here's how this all works;  Define the ring buffer as being
                empty if the put and get pointers are equal.  Define the ring
                buffer as full if advancing the put pointer one storage unit would
                make it equal to the get pointer (we don't want an ambiguity between
                full and empty ring buffers).  A producer will ensure it has space
                in the ring buffer for whatever data it wants to put by
                calculating the modulo distance between the put and get pointers.
                When space becomes available (producers wait if necessary for
                space), data are transferred to the ring buffer starting at
                the location indicated by the put pointer (using modulo addressing again).
                When the data are transferred, the put pointer is advanced to
                point to the location just following the message.
            </para>
            <para>
                Similarly, a consumer that wants to get data from the ring
                ensures there is enough data to get by waiting until the
                distance between the put and get pointers is at least the size
                of the data transfer it wants to perform.  Once there is
                sufficient data in the ring buffer it transfers the data
                out of the ring and, when the data have been read,
                updates the get pointer so that it points to the next
                unread unit of memory.
            </para>
            <para>
                This business of the produceer waiting for space to be
                available and the consumer waiting for data to be available
                is called flow control.
            </para>
            <para>
                Ring buffers therefore can be thought of as objects with
                the following simple to implement set of functions:
            </para>
            <variablelist>
                <varlistentry>
                    <term><function>create</function></term>
                    <listitem><para>
                        Makes a new ring buffer.  We will see that in the
                        ringbuffer data acquisition system, each ring buffer
                        has a name.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><function>destroy</function></term>
                    <listitem><para>
                        Destroys an existing ring buffer.  Note that the actual
                        destruction will occur when the last client has detached
                        from the shared memory region that holds the ring buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><function>Connect</function></term>
                    <listitem>
                        <para>
                            Connect to an existing ring buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><function>put</function></term>
                    <listitem><para>
                        Insert data into the ring buffer.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><function>get</function></term>
                    <listitem><para>
                        Retrieve data from the ring buffer.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><function>waitUntil</function></term>
                    <listitem><para>
                        Blocks until the ring buffer satisfies some
                        condition or  <firstterm>predicate</firstterm>.
                        This can be used to implement the blocking needed
                        for flow control for both the producer and the
                        consumer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><function>peek</function></term>
                    <listitem>
                        <para>
                            Exactly like <function>get</function> however
                            the get pointer is not updated.  This is not
                            strictly necessary but its existence simplifies
                            code in some cases.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                In a data acquisition system, we usually want to have several
                consumers.  This can be accomodated by having more than one
                get pointer.  This slightly complicates the flow control logic
                of the producer.  Now the producer must consider the free space
                to be the minimum distance between the the put pointer and all
                of the get pointers.
            </para>
            <para>
                Ring buffers are a very low overhead mechanism to transfer data
                between processes in a single shared memory computer system.
                Messages can be atomically put without any requirement to
                negotiate locks.  Furthermore, since data are in shared memory,
                it's not necessary to transfer buffers to kernel space and then
                back out to application space.  For more information about
                ring buffers see
                <ulink url='http://en.wikipedia.org/wiki/Circular_buffer'>
                    http://en.wikipedia.org/wiki/Circular_buffer
                </ulink>
            </para>
            <para>
                While theoretically the data transferred through the ring
                buffer is just a stream of bytes, in practice and in the
                NSCL Ring buffer Data Acquisition system, we send messages
                that have structure.   The messages have a structure
                defined by the <filename>&lt;DataFormat.h&gt;</filename>
                header.
            </para>
            <para>
                In the next section we'll look at how to use
                <firstterm>proxy ring buffers</firstterm> to transfer data
                across the network to computers that don't share memory.
            </para>
        </section>
        <section>
            <title>What are proxy rings and how are they used?</title>
            <para>
                The previous section introduced ring buffers as a data transfer
                mechanism within the memory shared by processes running in
                one or more processors that can share memory.  In a data
                data acquisition system we usually want several such computer
                systems to join the party.  Data taken in one system must
                be made visible in near real-time to analysis software in other
                computer systems.  This section describes the mechanism used by
                the NSCL Ring Buffer data acquisition system to accomplish this
                feat.
            </para>
            <para>
                Each system that runs the ring buffer data acquisition system
                has a simple server process called the <application>RingMaster</application>.
                We'll talk more about the RingMaster and its role in the next
                section.
            </para>
            <para>
                One role the ring master performs is to assist in hoisting
                data out of an local ring, sending it across the network to
                another system.  This is done through a mechanism called a
                <firstterm>proxy ring</firstterm> which makes the semantics
                of getting data from a remote system identical to the semantics
                of getting data from a local system.
            </para>
            <para>
                First we need to talk about ring buffer naming.  Each ring buffer
                in the system has a unique name that is of the form of a
                URL.  The URL components are <literal>tcp://hostname/ringname</literal>.
                Where <literal>hostname</literal> is the name of the system in which
                the ring lives (use <literal>localhost</literal> for local rings),
                and <literal>ringname</literal> is the name of the ring within the
                system. By convention, unless you have special needs, the
                <literal>ringname</literal> is your logged in user name.
            </para>
            <para>
                If a process attempts to open a ring buffer whose URL does not
                specify <literal>locahost</literal> as the hostname, the ring buffer
                DAQ system contacts the RingMaster in the target host and collaborates
                with it to create a local ring and a network pipeline that
                ships data from the ring in the remote host to the local ring.
            </para>
            <para>
                Such rings are called <firstterm>proxy ring</firstterm>buffers
                because from the consumer standpoint they cannot be distinguished
                from ring buffers that have local producers.  Note as well that
                only the first consumer goes through the gymnastics of creating
                a proxy ring. Subsequent consumers  simply connect to the
                proxy as an additional consumer.  In this way, network traffic
                between rings and their proxies are aggregated.
            </para>
            <para>
                A proxy ring has the local name <literal>hostname.remote-ringname</literal>
                where <literal>hostname</literal> is the host in which the
                'real ring' is located and <literal>remote-ringname</literal>
                is the name of the real ring in <literal>hostnanme</literal>.
                Thus the proxy ring for <literal>tcp://spdaq42/fox</literal>
                will be <literal>tcp://localhost/spdaq42.fox</literal>.
            </para>
        </section>
        <section>
            <title>What is the RingMaster server and what does it do?</title>
            <para>
                All systems that run the Ring buffer data acquisition system
                also run a simple server called the <application>RingMaster</application>.
                The RingMaster performs the following functions:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Collaborates with remote clients to set up a pipeline
                        to produce data into proxy rings as described in the
                        previous section.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Allocate ring resources for local consumers.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Cleans up when local consumer exit or release their
                        ring resources.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                The Ring buffer DAQ system has two types of clients.  Producers
                and consumers.  Recall that each ring can have at most one
                producer, and many consumers.
            </para>
            <para>
                The ring master keeps track of which local processes are attached
                to a ring and whether or not a process is the producer or
                a consumer (actually a consumer could be consuming data from several rings,
                or even be more than one consumer on one ring).
            </para>
            <para>
                When a client wants to obtain the put or a get pointer,
                it asks the ring master for one.  It does so by opening a
                TCP/IP connection to the ring master and sending it a pointer
                request message.  The ring master identifies the pointer
                it provides to the client.  The client is then required to hold
                the TCP/IP connection open.  If the TCP/IP connection closes,
                as it will normally  if a process exits, the RingMaster releases
                the pointer that was associated with that connection.
            </para>
            <para>
                In this way, ring buffers are immune to stalls that could occur
                if a pointer got orphaned.
            </para>
        </section>
    </section>
    <section>
        <title>Overview of ring buffer utilities</title>
        <para>
            This section will give a brief overview of some of the ring buffer
            utilities.  Please refer to the remainder of this documentation
            for detailed descriptions and reference material for each utility.
            This list is only a selection of utilities.
        </para>
        <variablelist>
            <varlistentry>
                <term><application>ringbuffer</application></term>
                <listitem>
                    <para>
                        This utility allows you to create, re-initialize, delete  and
                        monitor the status of ringbuffers.  Normally you don't
                        have to create ring buffers as producer frameworks
                        will create them if they don't already exist.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><application>dumper</application></term>
                <listitem><para>
                    Provides a simple textual formatted dump of the buffers.
                    If you want more advanced formatting, you can use
                    the <application>tkdumper</application> application.
                    By contrast with <application>dumper</application>,
                    <application>tkdumper</application> can be extended with
                    plugins in such a way that it can provide a human readable
                    formatted view of each event and the packets within the
                    event.
                </para></listitem>
            </varlistentry>
            <varlistentry>
                <term><application>eventlog</application></term>
                <listitem><para>
                    Performs native mode event loggging.  In this mode,
                    event file segments consists of streams of ring buffer items.
                    This is the default event logger run by the
                    <application>ReadoutShell</application> (see below), if you
                    want to log data in a format compatible with spectrodaq based
                    DAQ versions (version 8.x and earlier), use
                    <application>eventlog-compat</application>
                    </para></listitem>
            </varlistentry>
            <varlistentry>
                <term><application>ReadoutShell</application></term>
                <listitem>
                    <para>
                        Provides a GUI wrapper around a readout program that is
                        started in a remote system.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><application>ringselector</application></term>
                <listitem><para>
                    Provides a flexible ringbuffer consumer that pipes
                    the ring items it gets to standard output.  This
                    can be run over a pipe into your program or as the
                    first stage of a pipeline that transforms data before
                    providing it to an application (<application>eventlog-compat</application>
                    is actually a pipeline with ringslector as the source
                    piping through <application>compatibilitybuffer</application>
                    and then on to <application>compatibilitylogger</application>).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><application>ringtostdout</application></term>
                <listitem><para>
                    Accepts data from a ring and pipes it to stdout.  This is
                    the server side of the pipeline between systems when you are
                    setting up a proxy ring.  It can also be used as the first
                    stage of a pipeline to process data from  a ring.
                    </para></listitem>
            </varlistentry>
            <varlistentry>
                <term><application>ScalerDisplay</application></term>
                <listitem><para>
                    Provides a display of scaler event data.  This application
                    is highly configurable.  It can accept an arbitrary number
                    of scalers and format any number of pages as tabs in a notebook.
                    Strip charts of selected scalers are also supported.
                    </para></listitem>
            </varlistentry>
            <varlistentry>
                <term><application>stdintoring</application></term>
                <listitem><para>
                    Accepts data on stdin and puts it in a ring buffer.
                    This is the client side of the data pipeline that sets up
                    a proxy ring.
                    </para></listitem>
            </varlistentry>
            <varlistentry>
                <term><application>spectcldaq</application></term>
                <listitem><para>
                    Pipe data source for SpecTcl software that has not yet
                    been ported to ring buffer data format.  This accepts data
                    from a ring and outputs it on stdout in nscldaq-8.x format.
                    </para></listitem>
            </varlistentry>
        </variablelist>
    </section>
    <section>
        <title>Documentation roadmap</title>
        <para>
            This document can be logically divided into two segments.  The
            first segment consists of parts that are introductory material to
            various software tools.  The second segment provides extensive
            reference information in Unix Manpage format.
        </para>
        <para>
            Installations of the software include the web documentation
            which is installed at
            <literal>$DAQROOT/share/html/index.html</literal>.
            Manual pages aer installed at
            <literal>$DAQROOT/share/man</literal>, so that
            e.g. <command> man -M/usr/opt/daq/10.0/share/man spectcldaq</command>
            will display the manpage for the <application>spectcldaq</application>
            utility.
        </para>
        <section>
            <title>Introductory Material</title>
            <para>
                The introductory material is divided into several parts.  Introductory
                material is only generated as <filename>html</filename> pages in the
                web documentation.  It does not appear in the generated mapages.
            </para>
            <variablelist>
                <varlistentry>
                    <term>commands</term>
                    <listitem><para>
                        Documents a few free standing commands that tie the ring buffer
                        data acquisition system togehter.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>utilities</term>
                    <listitem><para>
                        Documents the bulk of the shell command utilities.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>libraries</term>
                    <listitem><para>
                        Provides introductory material for the major libraries
                        that define the API to subsystems of the DAQ software.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>servers</term>
                    <listitem><para>
                        Provides documentation on the persistent servers the system.
                        Note that serveral utilities are transient client/server
                        applications, however these are not documented in
                        this section.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>frameworks</term>
                    <listitem>
                        <para>
                            Several of the more complex API's are provided as
                            application frameworks.  This section describes
                            those frameworks.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
        <section>
            <title>Manpage sections.</title>
            <para>
                Manpage sections provide detailed reference material for
                components of the system.  In keeping with unix conventions,
                sections starting with <literal>1</literal> document commands
                that can be issued fromt he shell, sections beginning with
                <literal>3</literal> document libraries and frameworks.
                Sections beginning with <literal>5</literal> document configuration
                files and file formats.
            </para>
            <variablelist>
                <varlistentry>
                    <term>1compatibility</term>
                    <listitem>
                        <para>
                            The ring buffer data acuisition system provides serveral
                            utiltities that make migration to it from nscldaq-8.x
                            easy.  Specifically, there are a set of utilities
                            that provide the ability to hook clients that
                            are used to seeing nscldaq-8.x style buffer formats
                            tothe ring buffer daq.  This section provides manpages
                            for the full utility suite.
                            The utilities are provided both as toolkit elements
                            that can be used in unix pipelines and as scripts
                            that build commonly used pipelines.  This section
                            descsribes both of these types of elements.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>1daq</term>
                    <listitem>
                        <para>
                            Documents commands that you will use explicitly or
                            implicitly to build up your data acquisition system
                            configuration. In some cases you may never directly
                            invoke tools described in this section
                            (e.g. <application>ringtostdout</application>), in other
                            cases (e.g. <application>ReadoutGui</application>),
                            these applications will be an integral part of the
                            system and you will interact with them heavily.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>1tcl</term>
                    <listitem>
                        <para>
                            This section describes several pure Tcl applications.
                            There is some overlap between this section and
                            1daq.  For example, this section describes
                            <application>ScalerDisplay</application> which,
                            while it is a pure Tcl application might just as
                            easily belong in the 1daq section.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>1sbsReadout</term>
                    <listitem>
                        <para>
                            Provides reference material that describes how you can
                            invoke the SBS readout framework you have built
                            to read data from your experiment.  While, in general,
                            the default invocation (without specifying options)
                            is appropriate, for special application you may
                            want to provide command line options to alter
                            how the Readout program operates.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>1usbReadout</term>
                    <listitem>
                        <para>
                            Documents the USB Readout frameworks. The
                            VMUSB/CCUSB Readout frameworks provide high performance
                            access to VME and CAMAC crates.  These frameworks
                            allow you to describe the experiment in terms
                            of a set of digitizers, their configurations and
                            their readout orders.  Coupled with a special
                            version of SpecTcl, you can use this software to
                            use a single configuration file to get from readout
                            to raw spectra without a single line of C++ code.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>3daq</term>
                    <listitem>
                        <para>
                            Describes the bulk of the C++ classes that are provided
                            for various stand alone APIs.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>3tcl</term>
                    <listitem><para>
                        Describes Tcl loadable packages you can use in your
                        Tcl scripts.
                    </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>3sbsReadout</term>
                    <listitem>
                        <para>
                            Describes classes that are specifically part of
                            the SBS readout application framework.
                            Note that device support is described in
                            3daq, but classes you will interact with that
                            are specific to the readout framework are described
                            in this section.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>3usbReadout</term>
                    <listitem>
                        <para>
                            Most likely you don't need to read the man pages in this
                            section.  They provide reference documentation for the
                            classes that make up the VM/CC usb readout framework.
                            While at present only the VM-USB is supported, the
                            framework is generic enough that CC-USB support
                            can be built on top of it as well.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>5tcl</term>
                    <listitem>
                        <para>
                            Describes configuration file formats and contents
                            for several Tcl utilities that require configuration
                            files.  In general the utilities that use configuration
                            files documented in this section will have references
                            to these pages.  In the web version of this document,
                            those references will be hyperlinks.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
    </section>
</chapter>

<!-- /chapter -->
<!-- chapter libraries -->

<chapter id="chapter.threads">
    <title>NSCL DAQ Thread Library</title>
    <para>
        The NSCL DAQ thread library supplies object oriented threading support.
        This chapter describes:
        <itemizedlist>
            <listitem>
                <para>
                    The thread and synchronization model supported by the library
                </para>
            </listitem>
            <listitem>
                <para>
                    What you need to do to incorporate the library into your
                    application code.
                </para>
            </listitem>
            <listitem>
                <para>
                    A summary of the classes in the library and links to the
                    reference material for each of them.
                </para>
            </listitem>
        </itemizedlist>
    </para>
    <section>
        <title>The thread and synchronization model</title>
        <para>
            The NSCL Daq software models each thread as an object from a
            class that is derived from the
            <classname>Thread</classname> base class.  This class provides
            functions that allow a thread to be created, started, exited,
            joined to and detached.  
        </para>
        <para>
            The body of a thread is provided by you when you create your concrete
            <classname>Thread</classname>
            subclass.  The thread body is just your implementation of the
            <methodname>virtual run</methodname> method.
            Threads exit by returning from the
            <methodname>run</methodname>
            method.
        </para>
        <para>
            Given a running thread, the
            <methodname>join</methodname>
            thread allows the caller to block until the thread represented
            by the object exits.
            <methodname>join</methodname>ing is a necessary part of thread
            cleanup, unless the thread invokes its own
            <methodname>detach</methodname> member.
        </para>
        <para>
            In the following example, a thread is designed that will block itself
            for a second, print a message and exit.  Code is shown that
            creates the thread, starts it, joins it an deletes it.  Note that
            deleting a running thread object is a bad idea and has undefined
            consequences.
        </para>
        <example>
            <title>The life of a thread</title>
            <programlisting>
        ...
class MyThread : public Thread {      <co id="chapter.thread.mythread" />
public:
    virtual void run();
};
void
MyThread::run()                      <co id="chapter.thread.run" />
{
    sleep(1);
    std::cerr &lt;&lt; "My thread " &lt;&lt; getId() &lt;&lt; " is exiting\n";
    return;
};
   ...
   
MyThread* aThread = new MyThread;   <co id="chapter.thread.creation" />
aThread->start();                     <co id="chapter.thread.start" />

   ...
   
aThread->join();                    <co id="chapter.thread.join" />
delete aTrhead;                     <co id="chapter.thread.destroy" />
 
    ...

            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs="chapter.thread.mythread">
                <para>
                    By making
                    <classname>MyThread</classname> a subclass of
                    <classname>Thread</classname>,
                    objects from class
                    <classname>MyThread</classname>
                    can be started as independent threads of execution
                </para>
            </callout>
            <callout arearefs="chapter.thread.run">
                <para>
                    The
                    <methodname>run</methodname>
                    member of a thread is an abstract method.  Your thread classes
                    must supply the behavior for this member.  When the
                    thread is started, the
                    <methodname>run</methodname>
                    method gains control in the context of the new thread.
                </para>
            </callout>
            <callout arearefs="chapter.thread.creation">
                <para>
                    Creating a thread is simple.  Just create an object that
                    is of the thread class type.
                </para>
            </callout>
            <callout arearefs="chapter.thread.start">
                <para>
                    Starting a thread is equally simple, Just call the
                    thread's
                    <methodname>start</methodname>
                    method.  That starts the thread with an entry point that
                    eventually calls the
                    <methodname>run</methodname>
                    method.
                </para>
            </callout>
            <callout arearefs="chapter.thread.join">
                <para>
                    It's not safe to destroy a thread that is executing.
                    Calling a thread's
                    <methodname>join</methodname>
                    method blocks the caller's thread until the thread exits.
                    Note that it is not safe for a thread to call its own
                    <methodname>join</methodname>
                    method since that will block the thread forever.
                </para>
            </callout>
            <callout arearefs="chapter.thread.destroy">
                <para>
                    Once a thread has exited, the object that ran it can be
                    destroyed.  That effectively destroys the thread.
                    If the state of the exiting thread allows, it is possible
                    to start the thread again after it has exited.
                </para>
            </callout>
        </calloutlist>
        <para>
            Non trivial threaded software will almost always need some means
            for threads to synchronize against one another.  Consider the following
            trivial, but wrong, example:
        </para>
        <example>
            <title>Why synchonization is needed</title>
            <programlisting>
int someCounter = 0;

class MyThread : public Thread
{
    virtual void run() {
        for (int i=0; i &lt; 10000; i++) {
            someCounter++;
        }
};

...
MyThread* th1 = new MyThread;
MyThread* th2 = new MyThread;
th1->start();
th2->start();
th1->join();
th2->join();
delete th1;
delete th2;
std::cerr &lt;&lt; "someCounter = " &lt;&lt; someCounter &lt;&lt; std::endl;
...


            </programlisting>
        </example>
        <para>
            In this program, two threads increment the variable someCounter
            in parallel 10,000 times each.  You might expect the output of this
            program to always be 20000.  Most of the time, it probably will be.
            Sometimes it will be something less than 20000.
        </para>
        <para>
            Consider what
            <programlisting>
someCounter++;
            </programlisting>
            actually does.  The value of 
            <varname>someCounter</varname>
            is fetched to a processor register,
            the register is incremented and finally, the
            register is stored back into
            <varname>someCounter</varname>.
        </para>
        <para>
            Suppose thread <varname>th1</varname>
            fetches <varname>someCounter</varname>, and increments the register
            but before it has a chance to store the incremented value back into
            <varname>someCounter</varname>
            <varname>th2</varname> executes, fetches
            <varname>someCounter</varname> (the old value), increments the
            register and stores the value back.
            Now <varname>th1</varname> gets scheduled, and stores its value back.
        </para>
        <para>
            This sequence of steps results in a lost increment.  It is possible
            to construct sequences of execution, that result in a final value
            of <varname>someCounter</varname> holding any value from
            10000 through 20000 depending on how access to
            <varname>someCounter</varname> is interleaved.
        </para>
        <para>
            One way to fix this is to ensure that the increment of
            <varname>someCounter</varname> is
            <firstterm>atomic</firstterm> with respect to the increment.
            The NSCLDAQ threading library provides a synchonization primitive
            called a
            <classname>SyncGuard</classname> that can be used to implement
            the Monitor construct first developed by Per Brinch Hansen
            (see
            <ulink url="http://en.wikipedia.org/wiki/Monitor_%28synchronization%29">
            Wikipedia's Monitor (synchronization)</ulink> page.
        </para>
        <para>
            Let's rewrite the previous example so that the increment is atomic
            with respect to the scheduler.   To do this we will isolate the
            counter in a class/object of its own so that it is not possible to
            use it incorrectly
        </para>
        <example>
            <title>Using <classname>SyncGuard</classname> to implement a monitor</title>
            <programlisting>
class ThreadedCounter {
private:
    Synchronizeable  m_guard;      <co id="chapter.thread.synchronizable" />
    int              m_counter;
public:
    void increment();
    int  get() const;
};
void
ThreadedCounter::increment()
{
    sync_begin(m_guard);          <co id="chapter.thread.enter" />
    m_counter++;
    sync_end();                  <co id="chapter.thread.leave" />
}
int
ThreadedCounter::get() const
{
    return m_counter;
}

ThreadedCounter someCounter;
class MyThread : public Thread
{
    virtual void run() {
        for (int i=0; i &lt; 10000; i++) {
            someCounter.increment();     <co id="chapter.thread.monitoredincr" />
        }
};

...
MyThread* th1 = new MyThread;
MyThread* th2 = new MyThread;
th1->start();
th2->start();
th1->join();
th2->join();
delete th1;
delete th2;
std::cerr &lt;&lt; "someCounter = " &lt;&lt; someCounter.get() &lt;&lt; std::endl;
...

            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs="chapter.thread.synchronizable">
                <para>
                    This member is the synchronization element.  We will see
                    it used in the
                    <methodname>increment</methodname>
                    member.
                </para>
            </callout>
            <callout arearefs="chapter.thread.enter">
                <para>
                    The
                    <function>sync_begin()</function>
                    enters the monitor.  Only one thread at a time is allowed
                    to execute the code between a
                    <function>sync_begin</function>
                    and a
                    <function>sync_end</function> for the same synchronizing
                    object.
                </para>
            </callout>
            <callout arearefs="chapter.thread.leave">
                <para>
                    This call leaves the monitor.  The effect of the
                    monitor is to make the increment atomic with respect to the
                    scheduler.
                </para>
            </callout>
            <callout arearefs="chapter.thread.monitoredincr">
                <para>
                    By using the
                    <methodname>increment</methodname>
                    function, the counter is incremented atomically.
                </para>
            </callout>
        </calloutlist>
    </section>
    <section>
        <title>Incorporating the library into an application.</title>
        <para>
            To incorporate the thread library in your software, you will
            need to ensure that the compiler can locate the library headers
            and the library, both at link time and at load time.
        </para>
        <para>
            The library headers are in the
            <filename>include</filename>
            directory of the NSCLDAQ installation tree.  The library is called
            <filename>libthreads</filename> and is in the
            <filename>lib</filename>
            directory of the installation tree.
        </para>
        <para>
            In the compilation example below, we assume that an
            environment variable named DAQROOT has been defined to point to the
            top level of the NSCLDAQ installation tree:
        </para>
        <example>
            <title>Compiling and linking NSCLDAQ threaded software</title>
            <programlisting>
g++ -o mythreadedapp -I$DAQROOT/include mythreadedapp.cpp -L$DAQROOT/lib -lthreads \
    -Wl,"-rpath=$DAQROOT/lib"
            </programlisting>
        </example>
    </section>
    <section>
        <title>Pointers to the reference material</title>
        <para>
            This section provides pointers to the reference sections.
            The following three classes define the public interfaces
            for the threading and synchronization library:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend="manpage.thread"><classname>Thread</classname></link>
                    is the abstract base class from which you can construct
                    application specific threads.
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend="manpage.synchronizable"><classname>Synchronizable</classname></link>
                    is the class used to perform synchronization.
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend="manpage.syncguard"><classname>SyncGuard</classname></link>
                    is built on top of <classname>Synchronizable</classname> to 
                    provide monitor like synchronization semantics.
                </para>
            </listitem>
        </itemizedlist>
    </section>
</chapter>

<!-- /chapter -->
<!-- manpage 3daq -->
    <refentry id="manpage.thread">
      <refmeta>
         <refentrytitle>Thread</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>Thread</refname>
	 <refpurpose>Abstract base class for thread objects.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;Thread.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>Thread</classname></ooclass>
            <constructorsynopsis>
                <methodname>Thread()</methodname>
                <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>Thread</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~Thread</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>detach</methodname>
                                 <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>unsigned long</type> <methodname>getId</methodname>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>start</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setName</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>join</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getName</methodname>
                                         <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>run</methodname>
                                             <void /> <modifier>= 0</modifier>
            </methodsynopsis>

         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>Thread</classname>
            is an abstract base class that can be used to create threads.
            To make a thread you will normally derive a class from
            <classname>Thread</classname>
            and write the
            <methodname>run</methodname>
            method to implement the thread's code.
         </para>
         <para>
            A thread can then be created like any other object.
            The
            <methodname>start</methodname>
            method schedules the thread's
            <methodname>run</methodname>
            member for execution
         </para>
         <para>
            Threads can block on the completion of a thread via the
            <methodname>join</methodname> method.  
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
         <formalpara>
            <title>Constructors</title>
            <para>
                Constructors create a thread.  The thread is not scheduled
                for execution until the
                <methodname>start</methodname>
                method is called.
                Threads can have an optional thread name.
            </para>
         </formalpara>
        <constructorsynopsis>
            <methodname>Thread()</methodname>
            <void />
        </constructorsynopsis>
        <para>
            Constructs an anonymous thread.
        </para>
        <constructorsynopsis>
            <methodname>Thread</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a named thread.
        </para>
        <formalpara>
            <title>Thread identification</title>
            <para>
                Threads are identified by an optional name, which need not
                be unique, and a unique identifier (thread id), that is
                assigned by the underlying operating systemn.
            </para>
        </formalpara>
        <methodsynopsis>
            <type>unsigned long</type> <methodname>getId</methodname>
        </methodsynopsis>
        <para>
            Returns the thread id.  If the thread has not yet been started,
            <literal>-1</literal>
            is returned regardless of the thread.  A thread only gets an id
            when it has been started.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>start</methodname>
                              <void />
        </methodsynopsis>
        <para>
            Starts a thread.             
            A thread id is allocated and the
            <methodname>run</methodname>
            method is scheduled for execution.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setName</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Modifies the name of the thread.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>detach</methodname>
                             <void />
        </methodsynopsis>
        <para>
            Detaches an executing thread.   If the thread has not
            started, this returns
            <literal>-1</literal>.
            Detaching a thread indicates that any operating system storage
            (not object storage) associated with a thread can be released when
            the thread exits.  If the thread does not
            detach, it is necessary to
            <methodname>join</methodname>
            the thread to fully release its storage.
        </para>
        <para>
            On success,
            <literal>0</literal>
            should be returned, otherwise a value that is one of the values
            in
            <filename>errno.h</filename> is returned to describe why
            the call failed.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>join</methodname>
                              <void />
        </methodsynopsis>
        <para>
            <methodname>join</methodname>
            blocks until the thread exits.   When the thread does exit,
            thread specific storage is reclaimed.  Note that if a thread
            has calledis 
            <methodname>detach</methodname>
            it is not clear clear wht clear what this member will do.
        </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>getName</methodname>
                                     <void /><modifier>const</modifier>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type>
                                         <methodname>run</methodname>
                                         <void /> <modifier>= 0</modifier>
        </methodsynopsis>
        <para>
            You must implement this function to provide a concrete
            <classname>Thread</classname>
            run-time behavior.
        </para>
      </refsect1>

   </refentry>

    <refentry id="manpage.synchronizable">
      <refmeta>
         <refentrytitle>Synchronizable</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>Synchronizable</refname>
	 <refpurpose>Wait queue for threads</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;Synchronizable.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>Synchronizable</classname></ooclass>
            <constructorsynopsis>
                <methodname>Synchronizable</methodname><void />
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~Synchronizable()</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>waitFor</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>waitFor</methodname>
                <methodparam>
                    <type>long</type> <parameter>timeout</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>waitFor</methodname>
                <methodparam>
                    <type>long</type> <parameter>seconds</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>nanoseconds</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>notify</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>notifyAll</methodname>
                                  <void />
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class implements a wait queue for threads.  A thread can
            place itself in a wait queue and then be awakened by another thread,
            or by a timeout on the wait itself.
         </para>
         <para>
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>Synchronizable</methodname><void />
        </constructorsynopsis>
        <para>
            Creates a thread wait queue.
        </para>
        <destructorsynopsis>
            <modifier>virtual</modifier> <methodname>~Synchronizable()</methodname>
                                         <void />
        </destructorsynopsis>
        <para>
            Destroys a thread wait queue.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>waitFor</methodname>
                              <void />
        </methodsynopsis>
        <para>
            Waits for an unbounded length of time.  The method completes
            when either the calling thread is at the head of the wait queue
            and another thread invokes the
            <methodname>notify</methodname>, member or another thread invokes
            the
            <methodname>notifyAll</methodname> member function.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>waitFor</methodname>
            <methodparam>
                <type>long</type> <parameter>timeout</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Waits as above, but for at most
            <parameter>timeout</parameter> seconds.  In the current implementation,
            it is not possible to distinguish between a wait that times out
            and one that completes due to notification.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>waitFor</methodname>
            <methodparam>
                <type>long</type> <parameter>seconds</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>nanoseconds</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Waits as above, but for <parameter>seconds</parameter> seconds and
            at least an additional <parameter>nanoseconds</parameter> nanoseconds,
            or until notification awakens the thread.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>notify</methodname>
                              <void />
        </methodsynopsis>
        <para>
            Wakes up the thread that least recently entered one of the wait
            functions and has not yet timed out.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>notifyAll</methodname>
                              <void />
        </methodsynopsis>
        <para>
            Awakens all of the threads that are currently blocked on this
            object.
        </para>
      </refsect1>
   </refentry>


    <refentry id="manpage.syncguard">
      <refmeta>
         <refentrytitle>SyncGuard</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>SyncGuard</refname>
	 <refpurpose>Provide Critical Regions, Monitors</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;SyncGuard.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>SyncGuard</classname></ooclass>
            <constructorsynopsis>
                <methodname>SyncGuard()</methodname>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>SyncGuard</methodname>
                <methodparam>
                    <type>Synchronizable&amp;</type> <parameter>syncer</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>SyncGuard</methodname>
                <methodparam>
                    <type>Synchronizable&amp;</type> <parameter>syncer</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>tryonly</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~SyncGuard</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>dshwrapthread_t</type> <methodname>getOwner</methodname>
                                             <void />
            </methodsynopsis>

         </classsynopsis>
        <programlisting>
Macros:
#define sync_self
#define sync_begin(s)
#define sync_begin2(t,s)
#define sync_end


#define sync_trybegin(s)
#define sync_trybegin2(t,s)
#define sync_tryend

#define sync_global_begin(t)
#define sync_global_end

        </programlisting>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The
            <classname>SyncGuard</classname> class uses a
            <classname>Synchronizable</classname> object to create
            a critical region, or monitor.  Both of these synchronization
            primitives are mechanisms that ensure that only one thread can
            execute a guarded code segment at a time.
         </para>
         <para>
            Creating a
            <classname>SynchGuard</classname>
            on a synchronizable object locks the guard.  Destroying the
            object releases the guard.  You can create more than one
            <classname>SyncGuard</classname> on a single
            <classname>Synchronizable</classname> object, and typically will.
         </para>
         <para>
            The simplest use of
            <classname>SynchGuard</classname> is via its macros.
         </para>
         <para>
            The NSCLDAQ threading system creates a global
            <classname>Synchronizable</classname>
            object that is used by all of the locking macros and constructors that
            don't take an explicit parameter.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <constructorsynopsis>
                <methodname>SyncGuard()</methodname>
            </constructorsynopsis>
            <para>
                Constructs a synchronization guard that uses the global
                <classname>Syncrhonizable</classname> to perform
                the synchronization.
            </para>
            <constructorsynopsis>
                <methodname>SyncGuard</methodname>
                <methodparam>
                    <type>Synchronizable&amp;</type> <parameter>syncer</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Creates a
                <classname>SyncGuard</classname>
                that uses <parameter>syncer</parameter>
                as its synchronization object.
            </para>
            <constructorsynopsis>
                <methodname>SyncGuard</methodname>
                <methodparam>
                    <type>Synchronizable&amp;</type> <parameter>syncer</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>tryonly</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Same as above, however if <parameter>tryonly</parameter> is
                true, and <parameter>syncer</parameter> is already locked, the thread continues
                execution.
            </para>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~SyncGuard</methodname>
                                             <void />
            </destructorsynopsis>
            <para>
                Destroys the guard, releasing the synchronization object.
            </para>
            <methodsynopsis>
                <type>dshwrapthread_t</type> <methodname>getOwner</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                Returns the id of the thread that owns the synchronization
                object used by a synchronization guard.  One use of this is to
                do a tryonly creation and then check to see if the running thread
                owns the object (indicating the try succeeded).
            </para>
         <formalpara>
            <title>
                Macros
            </title>
            <para>
                The macros below simplify the creation of critical segments
                of code.
            </para>
         </formalpara>
         <funcsynopsis>
            <funcprototype><funcdef>void <function>sync_self</function></funcdef>
                           <void />
            </funcprototype>
         </funcsynopsis>
         <para>
            This macro is intended for use within an object that is
            derived from a
            <classname>Synchronizable</classname>.  It locks the
            current object.
         </para>
         <funcsynopsis>
            <funcprototype><funcdef>void <function>sync_begin</function></funcdef>
                <paramdef>
                    <parameter>Synchronizable&amp; s</parameter>
                </paramdef>
            </funcprototype>
         </funcsynopsis>
         <para>
            Starts a a critical region that uses
            <parameter>s</parameter>
            to synchronize access.
        </para>
        <funcsynopsis>
            <funcprototype><funcdef>void<function>sync_begin2</function></funcdef>
            <paramdef>
                <parameter>t</parameter>
            </paramdef>
            <paramdef>
                <parameter>Synchronizable&amp; s</parameter>
            </paramdef>
            </funcprototype>
        </funcsynopsis>
        <para>
            Same as <function>sync_begin</function> but
            <parameter>t</parameter> is appended to the name of the temporary
            <classname>Syncrhonizable</classname> the macro creates.
        </para>
        <funcsynopsis>
            <funcprototype><funcdef>void <function>sync_end</function></funcdef>
                                         <void />
            </funcprototype>
        </funcsynopsis>
        <para>
            Marks the end of a critical section that was begun with
            one of the sync macros above.
        </para>
        <funcsynopsis>
            <funcprototype><funcdef> void <function>sync_trybegin</function></funcdef>
            <paramdef><parameter>Synchronizable&amp; s</parameter></paramdef>
            </funcprototype>
        </funcsynopsis>
        <para>
            This macro creates a temporary
            <classname>SynchGuard</classname> object constructed on
            <parameter>s</parameter>.
            Non-blocking access is to the guard is attempted.  If successful,
            the code that follows the macro up until the next
            <function>sync_tryend</function> macro invocation is executed.
            If access to the guard could not be gotten without blocking, the
            code will not be executed.
        </para>
        <funcsynopsis>
            <funcprototype><funcdef> void <function>sync_trybegin2</function></funcdef>
            <paramdef>
                <parameter>t</parameter>
            </paramdef>
            <paramdef>
                <parameter>Synchronizable&amp; s</parameter>
            </paramdef>
            </funcprototype>
        </funcsynopsis>
        <para>
            This macro behaves the same as
            <function>sync_trybegin2</function>, however the parameter
            <parameter>t</parameter> is used to construct the name of the
            <classname>SyncGuard</classname> object used by the macro.
        </para>
        <funcsynopsis>
            <funcprototype><funcdef>void <function>sync_tryend</function></funcdef>
                        <void />
            </funcprototype>
        </funcsynopsis>
        <para>
           Marks the end of a block of code that was synchronized using the
           <function>sync_trybegin*</function> macros.
        </para>
        <funcsynopsis>
            <funcprototype><funcdef>void <function>sync_global_begin</function></funcdef>
            <paramdef>
                <parameter>t</parameter>
            </paramdef>
	    </funcprototype>
        </funcsynopsis>
        <para>
            The NSCLDAQ thread synchronization library creates a global
            <classname>Synchronizable</classname>
            object.  This can do process wide synchronization on  a coarse grained
            level.
            <function>sync_global_begin</function> constructs a
            temporary
            <classname>SyncGuard</classname> on that object and locks it.
            The <parameter>t</parameter> paramter is used to construct the name
            of the guard object.
        </para>
        <funcsynopsis>
            <funcprototype><funcdef>void sync_global_end</funcdef>
            <void />
	    </funcprototype>
        </funcsynopsis>
        <para>
            Destroys the
            <classname>SyncGuard</classname> created by lexically most recent
            <function>sync_global_begin</function> macro.  This releases the
            synchronization object for other threads.
        </para>
      </refsect1>
   </refentry>



<!-- /manpage -->
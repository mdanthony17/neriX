<!-- chapter libraries -->

<chapter id="chapter.tclplus">
    <title>C++ encapsulation of a Tcl API subset</title>
    
        <para>
            The tclPlus library provides a C++ object oriented
            encapsulation of a large subset of the Tcl application programming
            interface.  This section provides reference material for this class library.
        </para>
        <para>
            Sections of the NSCLDAQ and SpecTcl products both make extensive use of this
            library.  It is therefore distributed with both prodcuts, from a common source base.
            Therefore, there are two ways to link to this library.
            First, using SpecTcl:
            <informalexample>
            <programlisting>
            <command>
g++ -o <replaceable>yourprogram yoursources</replaceable>  \
               -L${SPECTCLHOME}/lib -ltclPlus -lException
            </command>
            </programlisting>
            </informalexample>
            where <literal>${SPECTCLHOME}</literal> represents the top level director of
            your SpecTcl installation.  At the NSCL, for example, this could be
            <filename>/usr/opt/spectcl/3.2</filename>
        </para>
        <para>
            Second, using nscldaq, replace <literal>${SPECTCLHOME}</literal> with the top
            level directory of your NSCLDAQ installation, e.g.
            <filename>/usr/opt/daq/8.1</filename>.
        </para>
        <para>
            Some brief descriptions of the primary classes in this library follow:
        </para>
        <para>
            <classname>CTCLApplication</classname>
        </para>
        <para>
            This is a base class for complete applications that extend the Tcl/Tk
            interpreter.  By appropriately subclassing it you can build your own
            standalong extended Tcl/Tk interpreters.
        </para>
        <para>
            <classname>CTCLException</classname>
        </para>
        <para>
            The Tcl/Tk API use return codes to indicate error conditions.  This is
            error prone.  The tclPlus library converts these return codes in to
            thrown exceptions of the type <classname>CTCLException</classname>.
            To handle these exceptions properly requires use of  C++ try/catch blocks.
            A code fragment example of this is provided in the
            <classname>CTCLException</classname>(3) manpage.
        </para>
        <para>
            <classname>CTCLInterpreter</classname>
        </para>
        <para>
            The <classname>CTCLInterpreter</classname> object is at the core of the
            library.  It is a wrapping of a <type>Tcl_Interp*</type> along with member
            functions that access many functions that logically operate on a Tcl interpreter.
        </para>
        <para>
            <classname>CTCLInterpreterObject</classname>
        </para>
        <para>
            The <classname>CTCLInterpreterObject</classname> wraps objects that
            require an interpreter to function correctly.  It is a base class for
            many of the classes in the library.  It provides common services for those
            objects.
        </para>
        <para>
            <classname>CTCLList</classname>
        </para>
        <para>
            In Tcl scripting, lists play a key role in providing a structured
            data type.  The <classname>CTCLList</classname> object can be created
            on a string believed to be a list, and used to split a list into its
            elements or merge a set of words into a list.
        </para>
        <para>
            <classname>CTCLObject</classname>
        </para>
        <para>
            Tcl has the philosophy that everything can be treated as if it were a string.
            In older versions of the interpreter, everything <emphasis>was</emphasis> a
            string. This led to a great deal of inefficiency converting other data types
            to and from strings.  The <type>Tcl_Obj</type> type was created to reduce this
            inefficiency and to reduce the amount of string copying that was necessary
            to invoke commands.
        </para>
        <para>
            A <type>Tcl_Obj</type> is an object  that stores the string representation
            and another representation type for a Tcl interpreter entity.  <type>Tcl_Obj</type>
            also provides for object sharing with copy on modify semantics.  This reduces
            much of the string copying overhead that was previously associated with executing
            Tcl interpreter commands.
        </para>
        <para>
            The <classname>CTCLObject</classname> is a wrappig of a <type>Tcl_Obj</type>
            along with functions that operate on the underlying object.
        </para>
        <para>
            <classname>CTCLObjectProcessor</classname>
        </para>
        <para>
            Key to the concept of the Tcl interpreter as an application scripting language
            is the ability to add new commands to the interpreter that are application
            specific.  The <classname>CTCLObjectProcessor</classname> class is an
            abstract base class that, when subclassed and instantiated adds new
            commands to the interpreter.
        </para>
        <para>
            <classname>CTCLVariable</classname>
        </para>
        <para>
            The <classname>CTCLVariable</classname> class provides access to
            Tcl script variables.
        </para>
        <para>
        <classname>CItemConfiguration</classname> and <classname>CConfigurableObject</classname>
        while not actually Tcl objects provide infrastructure that is useful
        in the context of extension to a Tcl interpreter.  Specifically the
        creation and maintanance of commands that generate objects that have
        some configuration associated with them.  Configuration is expressed
        as a set of name value pairs. While all of the values have string
        representation, validators can be associated with configuration parameters
        to enforce type safeness, and range checking.  
        </para>
        <para>
            A rich set of predefined validators are supplied with the package,
            and custom validators can also be written and used.
        </para>
        
</chapter>

<!-- /chapter -->

<!-- manpage 3daq -->

<refentry id="manpage.CTCLApplication">
    <refmeta>
        <refentrytitle>CTCLApplication 3</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLApplication</refname>
        <refpurpose>
            Base class for TCL/Tk applications.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;tcl.h&gt;
#include &lt;TCLApplication.h&gt;
...
class CTCLApplication  : public CTCLInterpreterObject
{
public:
  CTCLApplication ();
  ~CTCLApplication ( );
  virtual   int operator() ()  =0;
  void      getProgramArguments(int&amp;, char**&amp; argv);
};
        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLApplication</classname> is an abstract base class
            that facilitates the creation of applications that extend the
            Tcl interpreter.  The `main program' of SpecTcl is derived from
            this class, for example.
        </para>
        <para>
            Initializing a Tcl application generallly consists of a bunch
            of boilerplate that initializes the interpreter, and then a bunch
            of application specific code to register extensions to the interpreter.
            <classname>CTCLApplication</classname>
            provides the main boilerplate.  It is expected that you
            derive a class from
            <classname>CTCLApplication</classname>
            Implement <function>operator()</function> to register
            application specific commands, and then create exactly one
            instance of your application class named, and a global pointer
            to that object named gpTCLApplication.
        </para>
        <para>
            For example, suppose you have created a class named MyTclApp:
            <informalexample>
            <programlisting>
// This code is at the global level:
...
MyTclApp app;                              // Makes an instance of this
CTCLApplication* gpTCLApplication = &amp;app;  // Pointer expected by framework.
...
            </programlisting>
            </informalexample>
            Will ensure that the <function>operator()</function> of your
            application object will be called with the interpreter already
            initialized.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <type>int</type> <function>operator()</function>()
        </para>
        <para>
            This function is pure virtual and must be overridden by your
            derived class.  <function>operator()</function> is expected to
            install all required extensions to the interprter and return to it
            to start the main event loop.  The return value from this should be
            <literal>TCL_OK</literal> if the application was successfully initialized
            or <literal>TCL_ERROR</literal> if the program encountered an error that
            should prevent the interpreter main loop from starting
        </para>

        <methodsynopsis>
            <type>void</type> <methodname>getProgramArgs</methodname>
            <methodparam>
                <type>int&amp;</type> <parameter>argc</parameter>
            </methodparam>
            <methodparam>
                <type>char**&amp;</type> <parameter>argv</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Provides a mechanism for the concrete class to get the program
            arguments. This allows the program arguments to be parsed for
            application specific switches and arguments.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLInterpreter, CTCLInterpreterObject, CTCLObjectProcessor, CTCLVariable
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLException">
    <refmeta>
        <refentrytitle>CTCLException</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLException</refname>
        <refpurpose>
            Class for reporting exceptional conditions in Tcl applications
            via the C++ try/catch mechanism.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLException.h&gt;
...
class CTCLException  : public CTCLInterpreterObject ,public CException
{
public:
  CTCLException (CTCLInterpreter&amp; am_rInterpreter,
                 Int_t am_nReason,
                 const char* pString);
  CTCLException(CTCLInterpreter&amp; am_rInterpreter,
                Int_t am_nReason,
                const std::string&amp; rString);
  CTCLException (const CTCLException&amp; aCTCLException );
  virtual ~CTCLException ( );

  CTCLException operator= (const CTCLException&amp; aCTCLException);
  int operator== (const CTCLException&amp; aCTCLException);

  void AddErrorInfo (const char* pMessage)  ;
  void AddErrorInfo(const std::string&amp; rMessage);
  void AddErrorInfo(const CTCLString&amp; rMessage);

  void SetErrorCode (const char* pMessage,
                     const char* pMnemonic="???",
                     const char* pFacility="TCL",
                     const char* pSeverity="FATAL")  ;
  void SetErrorCode(const std::string rMessage,
                    const std::string &amp;rMnemonic=std::string("???"),
                    const std::string &amp;rFacility=std::string("TCL"),
                    const std::string &amp;rSeverity=std::string("FATAL"));

  virtual   const char* ReasonText () const;
  virtual   Int_t ReasonCode () const  ;
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <classname>CTCLException</classname> class allows you to
            instantiate and throw exceptions that are distinguishable as coming
            from the TCL library and its extensions.   In most cases the
            TclPlus library itself will convert error conditions detected by the
            Tcl API and intantiate and throw an appropriate exception.
        </para>
        <para>
            The following example shows how to execute code that is aware of
            these exceptions.  In this case, the code just reports the error
            message and continues.
            <informalexample>
            <programlisting>
    try {
        // In here is TclPlus invoking code.
    }
    catch (CTCLException&amp; e) {
        cerr &lt;&lt; "TclPlus error caught: " &lt;&lt; e.ReasonText() &lt;&lt; endl;
    }
            </programlisting>
            </informalexample>
        </para>
        <para>
            The following example shows a typical code segment that throws a
            <classname>CTCLException</classname>:
                <programlisting>
    int status = Tcl_xxxxxxx(pInterp-&gt;getInterpreter()....); // Some Tcl call.
    if (status != TCL_OK) {
        throw CTCLException(*pInterp, status,
                            "Call to Tcl_xxxxxx returned an error");
    }
                </programlisting>
        </para>
        <para>
            Note that constructing a <classname>CTCLException</classname> object
            incorporates the Tcl result string at the time into the
            text returned by the <function>ReasonText()</function> member function.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLException</function> (<type>CTCLInterpreter</type>&amp; <parameter>rInterpreter</parameter>,
                 <type>Int_t</type> <parameter>nReason</parameter>,
                 const <type>char</type>* <parameter>pString</parameter>);
  <function>CTCLException</function>(<type>CTCLInterpreter</type>&amp; <parameter>rInterpreter</parameter>,
                <type>Int_t</type> <parameter>nReason</parameter>,
                const <type>std::string</type>&amp; <parameter>rString</parameter>);
  <function>CTCLException</function> (const <type>CTCLException</type>&amp; <parameter>aCTCLException</parameter> );
        </programlisting>
        </para>
        <para>
            These construct a <classname>CTCLException</classname>.
            <parameter>rInterpreter</parameter> is a reference to the intepreter that was
            used in the operation that resulted in the error.  The result string of that
            interpreter will be saved as part of the text returned by the
            <function>ReasonText</function> member function.
        </para>
        <para>
            The <parameter>nReason</parameter> is a reason for the exception.  Typically
            this will be <literal>TCL_ERROR</literal> however other error codes can be
            created and used for application specific problems.  This is the value that will
            be returned by the <function>ReasonCode</function> member function.
        </para>
        <para>
            <parameter>rString</parameter> and <parameter>pString</parameter> are intended to provide
            information about the context of the error, and will be incorporated into the
            text strin greturned from <function>ReasonText</function>.
        </para>
        <para>
            <parameter>aCTCLException</parameter> is a reference for the sourc object of
            the copy constructor.
        </para>
        <para>
        <programlisting>
  <type>CTCLException</type> <function>operator=</function> (const <type>CTCLException</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function>(const <type>CTCLException</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These two functions provide a mechanism to assign exceptions and to compare
            them for equality.  <parameter>rhs</parameter> is the object that is the source
            of the assignment or the object to which <varname>this</varname> is being compared.
            Equality is defined as the two exceptions having the same underlying interpreter,
            and same reason text.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>AddErrorInfo</function> (const <type>char</type>* <parameter>pMessage</parameter>)  ;
  <type>void</type> <function>AddErrorInfo</function>(const <type>std::string</type>&amp; <parameter>rMessage</parameter>);
  <type>void</type> <function>AddErrorInfo</function>(const <type>CTCLString</type>&amp; <parameter>rMessage</parameter>);
        </programlisting>
        </para>
        <para>
            These functions are wrapperf ro the API function <function>Tcl_AddErrorInfo</function>
            the <parameter>pMessage</parameter>, and <parameter>rMessage</parameter>
            parameters provide the message that is added to the <parameter>errorInfo</parameter>
            variable.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>SetErrorCode</function> (const <type>char</type>* <parameter>pMessage,</parameter>
                     const <type>char</type>* <parameter>pMnemonic</parameter>=<literal>"???"</literal>,
                     const <type>char</type>* <parameter>pFacility</parameter>=<literal>"TCL"</literal>,
                     const <type>char</type>* <parameter>pSeverity</parameter>=<literal>"FATAL"</literal>)  ;
  <type>void</type> <function>SetErrorCode</function>(const <type>std::string</type> <parameter>rMessage</parameter>,
                    const <type>std::string</type>&amp; <parameter>rMnemonic</parameter>=<type>std::string</type>(<literal>"???"</literal>),
                    const <type>std::string</type>&amp; <parameter>rFacility</parameter>=<type>std::string</type>(<literal>"TCL"</literal>),
                    const <type>std::string</type>&amp; <parameter>rSeverity</parameter>=<type>std::string</type>(<literal>"FATAL</literal>"));
        </programlisting>
        </para>
        <para>
            These function set the <varname>errorCode</varname> Tcl interpreter variable.
            The convention these function support is to set the error code to a list that
            consists of a message (<parameter>pMessage</parameter> and <parameter>rMessage</parameter>,
            mnemonic for the message (<parameter>pMnemonic</parameter> or <parameter>rMnemonic</parameter>, the
            Facility (<parameter>pFacility</parameter> or <parameter>rFacility</parameter>)that is throwing
            the error and the severity (<parameter>pSeverity</parameter> or <parameter>rSeverity</parameter>)
            of the error.
        </para>
        <para>
            <programlisting>
virtual   const <type>char</type>* <function>ReasonText</function> () const;
virtual   <type>Int_t</type> <function>ReasonCode</function> () const  ;
        </programlisting>
        </para>
        <para>
            These two functions are intended for use by exception catch blocks.
            <function>ReasonText</function> provides human readable text that
            describes the exception.  <function>ReasonCode</function> provides a
            numerical code that describes the exception.  Often this just has the
            value <literal>TCL_ERROR</literal>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
Tcl_AddErrorInfo(3tcl),
Tcl_SetErrorCode(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLInterpreter">
    <refmeta>
        <refentrytitle>CTCLInterpreter</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLInterpreter</refname>
        <refpurpose>
            Encapsulate a Tcl interpreter.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;TCLInterpreter.h&gt;

class CTCLInterpreter
{
public:
  CTCLInterpreter ();
  CTCLInterpreter (Tcl_Interp* am_pInterpreter  );

  Tcl_Interp* getInterpreter()
  std::string Eval (const char* pScript) ;
  std::string Eval(const CTCLString&amp; rScript);
  std::string Eval(const std::string&amp; rScript);
  std::string EvalFile (const char* pFilename)   ;
  std::string EvalFile(const CTCLString&amp; rFilename);
  std::string EvalFile(const std::string&amp; rFilename);

  std::string GlobalEval (const char* pScript)   ;
  std::string GlobalEval (const CTCLString&amp; rScript) ;
  std::string GlobalEval(const std::string&amp; rScript) ;

  std::string RecordAndEval (const char* pScript, Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const CTCLString&amp; rScript,
                            Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const std::string&amp; rScript,
                            Bool_t fEval = kfFALSE);

  std::string ExprString (const char* pExpression)   ;
  std::string ExprString(const CTCLString&amp; rExpr);
  std::string ExprString(const std::string&amp; rExpr);

  Long_t ExprLong (const char* pExpression)   ;
  Long_t ExprLong (std::string&amp; rExpression);
  Long_t ExprLong (const CTCLString&amp; rExpr);

  DFloat_t ExprDouble (const char* pExpression)   ;
  DFloat_t ExprDouble (const CTCLString&amp; rExpression);
  DFloat_t ExprDouble(const std::string&amp; rExpression);

  Bool_t ExprBoolean (const char*  pExpression)   ;
  Bool_t ExprBoolean (const CTCLString&amp; rExpression);
  Bool_t ExprBoolean(const std::string&amp; rExpression);

  std::string TildeSubst (const char* pFilename) const  ;
  std::string TildeSubst (const CTCLString&amp; rName) const;
  std::string TildeSubst (const std::string&amp; rName) const;
  std::string EvalFile (const char* pFilename)   ;
  std::string EvalFile(const CTCLString&amp; rFilename);
  std::string EvalFile(const std::string&amp; rFilename);

  std::string GlobalEval (const char* pScript)   ;
  std::string GlobalEval (const CTCLString&amp; rScript) ;
  std::string GlobalEval(const std::string&amp; rScript) ;

  std::string RecordAndEval (const char* pScript, Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const CTCLString&amp; rScript,
                            Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const std::string&amp; rScript,
                            Bool_t fEval = kfFALSE);

  std::string ExprString (const char* pExpression)   ;
  std::string ExprString(const CTCLString&amp; rExpr);
  std::string ExprString(const std::string&amp; rExpr);

  Long_t ExprLong (const char* pExpression)   ;
  Long_t ExprLong (std::string&amp; rExpression);
  Long_t ExprLong (const CTCLString&amp; rExpr);

  DFloat_t ExprDouble (const char* pExpression)   ;
  DFloat_t ExprDouble (const CTCLString&amp; rExpression);
  DFloat_t ExprDouble(const std::string&amp; rExpression);

  Bool_t ExprBoolean (const char*  pExpression)   ;
  Bool_t ExprBoolean (const CTCLString&amp; rExpression);
  Bool_t ExprBoolean(const std::string&amp; rExpression);

  std::string TildeSubst (const char* pFilename) const  ;
  std::string TildeSubst (const CTCLString&amp; rName) const;
  std::string TildeSubst (const std::string&amp; rName) const;
  Tcl_Interp* operator-&gt; ();
  operator Tcl_Interp* ();
};



    </programlisting>
    </refsynopsisdiv>


    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLInterpreter</classname>
            encapsulates a <type>Tcl_Interp*</type> in an object.
            Method invocations on that object provide access to many of the
            Tcl interpreter. See METHODS below for more information about htis.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <function>CTCLInterpreter () </function>
        </para>
        <para>
            <function>CTCLInterpreter</function> (
                <type>Tcl_Interp</type>* <parameter>pInterp</parameter>)
        </para>
        <para>
            Constructs an interpreter object.  The first form of this
            constructor creates a new <type>Tcl_Interp*</type> using
            <function>Tcl_CreateInterp()</function> and wraps the object
            around it.  All members of the object will operate on that
            newly created interpreter.  The second form, wraps an object
            around <parameter>pInterp</parameter>,
            a previously created <type>Tcl_Interp*</type>.
            Note that in either case on destruction, <function>Tcl_DeleteInterp()</function>
            is called on the wrapped interpreter.
        </para>
        <para>
            <type>Tcl_Interp</type>* <function>getInterpreter</function>()
        </para>
        <para>
            Returns the interpreter that is being wrapped by this object.
            This interpreter can be used as an <parameter>interp</parameter>
            parameter for any <function>Tcl_xxxxxx</function> call in the Tcl
            API.
        </para>
        <para>
            <programlisting>
<type>std::string</type> <function>Eval</function>(<type>const char</type>* <parameter>pScript</parameter>) ;
<type>std::string</type> <function>Eval</function>(<type>const CTCLString</type>&amp; <parameter>rScript</parameter>);
<type>std::string</type> <function>Eval</function>(<type>const std::string</type>&amp; <parameter>rScript</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates the script passed as a parameter.  The only differences between
            these functions is the form of the script parameter.  Each function will
            return the result of the script.  If there is an error in the script,
            a <classname>CTCLException</classname> will be thrown that will describe
            what happened.  For example:
            <programlisting>
    std::string commands;
    CTCLInterpreter interp;     // New intepreter.
    ...
    // after commands has been built up:

    string result
    try {
        result = interp.Eval(commands);
        cout &lt;&lt; "Eval of " &lt;&lt; commands &lt;&lt; " was "
             &lt;&lt;  result &lt;&lt; endl;
    }
    catch (CTCLException &amp;e) {
        cerr &lt;&lt; "Eval of " &lt;&lt; commands &lt;&lt; " failed: "
             &lt;&lt; e.ReasonText() &lt;&lt; endl;
    }
    // If no exception, result is usable as the output of the eval.

            </programlisting>
        </para>
        <para>
        <programlisting>
  <type>std::string</type> <function>EvalFile</function>(<type>const char</type>* <parameter>pFilename</parameter>)   ;
  <type>std::string</type> <function>EvalFile</function>(<type>const CTCLString</type>&amp; <parameter>rFilename</parameter>);
  <type>std::string</type> <function>EvalFile</function>(<type>const std::string</type>&amp; <parameter>rFilename</parameter>);
        </programlisting>
        </para>
        <para>
            Sources the specified file in and executes it as a script in the interpreter that
            is wrapped by the object.  The only difference between these functions is
            how the name of the file is passed.  The return value is the script result.
            A <classname>CTCLException</classname> will be thrown in the event the script
            reports an error.  See the example in
            <classname>CTCLInterpreter</classname>::<function>Eval</function>
            to see how to catch and report this kind of exception.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>GlobalEval</function>(<type>const char</type>* <parameter>pScript</parameter>);
  <type>std::string</type> <function>GlobalEval</function>(<type>const CTCLString</type>&amp; <parameter>rScript</parameter>);
  <type>std::string</type> <function>GlobalEval</function>(<type>const std::string</type>&amp; <parameter>rScript</parameter>);
            </programlisting>
        </para>
        <para>
            This function evaluates a script at the global level.  Note that
            <classname>CTCLInterpreter</classname>::<function>Eval</function>,
            and <classname>CTCLInterpreter></classname>::<function>EvalFile</function>
            evaluates the script at whatever call level the interpreter is currently
            executing at.
            The only difference between the methods above is how the script is passed.
            The functions all return the interpreter result after the script executes.
            If the script reports an error, a <classname>CTCLException</classname> will
            be thrown.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>RecordAndEval</function> (<type>const char</type>* <parameter>pScript</parameter>,
                       <type>Bool_t</type> <parameter>fEval</parameter>=<literal>kfFALSE</literal>);
  <type>std::string</type> <function>RecordAndEval</function>(<type>const CTCLString</type>&amp; <parameter>rScript</parameter>,
                       <type>Bool_t</type> <parameter>fEval</parameter>=<literal>kfFALSE</literal>);
  <type>std::string</type> <function>RecordAndEval</function>(<type>const std::string</type>&amp; <parameter>rScript</parameter>,
                      <type>Bool_t</type> <parameter>fEval</parameter>=<literal>kfFALSE</literal>);
            </programlisting>
        </para>
        <para>
            Records a script in the Tcl interpreter history and, if <parameter>fEval</parameter>
            is <literal>kfTRUE</literal>, evaluates it as well.  The
            return value is the interpreter result, which is only meaningful if the
            script was evalutated.  If the script reports an error, a
            <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>ExprString</function>(<type>const char</type>* <parameter>pExpression</parameter>);
  <type>std::string</type> <function>ExprString</function>(<type>const CTCLString</type>&amp; <parameter>rExpr</parameter>);
  <type>std::string</type> <function>ExprString</function>(<type>const std::string</type>&amp; <parameter>rExpr</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates an expression (as if with the <command>expr</command>
            Tcl command), and returns the result
            of the evaluation as a string.  If the expression has an error,
            a <classname>CTCLException</classname> will be thrown.
            The only difference between these functions is how the expression is passed.
        </para>
        <para>
            <programlisting>
  <type>Long_t</type> <function>ExprLong</function>(<type>const char</type>* <parameter>pExpression</parameter>)   ;
  <type>Long_t</type> <function>ExprLong</function>(<type>std::string</type>&amp; <parameter>rExpression</parameter>);
  <type>Long_t</type> <function>ExprLong</function>(<type>const CTCLString</type>&amp; <parameter>rExpr</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates an expression (as if with the <command>expr</command>
            Tcl command).  If the result
            can be converted into an integer, it is returned as a <type>Long_t</type>.
            If the expression either cannot be converted to an integer (e.g. it's a non-numerical
            expression), or if the expression contains an error, a <classname>CTCLException</classname>
            will be
            thrown.
        </para>
        <para>
            <programlisting>
  <type>DFloat_t</type> <function>ExprDouble</function>(<type>const char</type>* <parameter>pExpression</parameter>)   ;
  <type>DFloat_t</type> <function>ExprDouble</function>(<type>const CTCLString</type>&amp; <parameter>rExpression</parameter>);
  <type>DFloat_t</type> <function>ExprDouble</function>(<type>const std::string</type>&amp; <parameter>rExpression</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates the parameter as an expression (as if with the <command>expr</command> Tcl command).
            If the result can be converted to a floating point value it is returned as
            the function value.  If not, or if there is an error in the expression,
            a <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
  <type>Bool_t</type> <function>ExprBoolean</function>(<type>const char</type>*  <parameter>pExpression</parameter>)   ;
  <type>Bool_t</type> <function>ExprBoolean</function>(<type>const CTCLString</type>&amp; <parameter>rExpression</parameter>);
  <type>Bool_t</type> <function>ExprBoolean</function>(<type>const std::string</type>&amp; <parameter>rExpression</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates the parameter as an expression (as if with the <command>expr</command>
            Tcl command).  If the result can be interpreted as a boolean, it is returned
            as the function value.  If not, or if there is an error in the expression,
            a <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>TildeSubst</function>(<type>const char</type>* <parameter>pFilename</parameter>) const  ;
  <type>std::string</type> <function>TildeSubst</function>(<type>const CTCLString</type>&amp; <parameter>rName</parameter>) const;
  <type>std::string</type> <function>TildeSubst</function>(<type>const std::string</type>&amp; <parameter>rName</parameter>) const;
            </programlisting>
        </para>
        <para>
            Performs tilde substitution on its parameter.   Tilde substitution means that leading
            &#152; characters are expanded to the current user's home directory path, while
            a leading &#152; followed by a word that is a username will be expanded to the
            home directory path of that user.  The expanded value is returned.
            Note thatthe use of this member is deprecated as the underlying Tcl library
            function is also deprecated.
        </para>
        <para>
        <programlisting>
  <type>Tcl_Interp</type>* <function>operator-&gt;</function>();
  <function>operator Tcl_Interp* </function>();
        </programlisting>
        </para>
        <para>
            These two functions allow objects that are <classname>CTCLInterpreter</classname>
            objects to be treated as if they were <type>Tcl_Interp*</type>'s.
            <function>operator-&gt;</function> supports dereferncing to fields of the
            wrapped interpreter (note that this is now deprecated within Tcl itself).
            <function>operator Tcl_Interp*</function> supports dynamic type conversion from
            a <classname>CTCLInterpreteter</classname> object and a <type>Tcl_Interp*</type>
            pointer.
        </para>
    </refsect1>
    <refsect1>
        <title>DEFECTS</title>
        <para>
            It is not possible to avoid destroying the interpreter when the
            object is destroyed.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLException, CTCLApplication, CTCLChannel, CTCLCommandPackage,
        CTCLFileHandler, CTCLList, CTCLObject, CTCLObjectProcessor, CTCLTimer,
        CTCLVariable
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLInterpreterObject">
    <refmeta>
        <refentrytitle>CTCLInterpreterObject  3 </refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLInterpreterObject</refname>
        <refpurpose>
            Base class for objects that are associated with a Tcl Interpreter.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;CTCLInterpreterObject.h&gt;
...
class CTCLInterpreterObject
{
public:
  CTCLInterpreterObject ();
  CTCLInterpreterObject (CTCLInterpreter* pInterp );
  CTCLInterpreterObject (const CTCLInterpreterObject&amp; src );

  CTCLInterpreterObject&amp; operator=
                        (const CTCLInterpreterObject&amp; rhs);
  int operator== (const CTCLInterpreterObject&amp; rhs) const;


  CTCLInterpreter* getInterpreter() const;
  CTCLInterpreter* Bind (CTCLInterpreter&amp; rBinding);
  CTCLInterpreter* Bind (CTCLInterpreter* pBinding);

};


        </programlisting>

    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLInterpreterObject</classname>
            is a base class for any object that requires a <type>CTCLInterpreter</type>
            (Tcl interpreter) to operate.  Almost  all objects in the Tcl++ library are
            derived from this base class.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <function>CTCLInterpreterObject()</function>
        </para>
        <para>
            Constructor for an interpreter object that will be bound to an underlying
            interpreter at a later time.  See the <function>Bind</function> functions
            for more information about binding interpreters. More normally, if you
            already have an interpreter you will construct using that interpreter.
        </para>
        <para>
            <function>CTCLInterpreterObject</function>
                       (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>)
        </para>
        <para>
            Constructs a <classname>CTCLInterpreterObject</classname> given
            that <parameter>pInterp</parameter> is an existing
            interpreter encapsulated in a <classname>CTCLInterpreter</classname>.
        </para>
        <para>
            <function>CTCLInterpreterObject</function>
                    (<type>const CTCLObject</type>&amp; <parameter>src</parameter>)
        </para>
        <para>
            Constructs a new <classname>CTCLInterpreterObject</classname>
            that is an exact copy of <parameter>src</parameter>.
        </para>
        <para>
            <classname>CTCLInterpreterObject</classname>&amp;
            <function>operator=</function>
                (const <type>CTCLInterpreterObjectd</type>&amp; <parameter>rhs</parameter>)
        </para>
        <para>
            Provides a mechanism for assigning a <classname>CTCLInterpreterObject</classname>
            a copy of the <parameter>rhs</parameter> <classname>CTCLInterpreterObject</classname>.
            The return value is just a reference to the left hand side of the assignment.  This
            permits operator chaining.
        </para>
        <para>
            <type>int</type> <function>operator==</function>(
                            const <type>CTCLInterpreterObject</type>&amp; rhs)
        </para>
        <para>
            Compares a <classname>CTCLInterpreterObject</classname> to another
            (<parameter>rhs</parameter>).  If the underlying interpreters are the
            same, the objects are said to be equal and <literal>1</literal> is
            returned.  If not, <literal>0</literal> is returned.
        </para>
        <para>
            <type>CTCLInterpreter</type>* <function>getInterpreter</function>() const
        </para>
        <para>
            Returns a pointer to the underlying <classname>CTCLInterpreter</classname>
            object.  See the <classname>CTCLInterpreter</classname>(3) manpage for
            more information about the services offered by that class.
        </para>
        <para>
            <type>CTCLInterpreter</type>* <function>Bind</function>(
                        <type>CTCLInterpreter</type>&amp; <parameter>rBinding</parameter>
                                                          )
        </para>
        <para>
            <type>CTCLInterpeter</type>* <function>Bind</function>(
                        <type>CTCLInterpreter</type>* <parameter>pBinding</parameter>)
        </para>
        <para>
            Binds the object to a new interpreter.  Typically this will only be
            called when the object was constructed without an initial interpreter.
            This is because most objects really are related to some interpreter and cannot
            be willy-nilly rebound.  The return value is  a pointer to the
            <classname>CTCLInterpreter</classname> the object was previously
            bound to.  This will be <literal>NULL</literal> if the object was not
            initially bound.
        </para>
    </refsect1>
    <refsect1>
        <title>DEFECTS</title>
        <para>
            No <function>operator!=</function> was defined.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLInterpreter, CTCLApplication, CTCLChannel, CTCLCommandPackage,
        CTCLFileHandler, CTCLList, CTCLObject, CTCLObjectProcessor, CTCLTimer,
        CTCLVariable
        </para>
    </refsect1>
</refentry>
<refentry id="manpage.CTCLList">
    <refmeta>
        <refentrytitle>CTCLList</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLList</refname>
        <refpurpose>
            Provide access to Tcl List parsing.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;TCLList.h&gt;
...
class CTCLList  : public CTCLInterpreterObject
{

public:
  CTCLList (CTCLInterpreter* pInterp);
  CTCLList (CTCLInterpreter* pInterp, const  char* am_pList  );
  CTCLList (CTCLInterpreter* pInterp, const std::string&amp; rList);
  CTCLList (const CTCLList&amp; aCTCLList );

  CTCLList&amp; operator= (const CTCLList&amp; aCTCLList);
  int operator== (const CTCLList&amp; aCTCLList);
  int operator!= (const CTCLList&amp; aCTCLList);

  const char* getList() const;

  int Split (StringArray&amp; rElements)  ;
  int Split (int&amp; argc, char*** argv);

  const char* Merge (const StringArray&amp; rElements)  ;
  const char* Merge(int argc, char** argv);

};


        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl Lists are white space separated words.  It is definition of
            words and quoting issues that makes the parsing of lists less than
            straightforward.
        </para>
        <para>
            Fortunately, Tcl provides several list processing functions.  The
            concept of a list and access to list processing functions are
            encapsulated in the <classname>CTCLList</classname> class.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>

<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          const  <type>char</type>* <parameter>pList</parameter>  );
<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          const <type>std::string</type>&amp; <parameter>rList</parameter>);
<type>CTCLList</type> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These four functions provide various ways to create a <classname>CTCLList</classname>
            object.  The first constructor creates an empty list.  The next two, create a list
            that has an initial value given by either the <literal>NULL</literal>
            terminated string <parameter>pList</parameter>, or the <type>std::string</type>
            object <parameter>rList</parameter>.
            The final constructor creates a list that is a duplicate of the list
            described by the object <parameter>rhs</parameter>.
        </para>
        <para>
            <programlisting>

  <type>CTCLList</type>&amp; <function>operator=</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator!=</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
            </programlisting>
        </para>
        <para>
            These function provide assignment (<function>operator=</function>),
            equality comparison (<function>operator==</function>), and
            inequality comparison (<function>operator!=</function>) with another
            <classname>CTCLList</classname> object, <parameter>rhs</parameter>.
            Assignment is defined as copying the string format of the list.
            Equality comparison is defined as the both interpreter and strings being equal.
            Inequality is defined as !operator==.
        </para>
        <para>
            <programlisting>
  const <type>char</type>* <function>getList()</function> const;
            </programlisting>
        </para>
        <para>
            <function>getList</function> returns an immutable pointer to
            the string rerpesentation of the list.  Note that the const qualfier
            on the pointer means that attempts to dereference the pointer which
            would modify the list result in error messages.  For Example:
            <programlisting>
        CTCLList aList(pInterp, "some list");
        const char* pData = aList.getList();
        *pData = 'S';         // Compiler error!!!!
            </programlisting>
        </para>
        <para>
            <programlisting>
<type>int</type> <function>Split</function> (<type>StringArray</type>&amp; <parameter>rElements</parameter>)  ;
<type>int</type> <function>Split</function> (<type>int</type>&amp; <parameter>argc</parameter>,
           <type>char</type>*** <parameter>argv</parameter>);
            </programlisting>
        </para>
        <para>
            Splits a list up into its component words.   <parameter>relements</parameter>
            is a <type>std::vector&lt;std::string&gt;</type> into which the elements will be split.
            <parameter>argc</parameter> is a reference to an integer into which the
            number of elements will be put. <parameter>argv</parameter> is a pointer to a
            <type>char</type>** into which will be placed a pointer to dynamically
            allocated storage containing a list of <parameter>argc</parameter> pointers
            to the words in the string.  This storage must be released by the caller
            with  <function>Tcl_Free</function>.
            For example:
            <programlisting>
                CTCLList someList(pInterp, someInitialContents);
                ...
                int argc;
                char** argv;
                someList.Split(argc, &amp;argv);
                //
                //  ... do something with the data
                //
                ...
                //
                // Done with the list elements.
                //
                Tcl_Free((char*)argv);
            </programlisting>
        </para>
        <para>
            <programlisting>
const <type>char</type>* <function>Merge</function> (const <type>StringArray</type>&amp; <parameter>rElements</parameter>)  ;
const <type>char</type>* <function>Merge</function>(<type>int</type> argc,
                 <type>char</type>** <parameter>argv</parameter>);
        </programlisting>
        </para>
        <para>
            Merges a bunch of words in to a list.  If necessary, quoting is performed to
            ensure that words that have whitespace or other special characters will be
            correctly formatted into the list. <parameter>rElements</parameter> is a
            <type>std::vector&lt;std::string&gt;</type> of words that will be merged into the
            string.  <parameter>argc</parameter> is a count of the number of words,
            and <parameter>argv</parameter> is a pointer to an array of pointers to the
            words stored as <literal>NULL</literal> terminated strings.
            The return value is the final string representation of the list after the
            merge operation has been performed.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLInterpreter(3),
CTCLInterpreterObject(3),
Tcl_Free(3tcl)
        </para>
    </refsect1>
</refentry>
<refentry id="manpage.CTCLObject">
    <refmeta>
        <refentrytitle>CTCLObject</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLObject</refname>
        <refpurpose>
            Encapsulate Tcl Dual ported objects.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;TCLObject.h&gt;
...
class CTCLObject : public CTCLInterpreterObject
{

public:
  CTCLObject ();
  CTCLObject (Tcl_Obj* am_pObject);
  CTCLObject (const CTCLObject&amp; aCTCLObject );
  virtual  ~CTCLObject ( );

  CTCLObject&amp; operator= (const CTCLObject&amp; aCTCLObject);
  int operator== (const CTCLObject&amp; aCTCLObject) const;

  Tcl_Obj* getObject();
  const Tcl_Obj* getObject() const;

   CTCLObject&amp; operator= (const std::string&amp; rSource)    ;
   CTCLObject&amp; operator= (const char* pSource)    ;
   CTCLObject&amp; operator= (int nSource)    ;
   CTCLObject&amp; operator= (const CTCLList&amp; rList)    ;
   CTCLObject&amp; operator= (double dSource)     ;
   CTCLObject&amp;  operator=(Tcl_Obj* rhs);

  operator std::string ()    ;
  operator int ()    ;
  operator CTCLList ()    ;
  operator double ()    ;

  CTCLObject&amp; operator+= (const CTCLObject&amp; rObject)    ;
  CTCLObject&amp; operator+= (int nItem)    ;
  CTCLObject&amp; operator+= (const std::string&amp; rItem)    ;
  CTCLObject&amp; operator+= (const char* pItem)    ;
  CTCLObject&amp; operator+= (double  Item)    ;

  CTCLObject clone ()    ;

  CTCLObject operator() ()    ;

  CTCLObject   getRange(int first, int last);

  CTCLObject&amp;  concat(CTCLObject&amp; rhs); // Concat lists.
  std::vector&lt;CTCLObject&gt;  getListElements();
  CTCLObject&amp;  setList(std::vector&lt;CTCLObject&gt; elements);
  int          llength();
  CTCLObject   lindex(int index);
  CTCLObject&amp;  lreplace(int first, int count, std::vector&lt;CTCLObject&gt; newElements);

};

        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl as a scripting language carries a deeply embedded philosophy that
            everything can be treated as a string.  Nonetheless, in many cases,
            entities manipulated by the interpreter are more efficiently manipulated
            when they have other types of internal representations.  For example strings
            which represent floating point numbers in extended computations are more
            efficiently represented directly as <type>float</type> or <type>double</type>
            variables.
        </para>
        <para>
            Tcl uses <firstterm>dual ported</firstterm> objects to capture this efficiently.
            A Tcl object is a thing that has a string representation and at most one
            other typed representation (e.g. list, integer, floating point).  Conversions
            from string to this representation are done once and cached as long as possible,
            so that when an object has been used as a particular type there is essentially
            no additional conversion cost to use it as that type again.
        </para>
        <para>
            While a <type>Tcl_Obj</type> and therefore a <classname>CTCLObject</classname>
            can exist independent of an interpreter, many member functions require the
            object be bound to an interpreter, or they will fail with an assertion failure
            causing the program to abort.  Use the base class <function>Bind</function>
            (<classname>CTCLInterpreterObject</classname>::<function>Bind</function>)
            member to bind the object to an existing interpreter, usually as soon as
            possible.
        </para>
        <para>
            Tcl objects also can be shared with a lazy copy on write scheme so that
            overhead associated with duplicating objects (e.g. when using them as
            parameters to Tcl commands) is minimized.
        </para>
        <para>
            <classname>CTCLObject</classname> exposes an object oriented interface to the
            Tcl dual ported object.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <programlisting>
  <function>CTCLObject</function> ();
  <function>CTCLObject</function> (<type>Tcl_Obj</type>* <parameter>pObject</parameter>);
  <function>CTCLObject</function> (const <type>CTCLObject</type>&amp; <parameter>rhs</parameter> );
            </programlisting>
        </para>
        <para>
            Constructs a Tcl object wrapped in a <classname>CTCLObject</classname>.
            <parameter>pObject</parameter> is an existing <type>Tcl_Obj</type> pointer that will be wrapped.
            <parameter>rhs</parameter> is an existing <classname>CTCLObject</classname>
            that will be used to create another reference to the same underlying
            object.  Note that in the last two of these forms, a new <type>Tcl_Obj</type>
            is not created.  Instead, <function>Tcl_IncrRefCount</function> is used
            on the previously existing object to mark it as shared.
            All member functions which  modify the underlying object will create a new
            object (copy on write semantics), and decrement the reference count of the
            original object.  Destroying a <classname>CTCLObject</classname> invokes
            <function>Tcl_DecrRefCount</function> on the underlying <type>Tcl_Obj</type>
            object.  This may or may not result in destruction of that underlying object
            depending on the resulting reference count.
        </para>
        <para>
            <programlisting>

  <type>CTCLObject</type>&amp; <function>operator</function>= (const <type>CTCLObject</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLObject</type>&amp; <parameter>rhs</parameter>) const;
            </programlisting>
        </para>
        <para>
            These two members provide assignment and equality comparison for <classname>CTCLObject</classname>
            instances with another object <parameter>rhs</parameter>.  Assignment operates
            efficiently by decrementing the reference count on the prior object,
            incrementing the reference count for <parameter>rhs</parameter>, and
            copying its <type>Tcl_Obj*</type> only.
            Equality comparision is true if the underlying objects have the same string
            representation.
        </para>
        <para>
            <programlisting>
  <type>Tcl_Obj</type>* <function>getObject</function>();
  const <type>Tcl_Obj</type>* <function>getObject</function>() const;
            </programlisting>
        </para>
        <para>
            Retrieves a mutable or immutable pointer to the underlying object.
            If you intend to retain this pointer for longer than the lifetime of the
            <classname>CTCLObject</classname> object from which it comes or longer
            than the lifetime of the execution of the calling function you should
            invoke <function>Tcl_IncrRefCount</function> to mark the object shared
            and prevent its destruction until you no longer need it, at which point
            you should invoke <function>Tcl_DecrRefCount</function>.
        </para>
        <para>
            You should not modify the underlying object as that violates the
            copy on write semantics expected of <type>Tcl_Obj</type> objects.
            Instead, use <function>Tcl_DuplicateObj</function> to create a new
            object (decrementing the reference count of the previous object), and
            modify that one instead.  The following code snippet shows this:
            <programlisting>
        int      len;
        Tcl_Obj* pObject = someObject.getObject();
        string   value   = string(Tcl_GetStringFromObj(pObject, &amp;len));
        value           += "new text";
        pObject          = Tcl_DuplicateObj(pObject); // Split off a new object.
        Tcl_SetStringObj(pObject, (char*)value.c_str(), -1);
            </programlisting>
        </para>
        <para>
            <programlisting>
   <type>CTCLObject</type>&amp; <function>operator=</function> (const <type>std::string</type>&amp; <parameter>rSource</parameter>)    ;
   <type>CTCLObject</type>&amp; <function>operator=</function> (const <type>char</type>* <parameter>pSource</parameter>)    ;
   <type>CTCLObject</type>&amp; <function>operator=</function> (<type>int</type> <parameter>nSource</parameter>)    ;
   <type>CTCLObject</type>&amp; <function>operator=</function> (const <type>CTCLList</type>&amp; <parameter>rList</parameter>)    ;
   <type>CTCLObject</type>&amp; <function>operator=</function> (<type>double</type> <parameter>dSource</parameter>)     ;
   <type>CTCLObject</type>&amp; <function>operator=</function>(<type>Tcl_Obj</type>* <parameter>rhs</parameter>);
            </programlisting>
        </para>
        <para>
            Assigns a new value to the object.  The reference count of the previously
            encapsulated object is decremented and a new object is created into
            which the right hand side value is loaded.  This preserves copy on write
            semantics.  <parameter>rSource</parameter> and <parameter>pSource</parameter> load
            the new object with a string valued entity.  No attempt is made to create another
            representation for the object (yet).
            <parameter>nSource</parameter> loads the object with an integer value and its
            string representation.
            <parameter>rList</parameter> loads the object with a list representation and
            its string representation.
            <parameter>dSource</parameter> loads the object with a double precision floating
            point value and its string representation.  <parameter>rhs</parameter> simply
            copies in the new object pointer and increments its reference count.
        </para>
        <para>
            <programlisting>

  <function>operator std::string</function> ()    ;
  <function>operator int</function> ()    ;
  <function>operator CTCLList</function> ()    ;
  <function>operator double</function> ()    ;
            </programlisting>
        </para>
        <para>
            These function provide implicit and explicit type conversions between
            a <classname>CTCLObject</classname> instance and other types.
            The type conversions attempt to extract the appropriately typed value
            from the underlying object.  If successful, the value is returned.
            On failure, a <classname>CTCLException</classname> is thrown.
            For example:
            <programlisting>
        CTCLObject object = "3.14159";  // String rep.
        object.Bind(pInterp);           // Some of these need an interp.
        double     pi     = object      // (operator double()).
        object            = "george";   // string rep.
        try {
           int trash = object;          // fails.
        }
        catch (CTCLException&amp; e) {
            // this catch block will execute.
        }
            </programlisting>
        </para>
        <para>
            <programlisting>

<type>CTCLObject</type>&amp; <function>operator+=</function> (const <type>CTCLObject</type>&amp; <parameter>rObject</parameter>)    ;
<type>CTCLObject</type>&amp; <function>operator+=</function> (<type>int</type> <parameter>nItem</parameter>)    ;
<type>CTCLObject</type>&amp; <function>operator+=</function> (const <type>std::string</type>&amp; <parameter>rItem</parameter>)    ;
<type>CTCLObject</type>&amp; <function>operator+=</function> (const <type>char</type>* <parameter>pItem</parameter>)    ;
<type>CTCLObject</type>&amp; <function>operator+=</function> (<type>double</type>  <parameter>Item</parameter>)    ;
            </programlisting>
        </para>
        <para>
            Creates the list representation of the underlying object, converts either
            <parameter>rObject</parameter>,
            <parameter>nItem</parameter>,
            <parameter>rItem</parameter>,
            <parameter>pItem</parameter>,
            <parameter>Item</parameter> to its string representation and appends
            it as a list entry to the object.
        </para>
        <para>
            <programlisting>

  <type>CTCLObject</type> <function>clone</function> ()    ;
            </programlisting>
        </para>
        <para>
            A wrapper for <function>Tcl_DuplicateObj</function>.  The object is
            duplicated and its duplicate is returned wrapped by a
            <classname>CTCLOjbect</classname>.
        </para>
        <para>
            <programlisting>

<type>CTCLObject</type> <function>operator()</function> ()    ;
            </programlisting>
        </para>
        <para>
            The object's string representation is compiled by its bound
            interpreter to Tcl byte code and executed as a script by that
            bound interpreter.  Note that the byte code compilation is cached
            so that subsequent invocations of the script will not require
            recompilation unless other references force a different second
            representation on the object (e.g. fetching it as a list).
            The result of the script execution is returned as a new <classname>CTCLObject</classname>
            If script compilation failed, or script execution resulted in an error,
            a <classname>CTCLException</classname> will be thrown describing this.
        </para>
        <para>
            <programlisting>

<type>CTCLObject</type> <function>getRange</function>(<type>int</type> <parameter>first</parameter>,
                   <type>int</type> <parameter>last</parameter>);
            </programlisting>
        </para>
        <para>
            Returns a new object that consists of a subrange of the string representation of
            the original object. <parameter>first</parameter> is the index of the first
            character of the substring returned. <parameter>last</parameter> is the
            index of the last character of the substring. See <function>Tcl_GetRange</function>
            for more information, note however that some values of <parameter>first</parameter>
            or <parameter>last</parameter> will be treated specially, and that the
            underlying string representation operated on is a <firstterm>Unicode</firstterm> string
            for which some characters in some languages may require more than one byte.
        </para>
        <para>
            <programlisting>
<type>CTCLObject</type>&amp;  <function>concat</function>(<type>CTCLObject</type>&amp; <parameter>rhs</parameter>); // Concat lists.
            </programlisting>
        </para>
        <para>
            Concatenates the <parameter>rhs</parameter> as a list element to the object.
            A refrence to the new object is returned.  Copy on write semantics are maintained.
        </para>
        <para>
            <programlisting>
<type>std::vector&lt;CTCLObject&gt;</type>  <function>getListElements</function>();
            </programlisting>
        </para>
        <para>
            Converts the object into its underlying list representation.  The
            elements of the list are loaded into a vector of <classname>CTCLObject</classname>
            objects and returned.  If the underlying string representation does not have
            a valid list representation, (e.g. "{this cannot be converted") a
            <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
CTCLObject&amp;  setList(std::vector&lt;CTCLObject&gt; elements);
            </programlisting>
        </para>
        <para>
            Loads the object with a string and list representation whose words are
            the appropriately quoted string representation of <parameter>elements</parameter>.
            A reference to the new object is returned.  Copy on write semantics are
            maintained.
        </para>
        <para>
            <programlisting>
<type>int</type> <function>llength()</function>;
            </programlisting>
        </para>
        <para>
            If necessary, converts the object to its list representation and returns the
            number of elements in that list.  If it is not possible to convert the
            string represenation of the object into a valid list, a <classname>CTCLException</classname>
            is thrown.
        </para>
        <para>
            <programlisting>
<type>CTCLObject</type> <function>lindex</function>(<type>int</type> <parameter>index</parameter>);
            </programlisting>
        </para>
        <para>
            If necessary, creates the list representation of the object and returns a
            new object that is element number <parameter>index</parameter> of that list.
            If the object cannot be converted into a list, a <classname>CTCLException</classname>
            is thrown.
        </para>
        <para>
            <programlisting>
<type>CTCLObject</type>&amp; <function>lreplace</function>(<type>int</type> <parameter>first</parameter>,
                    <type>int</type> <parameter>count</parameter>,
                    <type>std::vector&lt;CTCLObject&gt;</type> <parameter>newElements</parameter>);
            </programlisting>
        </para>
        <para>
            If necessary, converts the object to its list representation.  If that conversion
            fails a <classname>CTCLException</classname> is thrown.  The set of elements
            specified by <parameter>first</parameter> and <parameter>count</parameter>,
            are replaced by the words held in the vector <parameter>newElements</parameter>.
            <parameter>newElements</parameter> can, of course, be an empty vector in order
            to remove <parameter>count</parameter> elements starting at <parameter>first</parameter>
            from the list.  A reference to the resulting object is returned.
            Copy on write semantics are enforced.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLException(3),
CTCLInterpreter(3),
CTCLInterpreterObject(3),
Tcl_DecrRefCount(3tcl),
Tcl_DuplicateObj(3tcl),
Tcl_GetRange(3tcl),
Tcl_IncrRefCount(3tcl),
Tcl_NewObj(3tcl),
Tcl_SetStringObj(3tcl)

        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLObjectProcessor">
    <refmeta>
        <refentrytitle>CTCLObjectProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLObjectProcessor</refname>
        <refpurpose>
            Abstract base class to encapsulate the Tcl object command interface exposed by
            <function>Tcl_CreateObjCommand</function>.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLObjectProcessor.h&gt;
...
class CTCLObjectProcessor : public CTCLInterpreterObject
{
public:
  CTCLObjectProcessor(CTCLInterpreter&amp; interp,
                      std::string      name,
                      bool             registerMe=true);
  virtual ~CTCLObjectProcessor();

  void Register();              // Register command on the interpreter.
  void unregister();            // Unregister command from the interp.
  std::string getName() const;  // Return the name of the object.
  Tcl_CmdInfo getInfo() const;  // Return info about the command.

  virtual int operator()(CTCLInterpreter&amp; interp,
                         std::vector&lt;CTCLObject&gt;&amp; objv) = 0;
  virtual void onUnregister();

};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl supports the addition of commands to the interpreter.  <classname>CTCLObjectProcessor</classname>
            supports an object oriented encapsulation of this part of the API.
            To add a command to an interpreter, write a subclass of
            <classname>CTCLObjectProcessor</classname>.  This subclass should override
            <function>operator()</function>, and optionally <function>onUnregister</function>.
            to implement the desired behavior for the new command.
        </para>
        <para>
            Create an instance of this new class and invoke its
            <function>Register</function>
            member to add it to the interpreter onto which it is bound.  Whenever a
            script executes the new command that object's
            <function>operator()</function> is invoked to process the command.
            If the interpreter is destroyed, or if the command is ever unregistered,
            the <function>onUnregister</function> function is called to perform any
            required global cleanup.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLObjectProcessor</function>(<type>CTCLInterpreter</type>&amp; <parameter>interp</parameter>,
                    <type>std::string</type>      <parameter>name</parameter>,
                    <type>bool</type>             <parameter>registerMe</parameter>=<literal>true</literal>);

        </programlisting>
        </para>
        <para>
            Constructs a new command processor.  <parameter>interp</parameter> is the
            interpreter on which the command will be registered when the
            <function>Register</function> member is invoked.
            <parameter>name</parameter> is the name of the command.
            If <parameter>registerMe</parameter> is not supplied or is supplied but is
            <literal>true</literal>, the command will be registered as part of the construction process.
            If <parameter>registerMe</parameter> is supplied and is <literal>false</literal>,
            the command is not immediately added, and <function>Register</function> must
            be called later to incorporate it into the interpreter.
        </para>
        <para>
        <programlisting>
<type>void</type> <function>Register</function>();
<type>void</type> <function>unregister</function>();
        </programlisting>
        </para>
        <para>
            <function>Register</function> incorporates the command into the
            interpreter.  If the command is already registered, a
            <classname>CStateException</classname> is thrown.
        </para>
        <para>
            <function>unRegister</function> removes the command from the interpreter.
            This causes <function>onUnregister</function> to be called.
            if the command is registered at destruction time, destruction implies a call
            to <function>unRegister</function> (and therefore <function>onUnregister</function>).
        </para>
        <para>
        <programlisting>
<type>std::string</type> <function>getName</function>() const;
<type>Tcl_CmdInfo</type> <function>getInfo</function>() const;
        </programlisting>
        </para>
        <para>
            <function>getName</function> returns the name of the command
            that will invoke this object's <function>operator()</function>.
            If the command has been registered, and subsequently renamed at the
            script level, this function will reflect the rename.
        </para>
        <para>
            <function>getInfo</function> returns information about the command
            see <function>Tcl_GetCommandInfo</function> for more information about
            what is returned and what it means.
        </para>
        <para>
        <programlisting>
virtual <type>int</type> <function>operator()</function>(<type>CTCLInterpreter</type>&amp; <parameter>interp</parameter>,
                       <type>std::vector&lt;CTCLObject&gt;</type>&amp; <parameter>objv</parameter>) = 0;
        </programlisting>
        </para>
        <para>
            This pure virtual function must be overridden in concrete object command processors.
            The function is called to execute the command that this object is performing.
            <parameter>interp</parameter> provides a reference to the interpreter on which
            the command is being run. <parameter>objv</parameter> is a reference to a
            <type>std::vector&lt;CTCLObject&gt;</type>.
            Each element of <parameter>objv</parameter> is a <classname>CTCLObject</classname>
            containing a word of the command line that invoked us.
        </para>
        <para>
            The function should return <literal>TCL_OK</literal> on success and
            <literal>TCL_ERROR</literal> on failure.  Other return values are possible
            for e.g. commands that implement new control structures however this is beyond
            the scope of this manpage.  If the command processor wants to make a result
            available to the interpreter, it can create a <classname>CTCLResult</classname>
            object, fill it in and commit it.
        </para>
        <para>
        <programlisting>
virtual void onUnregister();
        </programlisting>
        </para>
        <para>
            This function is called when the interpreter is being destroyed or if the
            command is being unregistered either due to object destruction or a call to
            <function>unregister</function>.  The default behavior is to do nothing, but
            this can be overidden in your derived class if desired.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLCompatibilityProcessor(3),
CTCLInterpreter(3),
CTCLInterpreterObject(3),
CTCLObject(3),
CTCLProcessor(3),
CTCLResult(3),
Tcl_CreateObjCommand(3tcl),
Tcl_GetCommandInfo(3tcl)
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLVariable">
    <refmeta>
        <refentrytitle>CTCLVariable</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLVariable</refname>
        <refpurpose>
            Encapsulate Tcl interpreter variables.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLVariable.h&gt;

class CTCLVariable  : public CTCLInterpreterObject
{
public:
  CTCLVariable (std::string am_sVariable,  Bool_t am_fTracing  );
  CTCLVariable (CTCLInterpreter* pInterp,
                std::string am_sVariable,  Bool_t am_fTracing  );
  CTCLVariable (const CTCLVariable&amp; aCTCLVariable );

  CTCLVariable&amp; operator= (const CTCLVariable&amp; aCTCLVariable);
  int operator== (const CTCLVariable&amp; aCTCLVariable) const;

  std::string getVariableName() const;
  Bool_t IsTracing() const;

  void setVariableName (const std::string am_sVariable);
  virtual   char*  operator() (char* pName,
                               char* pSubscript,
                               int Flags)  ;

   static  char* TraceRelay (ClientData pObject, Tcl_Interp* pInterpreter,
                             tclConstCharPtr  pName,
                             tclConstCharPtr pIndex,
                             int flags)  ;

  const char* Set (const char* pValue, int flags=TCL_LEAVE_ERR_MSG |
                                                 TCL_GLOBAL_ONLY)  ;
  const char* Set (const char* pSubscript, char* pValue,
                   int flags=TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY)  ;
  const char* Get (int flags=TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY,
                   char* pIndex=0)  ;
  int Link (void* pVariable, int Type)  ;
  void Unlink ()  ;
  int Trace (int flags=TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS,
             char* pIndex = (char*)kpNULL)  ;

  void UnTrace ()  ;

};
</programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLVariable</classname> allows an existing or new Tcl interpreter
            variable to be encapsulated so that it can be accessed, traced or linked
            in C++ code.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <programlisting>
  <function>CTCLVariable</function>(<type>std::string</type> <parameter>sName</parameter>,
             <type>Bool_t</type> <parameter>fTracing</parameter>  );
  <function>CTCLVariable</function> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
             <type>std::string</type> <parameter>sName</parameter>,
             <type>Bool_t</type> <parameter>fTracing</parameter>  );
  <function>CTCLVariable</function> (<type>const CTCLVariable</type>&amp; <parameter>aCTCLVariable</parameter> );
            </programlisting>
        </para>
        <para>
            In the first two cases, <parameter>sName</parameter> is the name of the variable
            that will be wrapped by this object.  The variable name can contain namespace
            qualifications as well as indices.  If <parameter>fTracing</parameter> is true,
            the object is set to record that it is tracing the variable.  Normally
            this parameter should be allowed to default to <literal>kfFALSE</literal>,
            and the trace member functions used to set explicit traces.
            For the final form of the constructor (copy constructor),
            <parameter>aCTCLVariable</parameter> is a <classname>CTCLVariable</classname> that
            will be copied into this object.
        </para>
        <para>
            In the first form of the constructor, one must later call the
            <function>Bind</function> function (see CTCLInterpreterObject), to bind
            the variable to a specific interpreter prior to accessing it.
        </para>
        <para>
            <programlisting>
  <type>CTCLVariable</type>&amp; <function>operator=</function>(<type>const CTCLVariable</type>&amp; <parameter>rhs</parameter>);
            </programlisting>
        </para>
        <para>
            Assigns the <parameter>rhs</parameter> object to this one.  A reference to the
            left hand side of the assignment is returned.  The semantics of assignment are
            not that the variable values are assigned, but that the left side of the
            assignment becomes a functional equivalent of <parameter>rhs</parameter>,
            that is it stands for the same object and has the same traces (if any) set.
            Thus, if <parameter>rhs</parameter> wraps the interpreter variable <varname>a</varname>
            and the object on the left side wraps interpreter variable <varname>b</varname>
            after the assignment executes, the left side object will be wrapping
            <varname>a</varname>.
            A reference to the object on the left hand side of the assignment is returned.
        </para>
        <para>
            <programlisting>
  <type>int</type> <function>operator==</function>(<type>const CTCLVariable</type>&amp; <parameter>rhs</parameter>) const;
            </programlisting>
        </para>
        <para>
            Compares this object for functional equality with <parameter>rhs</parameter>.
            Functional equality is defined as the two objects referring to the same
            variable, in the same interpreter, and having traces set on the same
            operations.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>getVariableName</function>() const;
            </programlisting>
        </para>
        <para>
            Returns the name of the Tcl variable that is wrapped by this object.
        </para>
        <para>
            <programlisting>
<type>int</type> <function>Trace</function>(<type>int</type> <parameter>flags</parameter>=<literal>TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS</literal>,
          <type>char</type>* <parameter>pIndex</parameter> = (<type>char</type>*)<literal>kpNULL</literal>)  ;
<type>void</type> <function>UnTrace</function> ()  ;
<type>Bool_t</type> <function>IsTracing</function>() const;
virtual <type>char</type>*  <function>operator()</function> (<type>char</type>* <parameter>pName</parameter>,
                        <type>char</type>* <parameter>pSubscript</parameter>,
                        <type>int</type> <parameter>Flags</parameter>)  ;
            </programlisting>
        </para>
        <para>
            This set of functions supports variable tracing.  In Tcl, a trace is a function
            that is called when some event of interest occurs on a varialbe.  The possible
            events are read, write, and unset.  To effectively use variable tracing, you
            must create a subclass of <classname>CTCLVariable</classname>, override its
            <function>operator()</function> member to handle the trace and call
            <function>Trace</function> to initiate tracing.
        </para>
        <para>
            The <function>Trace</function> member initiates tracing on the variable.
            <parameter>flags</parameter> describes when the trace should fire.
            See the manpage for <function>Tcl_TraceVar</function> for information about
            the legal flag values.
        </para>
        <para>
            <function>Untrace</function> cancels all traces on the variable represented by
            this object.
        </para>
        <para>
            <function>IsTracing</function> returns <literal>kfTRUE</literal> if tracing
            is being performed on the variable.
        </para>
        <para>
            When a trace fires, the <function>operator()</function> member will be called.
            This is why you must override the <classname>CTCLVariable</classname> base
            class to do anything useful with a trace.  The parameters to the
            call are; <parameter>pName</parameter> is the name of the variable that
            has been traced. <parameter>pSubscript</parameter> is the array subscript in the
            event the trace fires on an array or element of an array, and is
            <literal>NULL</literal> otherwise.  <parameter>Flag</parameter> describes
            why the trace fired.  Again, see the <function>Tcl_TraceVar</function>
            manpage for more information.
            Note that for write traces, the variable has already been set.  Modifying
            the value of the traced variable within a trace function will not fire any
            additional traces.
            The <function>operator()</function> function must return a <literal>NULL</literal>
            pointer if the trace is successful.  It must return a pointer to an error message
            if the trace is not successful.  An example of an unsuccessful trace might be
            a write trace that ensures that only particular values are assigned to the
            variable.
        </para>
        <para>
            <programlisting>
const <type>char</type>* <function>Set</function>(const <type>char</type>* <parameter>pValue</parameter>,
                <type>int</type> <parameter>flags</parameter>=<literal>TCL_LEAVE_ERR_MSG</literal> |
                          <literal>TCL_GLOBAL_ONLY</literal>)  ;
const <type>char</type>* <function>Set</function>(const <type>char</type>* <parameter>pSubscript</parameter>,
               <type>char</type>* <parameter>pValue</parameter>,
               <type>int</type> <parameter>flags</parameter>=<literal>TCL_LEAVE_ERR_MSG</literal> | <literal>TCL_GLOBAL_ONLY</literal>)  ;
            </programlisting>
        </para>
        <para>
            Sets the value of the variable to the string pointed to by <parameter>pValue</parameter>
            The second form of this assumes that the <classname>CTCLVariable</classname>
            represents an array and the <parameter>pSubscript</parameter> parameter
            specifies the subscript of the array that is being set.  The <parameter>flags</parameter>
            parameter is fully documented in the Tcl manpage for Tcl_SetVar
        </para>
        <para>
            <programlisting>
const <type>char</type>* <function>Get</function>(<type>int</type> <parameter>flags</parameter>=<literal>TCL_LEAVE_ERR_MSG</literal> | <literal>TCL_GLOBAL_ONLY</literal>,
              <type>char</type>* <parameter>pIndex</parameter>=<literal>0</literal>)  ;
            </programlisting>
        </para>
        <para>
            Retrieves the current value of a variable.  If the <parameter>pIndex</parameter>
            parameter is supplied, the variable wrapped by <classname>CTCLVariable</classname>
            is assumed to be an array and <parameter>pIndex</parameter> points to the subscript of the
            element to retrieve.  The <parameter>flags</parameter> parameter is fully
            documented in the Tcl_GetVar manpage.  The return value of the function is
            a null terminated character string that is the current value of the variable.
            If the variable does not exist, then a <literal>NULL</literal> is returned.
        </para>
        <para>
            <programlisting>
<type>int</type> <function>Link</function>(<type>void</type>* <parameter>pVariable</parameter>,
         <type>int</type> <parameter>Type</parameter>)  ;
<type>void</type> <function>Unlink</function>()  ;
            </programlisting>
        </para>
        <para>
            <function>Link</function> and <function>Unlink</function> support variable
            linking.  Variable linking is when a Tcl variable is made to track the value
            of a C/C++ variable or C++ member variable of an object.
            <function>Link</function> establishes the link.  <parameter>pVariable</parameter>
            points to the C or C++ variable or member variable to link to this
            <classname>CTCLVariable</classname>.  The <parameter>Type</parameter>
            parameter is one of following values:
            <literal>TCL_LINK_INT</literal>,
            <literal>TCL_LINK_DOUBLE</literal>,
            <literal>TCL_LINK_BOOLEAN</literal>,
            <literal>TCL_LINK_WIDE_INT</literal>, or
            <literal>TCL_LINK_STRING</literal> indicating the type of the variable
            to which <parameter>pVariable</parameter> points.  For all but
            <literal>TCL_LINK_STRING</literal>, <parameter>pVariable</parameter> points
            to a variable of the type indicated, and that variable will be linked.
            for <literal>TCL_LINK_STRING</literal>, <parameter>pVariable</parameter> points
            to a <type>char*</type> which should be initialized to point to <literal>NULL</literal>.
            The Tcl interpreter will use <function>Tcl_Alloc</function> and <function>Tcl_Free</function>
            to maintain a dynamically allocated string pointed to by that pointer which
            reflects the value of the variable.  If the C/C++ program modifies this string,
            it must <function>Tcl_Free</function> the prior value and <function>Tcl_Alloc</function>
            a new value with the new variable value.
        </para>
    </refsect1>
    <refsect1>
        <title>DEFECTS</title>
        <para>
            No <function>operator!=</function> has been defined.
        </para>
        <para>
            There is no protection against multiple links... the most recent link
            for an underlying Tcl variable is the one effective.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLInterpreter(3), CTCLInterpreterObject(3),
        Tcl_GetVar(3tcl), Tcl_LinkVar(3tcl), Tcl_SetVar(3tcl), Tcl_TraceVar(3tcl)
        </para>
    </refsect1>
</refentry>
<refentry id="manpage.CTCLProcessor">
    <refmeta>
        <refentrytitle>CTCLProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLProcessor</refname>
        <refpurpose>
            Provide <parameter>argc</parameter>, <parameter>argv</parameter>
            extension commands to Tcl.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLProcessor.h&gt;
...
class CTCLProcessor : public CTCLInterpreterObject
{
public:
  CTCLProcessor(const std::string sCommand, CTCLInterpreter* pInterp);
  CTCLProcessor(const char*       pCommand, CTCLInterpreter* pInterp);
  virtual ~CTCLProcessor();

  std::string getCommandName() const;

  virtual int operator()(CTCLInterpreter&amp; rInterpreter,
                         CTCLResult&amp;      rResult,
                         int argc, char** argv) = 0;
  virtual void OnDelete();

  void Register();
  void Unregister();

  static  std::string ConcatenateParameters (int nArguments,
                                              char* pArguments[])  ;
  int ParseInt (const char* pString, int* pInteger)  ;
  int ParseInt (const std::string&amp; rString, int* pInteger)

  int ParseDouble (const char* pString, double* pDouble)  ;
  int ParseDouble (const std::string&amp; rString, double* pDouble)

  int ParseBoolean (const char* pString, Bool_t* pBoolean)  ;
  int ParseBoolean (const std::string&amp; rString, Bool_t* pBoolean)

  static int MatchKeyword(std::vector&lt;std::string&gt;&amp; MatchTable,
                          const std::string&amp; rValue,
                          int NoMatch = -1);


};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <parameter>Do not use this for new commands</parameter>
        </para>
        <para>
            The <classname>CTCLProcessor</classname> provides a compatibility
            interface to the old Tcl style <parameter>argc</parameter>,
            <parameter>argv</parameter> style of command extension.
            New commands should be written using the
            <classname>CTCLObjectProcessor</classname> class instead.
        </para>
        <para>
            To extend the interpreter using this mechanism, you must
            derive a class from <classname>CTCLProcessor</classname> and
            minimally override and implement its
            <function>operator()</function> pure virtual function.  You may optionally
            overrid its <function>OnDelete</function> member as well.
            Having written the class, you must create an object of that class and
            register it on an interpreter.  Once the class is registered,
            invocations of the command under which it was registered will
            invoke your <function>operator()</function>.
        </para>
        <para>
            If the interpreter is destroyed or the object destroyed, or unregistered,
            the <function>OnDelete</function> member will be called.
            <classname>CTCLProcessor</classname> defines and implements this function
            with an empty body, so it is only necessary for you to override and implement
            this if you have some cleanup actions that must be done when the command is
            deleted.
        </para>
        <para>
            This class is now implemented in terms of a <classname>CTCLObjectProcessor</classname>
            derived class called a <classname>CTCLCompatibilityProcessor</classname>. It is
            less efficient to use this class than to use a class derived directly from a
            <classname>CTCLObjectProcessor</classname>.  This class is therefore not
            recommended for use with new extensions, but is only provided for
            compatibility with existing extensions written before
            <classname>CTCLObjectProcessor</classname> was developed.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLProcessor</function>(const <type>std::string</type> <command>sCommand</command>,
             <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
<function>CTCLProcessor</function>(const <type>char</type>*       <parameter>pCommand</parameter>,
             <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
        </programlisting>
        </para>
        <para>
            Constructs a <classname>CTCLProcessor</classname>.  <parameter>sCommand</parameter>
            or <parameter>pCommand</parameter> are the initial name of the command.
            Note that the Tcl interpreter supports command renaming at the script level,
            so there is no gaurentee that this will always be the name of the command.
            <parameter>pInterp</parameter> is the interpreter on which the command
            will be registered when the <function>Register</function> function is called.
        </para>
        <para>
        <programlisting>

<type>std::string</type> <function>getCommandName</function>() const;
        </programlisting>
        </para>
        <para>
            Returns the initial name of the command.  Unlike
            <classname>CTCLObjectCommand</classname>::<function>getName</function>()
            this function does not track changes in the command name.
        </para>
        <para>
        <programlisting>

virtual <type>int</type> <function>operator</function>()(<type>CTCLInterpreter</type>&amp; <parameter>rInterpreter</parameter>,
                       <type>CTCLResult</type>&amp; <parameter>rResult</parameter>,
                       <type>int</type> <parameter>argc</parameter>,
                       <type>char</type>** <parameter>argv</parameter>) = 0;
virtual <type>void</type> <function>OnDelete</function>();
        </programlisting>
        </para>
        <para>
            <function>operator()</function> is a pure virtual function and therefore must
            be overidden and implemented in concrete command implementations.
            <parameter>rInterpreter</parameter> is a reference to the interpreter that is
            executing this command. <parameter>rResult</parameter> is a reference to
            a <classname>CTCLResult</classname> object that represents the result of the
            interpreter.  Any text stored into this object will be made available to the
            interpreter as the result of the command. <parameter>argc</parameter>
            and <parameter>argv</parameter> are the number of words on the command line and
            a pointer to an array of pointers to the command words respectively.
        </para>
        <para>
            <function>operator()</function> should be written to return
            <literal>TCL_OK</literal>
            if it is successful and
            <literal>TCL_ERROR</literal>
            if it encounters an error.   Other return values are possible and meaningful
            for commands that implement flow of control structures, but documenting these
            is beyond the scope of this manpage.   See the return(3tcl) manpage for
            more information about these.
        </para>
        <para>
            <function>OnDelete</function> is called whenever the interpreter
            or the object is being
            destroyed, or the object's <function>Unregister</function> function has been
            called.  <classname>CTCLProcessor</classname> provides a default implementation
            for <function>OnDelete</function> which does nothing.  It is only necessary
            to override and implement this function if you require specific action when
            the command is being unregistered.
        </para>
        <para>
        <programlisting>
<type>void</type> <function>Register</function>();
<type>void</type> <function>Unregister</function>();
        </programlisting>
        </para>
        <para>
            These functions register and unregister the command with the intepreter
            respectively.
        </para>
        <para>
        <programlisting>
static  <type>std::string</type> <function>ConcatenateParameters</function>(<type>int</type> <parameter>nArguments</parameter>,
                                           <type>char</type>* <parameter>pArguments</parameter>[])  ;
        </programlisting>
        </para>
        <para>
            Concatenates all of the <parameter>nArguments</parameter>
            words in the <parameter>pArguments</parameter> array into a <type>std::string</type>
            and returns it.  The words are space separated.
        </para>
        <para>
        <programlisting>
<type>int</type> <function>ParseInt</function>(const <type>char</type>* <parameter>pString</parameter>,
             <type>int</type>* <parameter>pInteger</parameter>)  ;
<type>int</type> <function>ParseInt</function>(const <type>std::string</type>&amp; <parameter>rString</parameter>,
             <type>int</type>* <parameter>pInteger</parameter>)
        </programlisting>
        </para>
        <para>
            Parses the character string <parameter>pString</parameter> or <parameter>rString</parameter>
            as a 32 bit signed integer into <parameter>pInteger</parameter>.  Returns
            <literal>TCL_OK</literal>
            if successful, or
            <literal>TCL_ERROR</literal>
            if the string coult no be parsed.  In that case, the result string
            of the interpreter will report why the string could not be parsed.
        </para>
        <para>
        <programlisting>
<type>int</type> <parameter>ParseDouble</parameter>(const <type>char</type>* <parameter>pString</parameter>,
                <type>double</type>* <parameter>pDouble</parameter>)  ;
<type>int</type> <function>ParseDouble</function>(const <type>std::string</type>&amp; <parameter>rString</parameter>,
                <type>double</type>* <parameter>pDouble</parameter>)
        </programlisting>
        </para>
        <para>
            Parses the input string, either <parameter>pString</parameter> or
            <parameter>rString</parameter>
            as a double precision floating point value, storing the result in the
            double pointed to by <parameter>pDouble</parameter>.
            On success,
            <literal>TCL_OK</literal>
            is returned.  On failure,
            <literal>TCL_ERROR</literal> and the interpreter result is
            a textual reason for the failure.
        </para>
        <para>
        <programlisting>
<type>int</type> <function>ParseBoolean</function>(const <type>char</type>* <parameter>pString</parameter>,
                 <type>Bool_t</type>* <parameter>pBoolean</parameter>)  ;
<type>int</type> <function>ParseBoolean</function>(const <type>std::string</type>&amp; <parameter>rString</parameter>,
                 <type>Bool_t</type>* <function>pBoolean</function>)
        </programlisting>
        </para>
        <para>
            Parses either <parameter>pString</parameter>
            or <parameter>rString</parameter> as a boolean value.  The result
            is stored in boolean pointed to by <parameter>pBoolean</parameter>.
            <literal>TCL_OK</literal>
            is returned on success,
            <literal>TCL_ERROR</literal>
            on error.  If <literal>TCL_ERROR</literal> was returned, the interpreter
            result is the textual reason for the failure.
        </para>
        <para>
        <programlisting>
static <type>int</type> <function>MatchKeyword</function>(<type>std::vector&lt;std::string&gt;</type>&amp; <parameter>MatchTable</parameter>,
                        const <type>std::string</type>&amp; <parameter>rValue</parameter>,
                        <type>int</type> <parameter>NoMatch</parameter> = <literal>-1</literal>);
        </programlisting>
        </para>
        <para>
            Searches for the string <parameter>rValue</parameter> in the vector of strings
            <parameter>MatchTable</parameter>, and returns the index in the vector at which
            the match occured.  If no match could be found, the value
            <parameter>NoMatch</parameter> is returned.
        </para>
        <para>
            Within SpecTcl, this is often used to match command switches.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLCompatibilityProcessor(3),
CTCLObjectProcessor(3),
CTCLPackagedCommand(3),
CTCLResult(3),
return(3tcl)
        </para>
    </refsect1>
</refentry>



<refentry id="manpage.CTCLChannel">
    <refmeta>
        <refentrytitle>CTCLChannel</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLChannel</refname>
        <refpurpose>
            Provide a C++ abstraction wrapper for Tcl Channels.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLChannel.h&gt;
...
class CTCLChannel : public CTCLInterpreterObject
{
public:

  CTCLChannel(CTCLInterpreter* pInterp,
              std::string      Filename,
              const char*      pMode,
              int              permissions);
  CTCLChannel(CTCLInterpreter* pInterp,
              int              argc,
              const char**           pargv,
              int              flags);
  CTCLChannel(CTCLInterpreter* pInterp,
              int              port,
              std::string      host)
  CTCLChannel(CTCLInterpreter* pInterp,
              int              port,
              Tcl_TcpAcceptProc* proc,
              ClientData       AppData);
  CTCLChannel(CTCLInterpreter* pInterp,
              Tcl_Channel      Channel);
  CTCLChannel(const CTCLChannel&amp; rhs);
  virtual ~CTCLChannel();

  Tcl_Channel getChannel() const;
  bool ClosesOnDestroy() const;

  int Read( void** pData, int nChars);
  int Write(const void* pData, int nBytes);

  bool atEof();
  void Flush();
  void Close();
  void Register();
  void SetEncoding(std::string Name);
  std::string GetEncoding();

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The Tcl API supplies an I/O abstraction layer on top of the
            operating systems I/O subsystem.  This layer makes use of what Tcl documentation
            refers to a s <firstterm>channels</firstterm>. A channel represents a connection
            to an I/O endpoint (source or sink of data or both).  The <classname>CTCLChannel</classname>
            class allows you to wrap a C++ class around a Tcl channel.
        </para>
        <para>
            Using a <classname>CTCLChannel</classname>, rather than direct operating system
            I/O allows you to improve the portability of your program, as well as allowing
            I/O from the TCL scripting level to be cleanly mixed with I/O at the C/C++ level.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>std::string</type>      <parameter>Filename</parameter>,
              <type>const char</type>*      <parameter>pMode</parameter>,
              <type>int</type>              <parameter>permissions</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>int</type>              <parameter>argc</parameter>,
              <type>const char</type>**           <parameter>pargv</parameter>,
              <type>int</type>              <parameter>flags</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>  * <parameter>pInterp</parameter>,
              <type>int</type>              <parameter>port</parameter>,
              <type>std::string</type>      <parameter>host</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>int</type>              <parameter>port</parameter>,
              <type>Tcl_TcpAcceptProc</type>* <parameter>proc</parameter>,
              <type>ClientData</type>      <parameter>AppData</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>Tcl_Channel</type>      <parameter>Channel</parameter>);
  <function>CTCLChannel</function>(<type>const CTCLChannel</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These constructors wrap a <classname>CTCLChannel</classname>
            object around a Tcl channel.  The variety of constructors reflects the
            variety of endpoints around which a <type>Tcl_Channel</type> can be
            wrapped.
        </para>
        <para>
            The first of the constructors attaches the object to a file via
            <function>Tcl_OpenFileChannel</function>.  <parameter>pInterp</parameter>
            is the channel the file is associated.  <parameter>Filename</parameter>
            is the name of the file the channel is connected to. <parameter>pMode</parameter>
            is the connection mode which can be any of of the mode values for the
            Tcl <command>open</command> scripting command.   <parameter>permissions</parameter>
            represents the permissions mask fo rthe file in POSIX format.  See
            open(2) for information about the possible mode bit values.
        </para>
        <para>
            The second form of the constructor connects a channel that is a pipe to a
            program.  The program and its command line arguments are specified
            via the <parameter>argc</parameter> and <parameter>pargv</parameter>
            parameters. The <parameter>flags</parameter> parameter specifies
            how the stdio channels of the program are or are not disposed into the
            channel.   Valid bits are:
            <literal>TCL_STDIN</literal>,
            <literal>TCL_STDOUT</literal>,
            <literal>TCL_STDERR</literal>,
            <literal>TCL_ENFORCE_MODE</literal>.  See the <function>Tcl_OpenCommandChannel</function>
            manpage for information about the meaning of these bits.
        </para>
        <para>
            The third form of the constructor constructs a channel that connects to a
            TCP/IP server, via <function>Tcl_OpenTcpClient</function>.  The
            <parameter>port</parameter> parameter specifies the port number on which the
            server is listening, while <parameter>host</parameter> is the name of the
            host to which the connection should be formed.  The host name can either be a
            DNS resolvable host name or the textual encoding of the TCP/IP address of the
            host (e.g. string("spdaq22.nscl.msu.edu") or string("35.9.56.56").
            This function will block until the connection is accepted by the server.
        </para>
        <para>
            The fourth form of the constructor creates a channel that is a Tcp/IP server.
            <parameter>port</parameter> is the port number on which the server listens
            for connections.
            <parameter>proc</parameter> is a function that will be called when a
            connection has been accepted by the Tcl event loop.
            <parameter>AppData</parameter> is application data that is passed, without
            interpretation to <parameter>proc</parameter>.  See the <function>Tcl_OpenTcpServer</function>
            manpage for more information about how the <parameter>proc</parameter> is
            called.
        </para>
        <para>
            The fifth form of the constructor creates a <classname>CTCLChannel</classname>
            object by wrapping an existing <type>Tcl_Channel</type>; <parameter>Channel</parameter>
            which has been obtained
            directly from the Tcl application programming interface.
        </para>
        <para>
            The final form of the constructor copies an existing <classname>CTCLChannel</classname>
            object so that the two objects refer to the same channel.  The object is created
            so that it will not close the channel on destruction.  Note however that the
            source channel may, depending on how it was constructed.  It is up to the
            application programmer to ensure that channels are closed at appropriate times.
        </para>
        <para>
        <programlisting>
  <type>Tcl_Channel</type> <function>getChannel</function>() const;
        </programlisting>
        </para>
        <para>
            Returns the underlying <type>Tcl_Channel</type> this object is
            wrapped around.  Once this is obtained, it can be usd in any
            Tcl API call that requires a channel.
        </para>
        <para>
        <programlisting>
  <type>bool</type> <function>ClosesOnDestroy</function>() const;
        </programlisting>
        </para>
        <para>
            When a <classname>CTCLChannel</classname> is copy constructed into
            being it is flagged such that destruction will not close the underlying channel.
            the return value from this function is <literal>true</literal> if the
            object will close the underlying channel on destruction and <literal>false</literal>
            if the object will not close the underlying channel on destruction.
        </para>
        <para>
        <programlisting>
  <type>int</type> <function>Read</function>( <type>void</type>** <parameter>pData</parameter>,
           <type>int</type> <parameter>nChars</parameter>);
  <type>int</type> <function>Write</function>(<type>const void</type>* <parameter>pData</parameter>,
           <type>int</type> <parameter>nBytes</parameter>);
        </programlisting>
        </para>
        <para>
            <function>Read</function> transfers data from the channel to the users's buffer;
            <parameter>pData</parameter>.  <parameter>nChars</parameter> is the number
            of characters of data that will be transferred.
            <function>Write</function> transfers <parameter>nBytes</parameter>
            <firstterm>bytes</firstterm> data to the chnnel from <parameter>pData</parameter>.
            Both function return the number of characters actually transferred.
            An important note about the <parameter>nChars</parameter> parameter:  If the
            channel is not opened as a binary channel, this parameter is the number of
            UTF-8 characters transferred.  Depending on the characters actually transmitted,
            this may  not be the same as the number of bytes transmitted.
            The return value is the number of units (bytes or characters) actually transferred.
        </para>
        <para>
        <programlisting>

  <type>bool</type> <function>atEof</function>();
        </programlisting>
        </para>
        <para>
            Returns <literal>true</literal> if the underlying channel is at the end of file.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Flush</function>();
        </programlisting>
        </para>
        <para>
            Tcl channels are internally buffered. The <function>Flush</function> member
            flushes internal output buffers to the underlying I/O endpoint.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Close</function>();
        </programlisting>
        </para>
        <para>
            Closes the underlying channel. Note that this is normally done on
            destruction unless the channel object was created via copy construction.
            If the channel was registered to be visible to the interpreter, it is
            unregistered as well.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Register</function>();
        </programlisting>
        </para>
        <para>
            Makes the channel visible to the interpreter.  This allows the user
            to return the channel name to the script level at which point it can be
            used in Tcl script commands that operate on channels.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>SetEncoding</function>(<type>std::string</type> <parameter>Name</parameter>);
  <type>std::string</type> <function>GetEncoding</function>();
        </programlisting>
        </para>
        <para>
            These functions allow the user to get and set the encoding for the channel.
            See the <command>fconfigure</command> Tcl man page for more information about this.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
close(3tcl),
fconfigure(3tcl),
open(2),
Tcl_OpenCommandChannel(3tcl),
Tcl_OpenFileChannel(3tcl),
Tcl_OpenTcpClient(3tcl),
Tcl_OpenTcpServer(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLCommandPacakge">
    <refmeta>
        <refentrytitle>CTCLCommandPackage</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLCommandPackage</refname>
        <refpurpose>
            Group several related Tcl command extensions and common services they
            may require together.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLCommandPackage.h&gt;
...
typedef std::list &lt;CTCLProcessor*&gt;   CommandList;
typedef CommandList::iterator  CommandListIterator;

class CTCLCommandPackage  : public CTCLInterpreterObject
{

public:
  CTCLCommandPackage (CTCLInterpreter* pInterp,
                      const std::string&amp; rSignon=std::string("Unnamed pkg"));
  CTCLCommandPackage(CTCLInterpreter* pInterp,
                     const char* pSignon = "Unnamed pkg");
  virtual ~ CTCLCommandPackage ( );
  CTCLCommandPackage (const CTCLCommandPackage&amp; aCTCLCommandPackage );
  CTCLCommandPackage&amp; operator= (const CTCLCommandPackage&amp; aCTCLCommandPackage);
  int operator== (const CTCLCommandPackage&amp; aCTCLCommandPackage);

  std::string getSignon() const;
  CommandList getCommandList() const;
protected:
  void setSignon (std::string am_sSignon);

public:
  void Register ()  ;
  void Unregister ()  ;
  void AddProcessor (CTCLProcessor* pProcessor);
  void AddProcessors(CommandList&amp; rList);
  CommandListIterator begin ();
  CommandListIterator end ();
};
    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Extensions to Tcl often come in a set of related commands.  These commands
            may require access to a common set of services.  The <classname>CTCLCommandPackage</classname>
            along with the <classname>CTCLPackagedCommand</classname> provide a pair of base
            classes that facilitate the construction of such commands.
        </para>
        <para>
            The pattern to follow to derive class from <classname>CTCLCommandPackage</classname>
            This class defines and implements common services for the related commands.
            The constructor of the derived class will also create instances of
            classes derived from <classname>CTCLPackagedCommand</classname>.  These objects
            define and implement the related commands.  These command processors will be
            added to the package via <function>AddProcessor</function>, and
            <function>AddProcessors</function>.
        </para>
        <para>
            When the <classname>CTCLCommandPackage</classname>::<function>Register</function>
            function is called, all of the commands added to the package will be
            registered as well.  When a command processor is invoked, it can call its
            <function>getMyPackage</function> member function to obtain a pointer to the
            owning package and therefore access to the services this package provides.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLCommandPackage</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                      <type>const std::string</type>&amp; <parameter>rSignon</parameter>=<type>std::string</type>(<literal>"Unnamed pkg"</literal>));
  <function>CTCLCommandPackage</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                     <type>const char</type>* <parameter>pSignon</parameter> = <literal>"Unnamed pkg"</literal>);
  <function>CTCLCommandPackage</function> (<type>const CTCLCommandPackage</type>&amp; <parameter>aCTCLCommandPackage</parameter> );
        </programlisting>
        </para>
        <para>
            Constructs instances of the package.  <parameter>pInterp</parameter> is a pointer
            to the interpreter object on which these commands will be registered.
            <parameter>signon</parameter> is a text string that will be emitted to
            <literal>stderr</literal> when the package is asked to register its commands.
            This string is typically a credit or copyright notice for the package.  It can
            be empty if the user desires.
        </para>
        <para>
            The first and second form of the constructor only differ in how the signon message
            is passed.  The final form of the constructor is a copy constructor.  While
            copy construction is legal it is anticipated that this will not normally be used
            as command packages are usually <firstterm>singleton</firstterm> objects.
        </para>
        <para>
        <programlisting>
  <type>std::string</type> <function>getSignon</function>() const;
        </programlisting>
        </para>
        <para>
            Retrieves the signon string from the current object.
        </para>
        <para>
            <programlisting>
  <type>CommandList</type> <function>getCommandList</function>() const;
            </programlisting>
        </para>
        <para>
            Retrieves the list of commands that are managed by this package.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>setSignon</function> (<type>std::string</type> <parameter>am_sSignon</parameter>);
        </programlisting>
        </para>
        <para>
            Allows derived classes to set the signon string after construction is complete.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Register</function> ()  ;
  <type>void</type> <function>Unregister</function> ()  ;
        </programlisting>
        </para>
        <para>
            <function>Regsiter</function> registers all of the commands in the package
            with the package's interpreter.  <function>Unregister</function> unregisters
            these commands.  It is therefore not advisable to change the set of commands in
            the package between registration and unregistration.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>AddProcessor</function>(<type>CTCLProcessor</type>* <parameter>pProcessor</parameter>);
  <type>void</type> <function>AddProcessors</function>(<type>CommandList</type>&amp; <parameter>rList</parameter>);
        </programlisting>
        </para>
        <para>
            These functions add command processors to the package.  Any type of processor
            can be added to the package, however usually <classname>CTCLPackagedCommand</classname>
            derived objects are in order to provide a mechanism to access the package services.
            <parameter>pProcessor</parameter> is a pointer to a single processor while
            <parameter>rList</parameter> is a reference to a list of such processors.
        </para>
        <para>
        <programlisting>
  <type>CommandListIterator</type> <function>begin</function> ();
  <type>CommandListIterator</type> <function>end</function> ();
        </programlisting>
        </para>
        <para>
            Returns STL list iterators to the beginning and off the end of the
            set of command packages.
            List iterators behave roughly like pointers.  In this case, pointers
            to <classname>CTCLProcessor*</classname>.   Incrementing an interator
            'points' it to the next item in the list.  A full discussion of STL iterators
            is well beyond the scope of this man page.  See references below.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLProcessor(3), CTCLPackagedCommand(3)
        </para>
    </refsect1>
    <refsect1>
        <title>References</title>
        <para>
        <programlisting>
Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
        </programlisting>
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLCompatibilityProcessor">
    <refmeta>
        <refentrytitle>CTCLCompatibiltyProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLCompatibilityProcessor</refname>
        <refpurpose>
            Adaptor between <classname>CTCLOjbectProcessor</classname>
            and <classname>CTCLProcessor</classname>.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLCompatibilityProcessor.h&gt;
...
class CTCLCompatibilityProcessor : public CTCLObjectProcessor
{

public:

  CTCLCompatibilityProcessor(CTCLProcessor&amp; actualCommand);
  virtual ~CTCLCompatibilityProcessor();

  virtual int operator()(CTCLInterpreter&amp; interp,
                         std::vector&lt;CTCLObject&gt;&amp; objv);
  virtual void onUnregister();
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Note that the information on this page is only to be used to
            "grandfather" old <classname>CTCLProcessor</classname> objects
            into Tcl.  New command processors should be based on the
            CTCLObjectProcessor.
        </para>
        <para>
            A rewrite of the TCL++ library in March 2006 eliminated the use of
            Tcl functions that are scheduled to be deprecated in the known future
            of Tcl.    One set of functions scheduled for deprecation are those
            that revolve around direct access to the Tcl interpreter result, and
            command processors that use the <parameter>argc</parameter>,
            <parameter>argv</parameter> interfaces.
        </para>
        <para>
            Since a number of existing command extensions are, no doubt built on
            top of the <classname>CTCLProcessor</classname> <parameter>argc</parameter>
                                                            <parameter>argv</parameter>
            interface, a mechanism that allows the use of existing commands was built
            as well.
        </para>
        <para>
            The current implementation of a <classname>CTCLProcessor</classname> includes
            as member data a <classname>CTCLCompatibilityProcessor</classname> object.
            This object registers itself as a <classname>CTCLObjectProcessor</classname>
            for the command intended by the <classname>CTCLProcessor</classname> and
            serves as an adaptor between these two command types, marshalling command
            objects into an <parameter>argc</parameter>, <parameter>argv</parameter> pair,
            creating and committing a <classname>CTCLResult</classname> object.
        </para>
        <para>
            For most users of this library, this is completely transparent, this documentation
            is provided for completeness, however.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLCompatibilityProcessor</function>(<type>CTCLProcessor</type>&amp; <parameter>actualCommand</parameter>);
        </programlisting>
        </para>
        <para>
            Constructs a  compatibility processor that adapts the object based command
            interface for <parameter>actualCommand</parameter>.  <parameter>actualCommand</parameter>
            must already be bound to an interpreter.
        </para>
        <para>
        <programlisting>
virtual <type>int</type> <function>operator()</function>(<type>CTCLInterpreter</type>&amp; <parameter>interp</parameter>,
                       <type>std::vector&lt;CTCLObject&gt;</type>&amp; <parameter>objv</parameter>);
        </programlisting>
        </para>
        <para>
            Called when the command is executed.  <parameter>objv</parameter> is marshalled
            into an argc, argv pair.  A <classname>CTCLResult</classname> is created and the
            actual command's <function>operator()</function> is called to execute the command.
            On return, the result is committed, and all dynamic storage released prior to
            returning the status from the command processor.
        </para>
        <para>
        <programlisting>
virtual <type>void</type> <function>onUnregister</function>();
        </programlisting>
        </para>
        <para>
            Called when the command is unregistered.  The actual command's <function>OnDelete</function>
            member is called.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLObject(3),
CTCLObjectProcessor(3),
CTCLProcessor(3),
CTCLResult(3),
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Gamma, Helm, Johnson, Vlissides <parameter>Design Patterns Elements of Reusable
Object-Oriented Software</parameter>
Addison-Wesley Professional Computing Series 1995 ISBN 0-0201-63361-2
See Chapter 4 the Adapter pattern.
            </programlisting>
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLFileHandler">
    <refmeta>
        <refentrytitle>CTCLFileHandler</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLFileHandler</refname>
        <refpurpose>
            Base class for building object oriented Tcl File event handlers.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLFileHandler.h&gt;
...

class CTCLFileHandler  : public CTCLInterpreterObject
{
  CTCLFileHandler(CTCLInterpreter* pInterp,
                   UInt_t am_nFid = STDIN_FILENO);
  CTCLFileHandler(CTCLInterpreter* pInterp,
                  FILE* pFile);
  CTCLFileHandler (const CTCLFileHandler&amp; aCTCLFileHandler );
  ~CTCLFileHandler ( );
  CTCLFileHandler&amp; operator= (const CTCLFileHandler&amp; aCTCLFileHandler);
  int operator== (const CTCLFileHandler&amp; aCTCLFileHandler) const;

  UInt_t getFid() const;

  virtual   void operator() (int mask)   = 0;

  void Set (int mask)  ;
  void Clear ()  ;
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl supplies an event loop.  It is possible to add events specifications
            to this loop.  One very useful event type is based on readability or writability
            of a file descriptor.   The <classname>CTCLFileHandler</classname> allows you
            to create an object oriented file handler, and register it with the event
            loop so that you can gain control when, for example, a file becomes readable.
        </para>
        <para>
            As <classname>CTCLFileHandler</classname> is an abstract base class,
            it is necessary to create a derived class.  The derived class should
            implement the <function>operator()</function> which will be called
            when the specific event is fired.  An instance of this derived class should
            be created, and then the <function>Set</function> and <function>Clear</function>
            members used to establish and remove the event handler.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLFileHandler</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                   <type>UInt_t</type> <parameter>nFid</parameter> = <literal>STDIN_FILENO</literal>);
  <function>CTCLFileHandler</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                  <type>FILE</type>* <parameter>pFile</parameter>);
  <function>CTCLFileHandler</function> (const <type>CTCLFileHandler</type>&amp; <parameter>aCTCLFileHandler</parameter> );
        </programlisting>
        </para>
        <para>
            Constructs a file handler object.  <parameter>pInterp</parameter> is a
            pointer to the interpreter on which the file handler will be registered.
            The file can be specified either by <parameter>nFid</parameter>, a file
            descriptor, or <parameter>pFile</parameter> an stdio File stream pointer.
        </para>
        <para>
            A copy constructor allows the creation of a copy of the file handler object
            given <parameter>aCTCLFileHandler</parameter> an existing one.  This is normally
            not useful.
        </para>
        <para>
            <programlisting>
  <type>CTCLFileHandler</type>&amp; <function>operator=</function> (const <type>CTCLFileHandler</type>&amp; <parameter>aCTCLFileHandler</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLFileHandler</type>&amp; <parameter>aCTCLFileHandler</parameter>) const;
            </programlisting>
        </para>
        <para>
            These functions support assignment and equality comparison.  Note that these functions
            are usually not very useful for file handlers.
        </para>
        <para>
        <programlisting>
  <type>UInt_t</type> <function>getFid()</function> const;
        </programlisting>
        </para>
        <para>
            Returns the file id that is associated with the event.
        </para>
        <para>
            <programlisting>
  virtual   <type>void</type> <function>operator</function>() (<type>int</type> <parameter>mask</parameter>)   = 0;
            </programlisting>
        </para>
        <para>
            The user's derived class must override this to provide the desired
            funtionality when event fires.  <parameter>mask</parameter>
            indicates which event fired the function and can be an or of the following:
            <literal>TCL_READABLE</literal> if the file can be read without blocking,
            <literal>TCL_WRITABLE</literal> if the file can be written without blocking,
            or <literal>TCL_EXCEPTION</literal> if some exceptional condition occured on the
            file.
        </para>
        <para>
            <programlisting>
  <type>void</type> <function>Set</function> (<type>int</type> <parameter>mask</parameter>)  ;
  <type>void</type> <function>Clear</function> ()  ;
        </programlisting>
        </para>
        <para>
            <function>Set</function> establishes the event handler for the set of conditions
            described in <parameter>mask</parameter>.  The valid bits for <parameter>mask</parameter>,
            are described in the documentation for the <parameter>mask</parameter>
            parameter to <function>operator()</function>.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLObject(3),
CTCLInterpreter(3)
Tcl_CreateFileHandler(3tcl),
Tcl_DeleteFileHandler(3tcl)
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLHashTable">
    <refmeta>
        <refentrytitle>CTCLHashTable</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLHashTable</refname>
        <refpurpose>
            Object oriented interface to Tcl's hash table functions.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLHashTable.h&gt;

template &lt;class T&gt;
class CTCLHashTable
{
public:
  CTCLHashTable () ;
  CTCLHashTable (  Tcl_HashTable am_HashTable  );
  CTCLHashTable (const CTCLHashTable&amp; aCTCLHashTable );
  virtual ~CTCLHashTable ( );

  CTCLHashTable operator= (const CTCLHashTable&amp; aCTCLHashTable);

  int operator== (const CTCLHashTable&amp; aCTCLHashTable);

  Tcl_HashTable* getHashTable() const;

  void Enter (const std::string&amp; rKey, rCTCLTHashTableItem rValue);
  const CTCLTHashTableItem* Find (const std::string&amp; rsKeyword) const;
  CTCLTHashTableItem* Delete (const std::string&amp; rsKeyword);
  CTCLTHashTableIterator begin ();
  CTCLTHashTableIterator end ();
  std::string Statistics ();
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Hash tables are tables of keyword value pairs that are organized
            such that the lookup time for any key in the table is <firstterm>amortized
            constant</firstterm>.  Hash tables operate by running the key through a
            function called the <firstterm>hash function</firstterm>, and storing the
            key/value pair as an element of an array indexed by the result of that hash
            function (<firstterm>hash index</firstterm>).  Depending on the implementation of the hash table, different
            methods are used to resolve cases where two keys result in the same
            hash index.
        </para>
        <para>
            Tcl includes support libraries for hash tables with string keys and
            arbitrary value types (e.g. structures, pointers etc. etc.).  One example
            of the use of this sort of data structure is Tcl's storage of array variables.
            Each array is a hash table indexed by the hash index of the array subscripts.
            In this way Tcl supports subscripts that are arbitrary strings without
            any search overhead when referencing an element of the array.
        </para>
        <para>
            The <classname>CTCLHashTable</classname> and related classes provide an object oriented
            interface to the Tcl API for hash tables.  This class is a <firstterm>template class</firstterm>.
            The template parameter is the type of data that will be associated with each
            hash key.  For example, to create a has key of <classname>CSpectrum*</classname>
            (pointers to SpecTcl Spectra):
            <programlisting>
        CTCLHashTable&lt;CSpectrum*&gt; spectrumHashTable;
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLHashTable</function> () ;
  <function>CTCLHashTable</function> (  <type>Tcl_HashTable</type> <parameter>aHashTable</parameter>  );
  <function>CTCLHashTable</function> (const <type>CTCLHashTable</type>&amp; <parameter>aCTCLHashTable</parameter> );
        </programlisting>
        </para>
        <para>
            Three methods for creating <classname>CTCLHashTable</classname> objects
            are defined.   The first of these creates a new, empty hash table.
            The second, takes the handle to an existing hash table;
            <type>Tcl_HashTable</type> <parameter>aHashTable</parameter> and wraps
            a <classname>CTCLHashTable</classname> around this existing hash table
            providing an object oriented interface to that hash table.
            The final constructor, a copy constructor, creates a
            <classname>CTCLHashTable</classname> that refers to the same underlying
            <type>Tcl_HashTable</type> as the <parameter>aCTCLHashTable</parameter> parameter.
        </para>
        <para>
        <programlisting>
  <type>CTCLHashTable</type> <function>operator</function>= (const <type>CTCLHashTable</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLHashTable</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            <function>operator=</function>  assigns <parameter>rhs</parameter> to an existing
            object.  The semantics of assignment are that
            followingt assignment, <varname>*this</varname> and <parameter>rhs</parameter>
            will refer to the same underlying hash table.
        </para>
        <para>
            <function>operator==</function> compares two hash tables, <varname>*this</varname>
            and <parameter>rhs</parameter> for equality.  The semantics of equality are
            that the two <classname>CTCLHashTable</classname> objects refer to the same
            underlying Tcl hash tables.
        </para>
        <para>
        <programlisting>
  <type>Tcl_HashTable</type>* <function>getHashTable</function>() const;
        </programlisting>
        </para>
        <para>
            Gets the underlying <type>Tcl_HashTable</type> that is wrapped by
            a <classname>CTCLHashTable</classname> object.
        </para>
        <para>
            <programlisting>
<type>void</type> <function>Enter</function> (const <type>std::string</type>&amp; <parameter>rKey</parameter>,
            <type>CTCLTHashTableItem&lt;T&gt;</type> <parameter>rValue</parameter>);
            </programlisting>
            </para>
            <para>
            Adds an entry to a hash table.  <parameter>rKey</parameter> is the
            lookup key that will be associated with the entry.  <parameter>rValue</parameter>
            is the data that is associated with that key.  Note that <type>T</type>
            is the template type that was used to create the hashtable.  E.g. if the
            hash table is a <classname>CTCLHashTable&lt;float&gt;</classname>,
            <parameter>rValue</parameter> must be a <classname>CTCLHashTableItem&lt;float&gt;</classname>.
            Note that Tcl hash tables do not support duplicate keys.  If a hash table
            entry with the key <parameter>rKey</parameter> already is in the table it is
            replaced.
            </para>
            <para>
                <programlisting>
  const <type>CTCLTHashTableItem</type>* <function>Find</function> (const <type>std::string</type>&amp; <parameter>rsKeyword</parameter>) const;
                </programlisting>
            </para>
            <para>
                Looks up a hash table item by key.  If a hash table item with
                the key <parameter>rsKeyword</parameter> exists, a pointer to its
                entry is returned.   If <parameter>rsKeyword</parameter> has not
                yet been <function>Enter</function>ed in the hash table, a
                <literal>NULL</literal> pointer is returned.
            </para>
            <para>
                <programlisting>
  <type>CTCLTHashTableItem</type>* <function>Delete</function> (const <type>std::string</type>&amp; <parameter>rsKeyword</parameter>);
                </programlisting>
            </para>
            <para>
                Removes the hash table entry with the key <parameter>rsKeyword</parameter>.
                If the item existed, a pointer to it is returned.  If the item does not
                exist in the hash table a <literal>NULL</literal> pointer is returned.
            </para>
            <para>
                <programlisting>
  <type>CTCLTHashTableIterator</type> <function>begin</function> ();
  <type>CTCLTHashTableIterator</type> <function>end</function> ();
                </programlisting>
            </para>
            <para>
                <function>begin</function> returns an <firstterm>iterator</firstterm> that
                "points" to the first entry in the hash table.  dereferencing the
                iterator yields the pointer to a HashTableItem.  The iterator can be
                incremented via ++ so that it advances to the next item in the table.
            </para>
            <para>
                <function>end</function>returns an iterator that points past the end of the
                table and can be used to determine when iteration is complete.
            </para>
            <para>
                Iterators are pointer like objects.  See the STL reference below for more
                information about them.  The following example Takes a Hash table and
                counts up the number of elements it contains.
                <programlisting>
        CTCLHashTableIterator i = table.begin();    // Table a CTCLHashTable
        int                   n = 0;
        while (i != table.end()) {
            n++;
        }
        // N is a count of elements in the table.

            </programlisting>
            </para>
            <para>
                <programlisting>
  <type>std::string</type> <function>Statistics</function> ();
                </programlisting>
        </para>
        <para>
            Returns a string that contains statistics about the hash table.
            This is a wrapper for <function>Tcl_HashStats</function>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLHashTableItem(3),
CTCLHashTableIterator(3),
Tcl_HashStats(3tcl)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
        <programlisting>
Niklaus Wirth <parameter>Algorithms + Data Structures = Programs</parameter>
Prentice Hall Series in Automatic Computation 1976 See section 4.6

Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
        </programlisting>
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLHashTableItem">
    <refmeta>
        <refentrytitle>CTCLHashTableItem</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLHashTableItem</refname>
        <refpurpose>
            Encapsulation of an entry in a Tcl Hash table as encapsulated
            in <classname>CTCLHashTable</classname>
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;TCLHashTableItem.h&gt;
...

template &lt;class T&gt;              // T Must have copy ctor &amp; Assignment defined.
class CTCLHashTableItem
{
  CTCLHashTableItem (T am_Item );
  CTCLHashTableItem (const CTCLHashTableItem&amp; aCTCLHashTableItem );
  virtual ~CTCLHashTableItem ( );

  CTCLHashTableItem operator= (const CTCLHashTableItem&amp; aCTCLHashTableItem);
   int operator== (const CTCLHashTableItem&amp; aCTCLHashTableItem);
  T getItem() const;
  T* operator-&gt; ();
}
        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title></title>
        <para>
            Provides an object oriented interface to elements of a hash table.
            See CTCLHashTable(3), and the first REFERENCE below for more information
            about hash tables.
        </para>
        <para>
            Note that this is a templated class.  The template parameter is
            the type of the item to be stored in the hash table.  Suppose,
            for example, we have a bunch of named calibration parameters
            (floating point) that are stored in a hash table.  A calibration
            The following code creates the calibration table, and inserts an
            element named george in it with the initial value of 0.0:
            <programlisting>
        CTCLHashTable&lt;float&gt;  calibrationTable;
        CTCLHashTableItem&lt;float&gt; entry(0.0);
        calibrationTable.Enter(std::string("george"), entry);
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLHashTableItem</function> (<type>T</type> <parameter>Item</parameter> );
<function>CTCLHashTableItem</function> (const <type>CTCLHashTableItem</type>&amp; <parameter>hashItem</parameter> );
        </programlisting>
        </para>
        <para>
            Constructs a <classname>CTCLHashTableItem</classname> either from the underlying
            type (<parameter>Item</parameter>) or from an existing <classname>CTCLHashTableItem</classname>
            (<parameter>hashItem</parameter>).
        </para>
        <para>
        <programlisting>
<type>CTCLHashTableItem</type> <function>operator=</function>(const <type>CTCLHashTableItem</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <parameter>operator==</parameter> (const <type>CTCLHashTableItem</type>&amp; <type>rhs</type>);
        </programlisting>
        </para>
        <para>
            <function>operator=</function> allows you to assign the value of one
            <classname>CTCLHashTableItem</classname> to another.  The underlying
            templated type must be capable of assignment.
        </para>
        <para>
            <function>operator==</function> allows you to compare two
            <classname>CTCLHashTableItem</classname>s to each other.  The underlying
            templated type must be capable of equality comparison.
        </para>
        <para>
            <programlisting>
<type>T</type> <function>getItem</function>() const;
            </programlisting>
        </para>
        <para>
            Returns the value of the item wrapped by the <classname>CTCLHashTableItem</classname>
            The underlying type must be capable of copy construction.
        </para>
        <para>
            <programlisting>
<type>T</type>* <function>operator-&gt;</function> ();       </programlisting>
        </para>
        <para>
            Returns the address of the contents of the <classname>CTCLHashTableItem</classname>.
            This is most useful if <classname>T</classname> is a structure or class as it can be
            used to dereference member (data or functions) of the structure or class.
            For example:
            <programlisting>
                struct complex {
                                 double real;
                                 double imaginary;
                                 complex(double r, double i) :
                                    real(r), imaginary(i) {}
                                } complex;
                CTCLHashTableItem&lt;complex&gt; v(1.0, 2.0);
                double real = v-&gt;real;             // real = 1.0
                double imag = v-&gt;imaginary;        // imag = 2.0
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLHashTable(3),
CTCLHashTableIterator(3)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Niklaus Wirth <parameter>Algorithms + Data Structures = Programs</parameter>
Prentice Hall Series in Automatic Computation 1976 See section 4.6
            </programlisting>
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLHashTableIterator">
    <refmeta>
        <refentrytitle>CTCLHashTableIterator</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLHashTableIterator</refname>
        <refpurpose>
            Iterator for visiting all elements of a <classname>CTCLHashTable</classname>
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>

#include &gt;TCLHashTableIterator.h&gt;
...
template &lt;class T&gt;
class CTCLHashTableIterator
{

public:
  CTCLHashTableIterator (Tcl_HashTable*   pTable);
  CTCLHashTableIterator (const CTCLHashTableIterator&amp; aCTCLHashTableIterator );
  virtual ~ CTCLHashTableIterator ( );

  CTCLHashTableIterator operator=
                     (const CTCLHashTableIterator&amp; aCTCLHashTableIterator);
  int operator== (const CTCLHashTableIterator&amp; aCTCLHashTableIterator);
  CTCLHashTableItem&lt;T&gt;* getCurrentEntry() const;
  Tcl_HashTable* getHashTable() const;

  CTCLHashTableIterator&amp; operator++ ();
  CTCLHashTableIterator operator++ (int i);
  CTCLHashTableItem&lt;T&gt;&amp; operator* ();
  CTCLHashTableItem&lt;T&gt;* operator-&gt;();

};



    </programlisting>

    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLHashTableIterator</classname> objects are created and returned
        by <classname>CTCLHashTableIterator</classname>::<function>begin</function>
        and <classname>CTCLHashTableIterator</classname>::<function>end</function>.
        These objects are pointer like objects to <classname>CTCLHashTableItem</classname>
        objects within the hash table.
        </para>
        <para>
            If you imagine that all containers can have an ordering defined on them,
            iterators are like pointers to elements of this ordering.
            Dereference operators yield an element of the container, and increment operators
            make the iterator 'point' to the next element in the container according to the
            ordering.
        </para>
        <para>
            For more information on both hash tables and iterators see the
            REFERENCES.  For information about the classes that are related to this,
            consult manpages pointed to by the SEE ALSO section.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLHashTableIterator</function> (<type>Tcl_HashTable</type>* <parameter>pTable</parameter>);
  <function>CTCLHashTableIterator</function>(const <type>CTCLHashTableIterator</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Construct a hash table iterator.  Normally you will not need to use these
            constructors directly.  They will be created, instead by
            <classname>CTCLHashTable</classname>::<function>begin()</function>
            or <classname>CTCLHashTable</classname>::<function>end()</function>.
            <parameter>pTable</parameter> is a pointer to an existing <type>Tcl_HashTable</type>
            created via <function>Tcl_InitHashTable</function>.  <parameter>rhs</parameter>
            is an existing <classname>CTCLHashTableIterator</classname> object whose state
            will be used to initialize the object under construction.
        </para>
        <para>
        <programlisting>
  <type>CTCLHashTableIterator</type> <function>operator=</function>
                     (const <type>CTCLHashTableIterator</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function>(const <type>CTCLHashTableIterator</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            <function>operator=</function> allows you to assign the state of one <classname>CTCLHashTableIterator</classname>
            to another.  When the assignment is complete, the left hand side object will
            be 'pointing' to the same object as the right hand side object but be separately
            incrementable.
        </para>
        <para>
            <function>operator==</function> allows you to compare two iterators for equality.
            equality is defined as the two iterators being defined on the same underlying
            hash table, pointing to the same element, and having the same increment context
            (e.g. an increment of both iterators will leave them both pointing to the
            same hash table item (different from the one prior to the increment).
        </para>
        <para>
        <programlisting>
<type>CTCLHashTableItem&lt;T&gt;</type>* <function>getCurrentEntry</function>() const;
<type>Tcl_HashTable</type>* <function>getHashTable</function>() const;
        </programlisting>
        </para>
        <para>
            These two functions get at the information the iterator is encapsulating.
            <function>getCurrentEntry</function> returns a pointer to the entry that
            the iterator si currently 'pointing' at.  This is identical to the
            <function>operator-&gt;</function> function.
            <function>getHashTable</function> returns a pointer to the underlying
            <type>Tcl_HashTable</type> created by <function>Tcl_InitHashTable</function>.
        </para>
        <para>
            <programlisting>
CTCLHashTableIterator&amp; operator++ ();
CTCLHashTableIterator operator++ (int i);
            </programlisting>
        </para>
        <para>
            These two function support both pre and post increment operations on an
            iterator.  There are slight differences in semantics between these
            operators best illustrated with a sample code fragment.  In the fragment
            below, i is an <classname>CTCLHashTableIterator</classname>
            <programlisting>
CTCLHashTableItem item1 = *i++;   // item 1 is the item pointed to prior to increment
CTCLHashTableItem item2 = *++i;   // item 2 is the item pointed to after increment.
            </programlisting>
        </para>
        <para>
            <programlisting>
<type>CTCLHashTableItem&lt;T&gt;</type>&amp; <function>operator*</function> ();
<type>CTCLHashTableItem&lt;T&gt;</type>* <function>operator-&gt;</function>();
        </programlisting>
        </para>
        <para>
            These operators allow <classname>CTCLHashTableIterator</classname> objects
            to be treated like pointers to <classname>CTCLHashTableItem</classname> objects.
            <function>operator*</function> provides 'pointer' dereferencing that allows
            code like:
            <programlisting>
                (*i).getItem();
            </programlisting>
        </para>
        <para>
            <function>operator-&gt;</function> provides a pointer to struct like semantics
            allowing code like:
            <programlisting>
                i->getItem();
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLHashTable(3),
CTCLHashTableItem(3),
Tcl_InitHashTable(3tcl),
Tcl_FirstHashEntry(3tcl),
Tcl_NextHashEntry(3tcl)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
        <programlisting>
Niklaus Wirth <parameter>Algorithms + Data Structures = Programs</parameter>
Prentice Hall Series in Automatic Computation 1976 See section 4.6

Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
        </programlisting>
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLIdleProcess">
    <refmeta>
        <refentrytitle>CTCLIdleProcess</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLIdleProcess</refname>
        <refpurpose>
            Allows the establishment of an executable object that
            can be scheduled to be invoked when the Tcl/Tk intperpreter
            has no events that require processing.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLIdleProcess.h&gt;

class CTCLIdleProcess : protected CTCLTimer
{
public:
  CTCLIdleProcess(CTCLInterpreterObject* pObject);
  CTCLIdleProcess(CTCLInterpreter* pInterp);
  virtual ~CTCLIdleProcess();

  void Set();
  void Clear();
  virtual void operator()() = 0;
};
    </programlisting>

    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            While Tcl provides a mechanism for scheduling the execution of
            a function when the interpreter main loop is idle (no pending events),
            this is not suitable for processes that may need to be rescheduled.
            Therefore, <classname>CTCLIdleProcess</classname> is actually based on a
            timer dispatch where the delay interval is 0ms.
        </para>
        <para>
        <classname>CTCLIdleProcess</classname>
        provides an abstract base class for creating function like classes that
        are 'called' to run interleaved with the interpreter.
        A function like class is one that implements <classname>operator()</classname>
        (see REFERENCES) below.  You can create an idle processor by creating
        a subclass of <classname>CTCLIdleProcess</classname> overriding
        <classname>operator()</classname>, creating an instance of that new class,
        and invoking the <function>Set()</function> function to schedule the
        execution of the <function>operator()</function>.  Note that
        It is possible for the code in your <function>operator()</function> to
        reschedule itself by calling <function>Set()</function>.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLIdleProcess</function>(<type>CTCLInterpreterObject</type>* <parameter>pObject</parameter>);
  <function>CTCLIdleProcess</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
        </programlisting>
        </para>
        <para>
            Creates a <classname>CTCLIdleProcess</classname> and initializes the timer on which this
            is based. <parameter>pInterp</parameter> is the interpreter that will schedule
            the object's <function>operator()</function>.  <parameter>pObject</parameter>
            points to an interpreter object who's interpreter will schedule the
            <function>operator()</function> to run.
        </para>
        <para>
            <programlisting>
  <type>void</type> <function>Set</function>();
  <type>void</type> <function>Clear</function>();
            </programlisting>
        </para>
        <para>
            These function control the scheduling of the <function>operator()</function>
            call. <function>Set</function> schedules the function to be called pretty much
            the next time the interpreter loop is intered, while <function>Clear</function>
            cancels a pending schedule.
        </para>
        <para>
            <programlisting>
  virtual <type>void</type> <function>operator()</function>() = 0;
        </programlisting>
        </para>
        <para>
            This pure virtual function is overridden by your idle processor to
            provide the behavior of the idle processor.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLTimer(3),
Tcl_CreateTimerHandler(3tcl),
Tcl_DoWhenIdle(3tcl),

        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
See section 2.4 for a description and discussion of function objects.
            </programlisting>
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLPackagedCommand">
    <refmeta>
        <refentrytitle>CTCLPackagedCommand</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLPackagedCommand</refname>
        <refpurpose>
            Base class for a command that lives in a <classname>CTCLCommandPackage</classname>
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLPackagedCommand.h&gt;
...
class CTCLPackagedCommand   : public CTCLProcessor
{

  CTCLPackagedCommand (const std::string&amp; sCommand, CTCLInterpreter* pInterp,
                       CTCLCommandPackage&amp; rPackage);
  CTCLPackagedCommand (const char* pCommand, CTCLInterpreter* pInterp,
                       CTCLCommandPackage&amp; rPackage);
   ~ CTCLPackagedCommand ( );

  CTCLCommandPackage&amp; getMyPackage();

  void setMyPackage (CTCLCommandPackage&amp; am_rMyPackage);

};
    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Command packages (see CTCLCommandPackage(3)), provide a way to organize
            a set of related Tcl command processors  around a set of shared services.
            Objects derived from <classname>CTCLPackagedCommand</classname> are added
            to an object derived from <classname>CTCLCommandPackage</classname>.
            The <classname>CTCLCommandPackage</classname> manages bulk registration of
            all of the commands added to it.  Construcint a
            <classname>CTCLPackagedCommand</classname> object provides it a
            reference to its package so
            that public members of the package can be invoked when the package commands
            are executing.
        </para>
        <para>
            Note that since <classname>CTCLPackagedCommand</classname> is derived from
            <classname>CTCLProcessor</classname>, and does not supply a <function>operator()</function>
            You must derive concrete classes from this class implementing
            <function>operator()</function> to provide the desired command functionality.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLPackagedCommand</function> (const <type>std::string</type>&amp; <parameter>sCommand</parameter>,
                       <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                       <type>CTCLCommandPackage</type>&amp; <parameter>rPackage</parameter>);
  <function>CTCLPackagedCommand></function> (const <type>char</type>* <parameter>pCommand</parameter>,
                       <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                       <type>CTCLCommandPackage</type>&amp; <parameter>rPackage</parameter>);
        </programlisting>
        </para>
        <para>
            Constructs a packaged command.
            <parameter>sCommand</parameter> or
            <parameter>pCommand</parameter>
            provide the command name.  <parameter>pInterp</parameter> is a pointer to the
            interpreter on which the command will be registered.
            <parameter>rPackage</parameter> is a reference to the package this object will
            be a member of.
        </para>
        <para>
            <programlisting>

<type>CTCLCommandPackage</type>&amp; <function>getMyPackage()</function>;
            </programlisting>
        </para>
        <para>
            Returns a reference to the object's package.  This can be cast to the
            actual type of the package at which point package public members can be
            accessed.
        </para>
        <para>
            <programlisting>
  <type>void</type> <function>setMyPackage</function> (<type>CTCLCommandPackage</type>&amp; <parameter>rMyPackage</parameter>);
        </programlisting>
        </para>
        <para>
            Provides a new package for the command.
        </para>
        <para>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLCommandPackage(3),
CTCLProcessor(3)
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLResult">
    <refmeta>
        <refentrytitle>CTCLResult</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLResult</refname>
        <refpurpose>
            Provide an object oriented interace to the Tcl interpreter result.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLResult.h&gt;
...
class CTCLResult  : public CTCLObject
{
  CTCLResult (CTCLInterpreter* pInterp, bool reset=true );
  CTCLResult (const CTCLResult&amp; aCTCLResult );
  virtual ~CTCLResult ( );

  CTCLResult&amp; operator= (const CTCLResult&amp; aCTCLResult);
  CTCLResult&amp; operator= (const char* rhs);
  CTCLResult&amp; operator=(std::string    rhs);

  int operator== (const CTCLResult&amp; aCTCLResult) ;
  int operator!= (const CTCLResult&amp; rhs);

  CTCLResult&amp; operator+= (const char* pString);
  CTCLResult&amp; operator+= (const std::string&amp; rString);

  void Clear ()  ;
  void AppendElement (const char* pString)  ;
  void AppendElement (const std::string&amp; rString);
  void commit() const;
  std::string getString();
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Each Tcl command can return <firstterm>result string</firstterm>
            the result string can be used by subsequent commands in the event
            the command operated successfully, or by <command>catch</command>
            commands if the command failed.  <classname>CTCLResult</classname>
            provides an extension of the <classname>CTCLObject</classname>
            class that builds up a string which can then be comitted to the
            result.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLResult</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
           <type>bool</type> <parameter>reset</parameter>=<literal>true</literal> );
<function>CTCLResult</function>(const <type>CTCLResult</type>&amp; <parameter>aCTCLResult</parameter>);
          </programlisting>
          </para>
          <para>
            Constructs a Tcl interpreter result string.  <parameter>pInterp</parameter> is the interpeter
            that will be associated with this result. <parameter>reset</parameter> controls
            whether or not the result string is reset when constructed, or if it is loaded
            with the current value of the result string.  In the case of copy construction,
            the interpreter associated with <parameter>aCTCLResult</parameter> is used.
            <parameter>aCTCLResult</parameter> is committed to the interpreter result, and
            the object under construction is then loaded from that interpreter's result.
          </para>
          <para>
          <programlisting>
  <type>CTCLResult</type>&amp; <function>operator=</function> (const <type>CTCLResult</type>&amp; <parameter>rhs</parameter>);
  <type>CTCLResult</type>&amp; <function>operator=</function> (const <type>char</type>* <parameter>rhs</parameter>);
  <type>CTCLResult</type>&amp; <function>operator=</function>(<type>std::string</type>    <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Assigns a value to the result from <parameter>rhs</parameter>.
            If the <parameter>rhs</parameter> is a <classname>CTCLResult</classname>, then the
            <parameter>rhs</parameter> is first committed to its interpreter result,
            the left hand object is then bound to the same interpreter as <parameter>rhs</parameter>
            and loaded with the result string of that interpreter.
        </para>
        <para>
        <programlisting>
  <type>int</type> <function>operator==</function> (const <type>CTCLResult</type>&amp; <parameter>rhs</parameter>) ;
  <type>int</type> <function>operator!=</function> (const <type>CTCLResult</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These functions suport comparison. Equality comparison is true
            (<function>operator==</function>) if the interpreters match as the assumption
            is that the user is working to maintain coherency if several <classname>CTCLResult</classname>
            objects are simultaneously live on a single interpreter.
            Inequality (<function>operator!=</function>) is defined as true when
            <function>operator==</function> is false.
        </para>
        <para>
        <programlisting>
<type>CTCLResult</type>&amp; <function>operator+=</function> (const <type>char</type>* <parameter>rhs</parameter>);
<type>CTCLResult</type>&amp; <function>operator+=</function>(const <type>std::string</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            <parameter>rhs</parameter> is textually appended to the result string being built
            up.   Note that the semantics of this are different than for the base class
            where <function>operator+=</function> is a list append.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Clear</function>()  ;
          </programlisting>
          </para>
          <para>
            Clears the result string being built up as well as clearing the
            underlying interpreter's result.
          </para>
          <para>
          <programlisting>
  <type>void</type> <function>AppendElement</function>(const <type>char</type>* <parameter>item</parameter>)  ;
  <type>void</type> <function>AppendElement</function>(const <type>std::string</type>&amp; <parameter>item</parameter>);
          </programlisting>
          </para>
          <para>
            Appends <parameter>item</parameter> to the result string being built up as a
            list element.  This means that under some circumstances extra quoting may be
            done to ensure that the result will be maintained as a valid list.
          </para>
          <para>
          <programlisting>
  <type>void</type> <function>commit</function>() const;
  <type>std::string</type> <function>getString</function>();
        </programlisting>
        </para>
        <para>
            <function>commit</function> sets the interpreter result string equal
            to the string being built up in the object.  <function>getString</function>
            does a commit and then returns the string.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLObject(3)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLString">
    <refmeta>
        <refentrytitle>CTCLString</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLString</refname>
        <refpurpose>
            Provide a wrapper for the <type>Tcl_DString</type> data type
            and its API
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLString.h&gt;
...
class CTCLString
{
public:
  CTCLString ();
  CTCLString (const char* pString  ) ;
  CTCLString(const std::string&amp; rString);
  CTCLString(const Tcl_DString&amp; rString);
  CTCLString (const CTCLString&amp; aCTCLString );
  ~ CTCLString ();

  CTCLString&amp; operator= (const CTCLString&amp; aCTCLString);
  int operator== (const CTCLString&amp; aCTCLString);
  int operator!= (const CTCLString&amp; aCTCLString);
  int operator&gt; (const CTCLString&amp; aCTCLString);
  int operator&lt; (const CTCLString&amp; aCTCLString);
  int operator&gt;=(const CTCLString&amp; aCTCLString);
  int operator&lt;=(const CTCLString&amp; aCTCLString);

  Tcl_DString&amp; getString();
  CTCLString&amp; Append (const std::string&amp; rString, Int_t nLength=-1);
  CTCLString&amp; Append (const CTCLString&amp;  rString, Int_t nLength=-1);
  CTCLString&amp; Append (Tcl_DString&amp;       pString, Int_t nLength=-1);
  CTCLString&amp; Append (const char*        pString, Int_t nLength=-1);
  CTCLString&amp; AppendElement (const Tcl_DString*      pRhs);
  CTCLString&amp; AppendElement (const CTCLString&amp;       rRhs);
  CTCLString&amp; AppendElement (const std::string&amp;      rRhs);
  CTCLString&amp; AppendElement (const char*             pRhs);
  CTCLString&amp; AppendElement(DFloat_t value, const char* pFormat = "%f");
  CTCLString&amp; AppendElement(long value, const char* pFormat = "%i");

  CTCLString&amp; StartSublist ()  ;
  CTCLString&amp; EndSublist ()  ;
  UInt_t  Length () const ;
  CTCLString&amp; Truncate (UInt_t nNewLength)  ;
  Bool_t isCommand () const  ;

  Bool_t Match (const char*       pPattern) const;
  Bool_t Match (std::string&amp;      rPattern) const;
  Bool_t Match (const CTCLString&amp; rPattern) const;

  operator const char* () const;
  operator std::string () const;
  operator Tcl_DString* ();
};
    </programlisting>


    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The Tcl API provides a dynamic string type <type>Tcl_DString</type>.
            For many purposes, the C++ <type>std::string</type> is sufficient, however
            the <type>Tcl_DString</type> list building functions are unmatched in
            <type>std::string</type>.  <classname>CTCLString</classname> is an object oriented
            wrapping of a <type>Tcl_DString</type>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <programlisting>
<type>CTCLString</type> ();
<type>CTCLString</type> (const <type>char</type>* <parameter>pString</parameter>) ;
<type>CTCLString</type>(const <type>std::string</type>&amp; <parameter>rString</parameter>);
<type>CTCLString</type>(const <type>Tcl_DString</type>&amp; <parameter>rString</parameter>);
<type>CTCLString</type> (const <type>CTCLString</type>&amp; <type>aCTCLString</type> );
            </programlisting>
            </para>
            <para>
                Constructs a <classname>CTCLString</classname> object.  With the exception
                of the first constructor, which produces an empty string, all of these
                constructors initialize the contents of the underlying
                <classname>Tcl_DString</classname> with the string representation of their
                parameter.
            </para>
            <para>
            <programlisting>
<type>CTCLString</type>&amp; <function>operator=</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Supports assignment to a <classname>CTCLString</classname> from another;
            <parameter>rhs</parameter>.
        </para>
        <para>
        <programlisting>
<type>int</type> <function>operator==</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator!=</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&gt;</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&lt;</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&gt;=</function>(const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&lt;=</function>(const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Relational operators provide for lexicographic copmarisons between the object
            and <parameter>rhs</parameter> which is another <classname>CTCLString</classname>.
        </para>
        <para>
        <programlisting>
<type>Tcl_DString</type>&amp; <function>getString</function>();
        </programlisting>
        </para>
        <para>
            Returns a reference tothe underlying <type>Tcl_DString</type> of the
            object.
        </para>
        <para>
        <programlisting>
<type>CTCLString</type>&amp; <function>Append</function> (const <type>std::string</type>&amp; <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
<type>CTCLString</type>&amp; <function>Append</function> (const <type>CTCLString</type>&amp; <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
<type>CTCLString</type>&amp; <function>Append</function> (<type>Tcl_DString</type>&amp;       <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
<type>CTCLString</type>&amp; <function>Append</function> (const <type>char</type>*            <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
        </programlisting>
        </para>
        <para>
            Appends a section of <parameter>String</parameter> to the
            <classname>CTCLString</classname> that is being built up.
            The first <parameter>nLength</parameter> characters are appended.
            if <parameter>nLength</parameter> is <literal>-1</literal> then
            all <parameter>String</parameter> is appended.
        </para>
        <para>
        <programlisting>
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>Tcl_DString</type>*  <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>CTCLString</type>&amp;   <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>std::string</type>&amp;  <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>char*</type>         <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function>(<type>DFloat_t</type> <parameter>item</parameter>,
                         const <type>char*</type> <parameter>pFormat</parameter> = <literal>"%f"</literal>);
<type>CTCLString</type>&amp; <function>AppendElement</function>(<type>long</type>     <parameter>item</parameter>,
                         const <type>char*</type> <parameter>pFormat</parameter> = <literal>"%i"</literal>);
        </programlisting>
        </para>
        <para>
            Appends <parameter>item</parameter> as a list element to the end of the
            string.  If necessary quotation is performed to ensure the item is treated as a
            single list element.  The <parameter>pFormat</parameter> parameter
            controls the conversion of non string data types to a string and is of the form
            of any control sequence used by sprintf.  For example
            <literal>"i = %d"</literal> could be used to convert an integer to a label
            and its value which would be appended to the string as e.g.
            <literal>{i = 1234}</literal>
        </para>
        <para>
        <programlisting>
<type>CTCLString</type>&amp; <function>StartSublist</function> ()  ;
<type>CTCLString</type>&amp; <function>EndSublist</function> ()  ;
        </programlisting>
        </para>
        <para>
            Used in conjuntion with <function>AppendElement</function> these
            start and end sublists which are list elements that consist of lists.
            Sublists can be nested to any depth.
            For example:
            <programlisting>
    CTCLString s;
    s.AppendElement("a");
    s.StartSublist();
    s.AppendElement("b");
    s.AppendElement("c");
    s.StartSublist();
    s.AppendElement("d");
    s.AppendElement("e");
    s.EndSublist();
    s.AppendElement("f");
    s.EndSublist();
    s.AppendElement("g");
            </programlisting>
        Would make the <varname>s</varname> contain the string
        <literal>"a {b c {d e} f} g"</literal>
        </para>
        <para>
        <programlisting>
<type>UInt_t</type>  <function>Length</function>() const ;
        </programlisting>
        </para>
        <para>
            Returns the number of characters in the string.
        </para>
        <informalexample>
        <programlisting>
CTCLString&amp; Truncate (UInt_t nNewLength)  ;
        </programlisting>
        </informalexample>
        <para>
            Truncates the string to the first <parameter>nNewLength</parameter>
            characters.
        </para>
    
        <informalexample>
        <programlisting>
<type>Bool_t</type> <function>isCommand</function> () const  ;
        </programlisting>
        </informalexample>
        <para>
            Analyzes the string and returns <literal>kfTRUE</literal> if the
            string is a 'well formed command'.  Note that a well formed command
            may still have syntax and execution errors.  This just ensures that
            a string has a balanced set of quoting characters.
        </para>
        <informalexample>
        <programlisting>
<type>Bool_t</type> <function>Match</function> (const <type>char</type>*           <parameter>Pattern</parameter>) const;
<type>Bool_t</type> <function>Match</function> (<type>std::string</type>&amp;      <parameter>Pattern</parameter>) const;
<type>Bool_t</type> <function>Match</function> (const <type>CTCLString</type>&amp; <parameter>Pattern</parameter>) const;
        </programlisting>
        </informalexample>
        <para>
            Returns <literal>kfTRUE</literal> if the contents of the string matches the
            <parameter>Pattern</parameter>
            parameter.  The <parameter>Pattern</parameter> parameter can contain all of the
            wildcards in <firstterm>glob</firstterm> style pattern matching.  See
            REFERENCES below for moer information about glob style matching.
        </para>
        <informalexample>
        <programlisting>
operator const char* () const;
operator std::string () const;
operator Tcl_DString* ();
    </programlisting>
        </informalexample>
        <para>
            These operators are implicit and explicit type conversion operators that
            allow a <classname>CTCLString</classname> object to be treated as a
            <type>char*</type> pointing to a null terminated string, a
            <type>std::string</type> object, or a <type>Tcl_DString</type> pointer.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
Tcl_DStringAppend(3tcl),
Tcl_DStringAppendElement(3tcl),
Tcl_DStringEndSublist(3tcl),
Tcl_DStringFree(3tcl),
Tcl_DStringGetResult(3tcl),
Tcl_DStringInit(3tcl),
Tcl_DStringLength(3tcl),
Tcl_DStringResult(3tcl),
Tcl_DStringSetLength(3tcl),
Tcl_DStringStartSublist(3tcl)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <informalexample>
            <programlisting>
J.K. Ousterhout <parameter>Tcl and the Tk Toolkit</parameter>
Addison-Wesley Professional Computing Series 1994 see section 9.2
            </programlisting>
        </informalexample>
    </refsect1>
</refentry>



<refentry id="manpage.CTCLTimer">
    <refmeta>
        <refentrytitle>CTCLTimer</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLTimer</refname>
        <refpurpose>
            Abstract base class for C++ objects attached to timer events.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLTimer.h&gt;
...
class CTCLTimer  : public CTCLInterpreterObject
{
public:
  CTCLTimer ();
  CTCLTimer(CTCLInterpreter* pInterp, UInt_t nMsec = 0);
  virtual ~CTCLTimer ( );


  Tk_TimerToken getToken() const;
  UInt_t getMsec() const;
  Bool_t IsSet() const;

  virtual   void operator() ()   = 0;

  void Set ()  ;
  void Set(UInt_t nms);
  void Clear ()  ;
};


    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl/Tk provide a mechanism for scheduling functions to be executed
            after a time delay specified in milliseconds.   The <classname>CTCLTimer</classname>
            class is an abstract base class that provides an interface into the API
            for that facility.  To use <classname>CTCLTimer</classname> you must
            create a class derived from <classname>CTCLTimer</classname> that
            overrides and implement the <function>operator()</function> function.
            Create an object from the resulting function class.  Use the object's
            <function>Set</function> and <function>Clear</function> members to schedule
            or cancel a scheduled execution.  The code fragment
            example below shows how to do this
            to create a class that periodically emits the text "Tick" to stderr.
            Many #include directives are missing for brevity.
            </para>
            <informalexample>
            <programlisting>
// Interface to <classname>Ticker</classname> normally goes in a header.
class Ticker : public CTCLTimer
{
public:
    Ticker(CTCLInterpreter* pInterp, int seconds);
    virtual ~Ticker();

    virtual void operator()();
};
...
// Implementation of <classname>Ticker</classname> normally goes in a .cpp

// Constructor of Ticker:

Ticker::Ticker(int seconds) :
    CTCLTimer(pInterp, seconds*1000)
{
    Set();                   // Schedule first one.
}
// Destructor.. chain to base class.
Ticker::~Ticker() {}

// called when timer goes off:
void
Ticker::operator()() {
    cerr &lt;&lt; "Tick\n";
    Set();                 // Schedule next one.
}
...


Ticker Tick(pInterp, 1);  // Tick every second.

            </programlisting>
            </informalexample>
        
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <informalexample>
        <programlisting>
<function>CTCLTimer</function> ();
<function>CTCLTimer</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          <type>UInt_t</type> <parameter>nMsec</parameter> = <literal>0</literal>);
          </programlisting>
        </informalexample>
          <para>
            Construct timer objects.  The first form of the constructor creates a timer
            object that must be later bound into an interpreter via a call to
            <classname>CTCLInterpreterObject</classname>::<function>Bind</function>.
            The seconf form of the contructor creates a timer object that is already
            bound to <parameter>pInterp</parameter> and has an initial schedule delay
            of <parameter>nMsec</parameter>.
          </para>
          <informalexample>
          <programlisting>
  Tk_TimerToken getToken() const;
  UInt_t getMsec() const;
          </programlisting>
          </informalexample>
          <para>
            These two members access internal state of the object.
            <function>getToken</function> returns the <type>Tk_TimerToken</type>
            associated with the timer object.  This is the Tcl/Tk token that
            identifies the timer request to the interpreter.
            <function>getMsec</function> retrieves the current value of the delay parameter
            in milliseconds.
          </para>
          <informalexample>
          <programlisting>
  virtual   void operator() ()   = 0;
        </programlisting>
          </informalexample>
        <para>
            This function must be overidden and implemented in concrete timer classes.
            See the example in DESCRIPTION above.
        </para>
        
        <informalexample>
        <programlisting>

  void Set ()  ;
  void Set(UInt_t nms);
  Bool_t IsSet() const;
        </programlisting>
        </informalexample>
        
        <para>
            <function>Set</function> schedules the object for execution.  If
            <parameter>nms</parameter> is provided it is saved as the scheduling
            parameter and determines the delay
            in milliseconds before <function>operator()</function> is
            next called.  If not provided, the most recently used delay will be
            used again.
        </para>
        <para>
            <function>IsSet</function> returns <literal>kfTRUE</literal> if the
            timer is currently pending, or <literal>kfFALSE</literal> if no pending
            timer request is active.
        </para>
        <para>
        <informalexample>
        <programlisting>
  void Clear ()  ;
        </programlisting>
        </informalexample>
        </para>
        <para>
           If a Timer request is pending, cancels it.  If no timer request is pending,
            this function does nothing, and does not report an error.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLInterpreterObject(3)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <informalexample>
            <programlisting>
Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
See section 2.4 for a description and discussion of function objects.
            </programlisting>
            </informalexample>
        </para>
    </refsect1>
</refentry>

    <refentry id="manpage.CTCLLiveEventLoop">
      <refmeta>
         <refentrytitle>CTCLLiveEventLoop</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLLiveEventLoop</refname>
	 <refpurpose>Run Tcl with event loop.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLLiveEventLoop.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLLiveEventLoop</classname></ooclass>
            <methodsynopsis>
                <modifier>static</modifier> <type>CTCLLiveEventLoop*</type>
                                            <methodname>getInstance</methodname>
                                            <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>start</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>start</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>stop</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>long</type> <methodname>setStopLatency</methodname>
                <methodparam>
                    <type>long</type> <parameter>ms</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>long</type> <methodname>getStopLatency</methodname>
                                <void /> <modifier>const</modifier>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The Tcl/Tk applications programming interfaces provides an event loop.
            In the case of Tk programs, the event loop is active once the Tk
            package starts.  For pure Tcl (non GUI) programs, the event loop
            is not active unless the script explicitly enters the event loop
            via e.g. <command>vwait</command>.
         </para>
         <para>
            <command>vwait</command> and other pure Tcl commands that enter
            the event loop block the interpreter from processing commands on
            stdin while the loop is running.  For some Tcl based data acquisition
            programs this is not acceptable.  For example, a readout program may
            want to accept commands on the command line while doing some periodic
            processing.  This class provides the ability to do this.
         </para>
         <para>
            The class is a singleton pattern instance, which means that you cannot
            actually construct an instance, but must use the <methodname>getInstance</methodname>
            method to get a pointer to the single instance of the singleton.
            The class works by establishing an event handler on stdin,
            and manually running the event loop at the C++ level.
            The C++ event loop and stdin input handler do prompting analagous
            to that of tclsh.  When the stdin event handler has accumulated a
            syntactically complete command it passes that on to the interpreter
            for evaluation, reporting the result to stdout.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <modifier>static</modifier> <type>CTCLLiveEventLoop*</type>
                                            <methodname>getInstance</methodname>
                                            <void />
            </methodsynopsis>
            <para>
                Returns a pointer to the singleton instance of the
                live event loop object.  The object is a singleton because
                while each application may have more than one interpreter,
                there is only at most one event loop.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>start</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Starts the event loop.  This will not return to the caller
                until some external force has stopped the event loop.
                External forces include the user closing stdin, or
                the event loop being asked to stop.
            </para>
            <para>
                In this invocation, the commands accumulated on stdin are
                dispatched to the interpreter that was bound to the
                <classname>CTCLApplication</classname> object.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>start</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Starts the event loop.  Commands accumulated by the stdin event
                handler are submited to <parameter>pInterp</parameter> for
                execution.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>stop</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Requests the event loop to stop processing.
                See below for the latency between this request and the
                actual stop time. Note that a different thread can call this
                than the one running the target interpreter.
            </para>
            <methodsynopsis>
                <type>long</type> <methodname>setStopLatency</methodname>
                <methodparam>
                    <type>long</type> <parameter>ms</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                The event loop waits for events with a timeout. When a wait
                has completed, if there are events in the queue, they are all
                processed.  After processing any pending events, the event loop
                determines if a stop has been requested, and if so, returns to
                its caller.
            </para>
            <para>
                The wait timeout is set by this member function to
                <parameter>ms</parameter> milliseconds.  This effectively sets
                an estimated latency between the <methodname>stop</methodname>
                member being called, and the event loop actually exiting.
            </para>
            <para>
                The function returns the prior latency setting.
            </para>
            <methodsynopsis>
                <type>long</type> <methodname>getStopLatency</methodname>
                                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns the current value of the latency setting.
                See <methodname>setStopLatency</methodname> above for
                more information. 
            </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            The sample below is a stock tclsh that always runs the event loop
             in the background.  It is installed in the NSCLDAQ
             <filename>bin</filename> directory as
            <application>evttclsh</application>
         </para>
         <example>
            <title>evttclsh</title>
            <programlisting>
#include &lt;TCLApplication.h&gt;
#include &lt;TCLLiveEventLoop.h&gt;

class evttclsh : public CTCLApplication
{
public:
  virtual int operator()();
};

int
evttclsh::operator()()
{
  CTCLLiveEventLoop* pLoop = CTCLLiveEventLoop::getInstance();
  pLoop-&gt;start();
  return TCL_ERROR;
}

CTCLApplication* gpTCLApplication = new evttclsh;

            </programlisting>
         </example>
      </refsect1>
   </refentry>


    <refentry id="manpage.ctclchannelcommander">
      <refmeta>
         <refentrytitle>CTCLChannelCommander</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLChannelCommander</refname>
	 <refpurpose>Accept commands on a Tcl channel from the event loop.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLChannelCommander.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLChannelCommander</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLChannelCommander</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>interp</parameter>
                </methodparam>
                <methodparam>
                    <type>Tcl_Channel</type>      <parameter>channel</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CTCLChannelCommander</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>start</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>stop</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>Tcl_Channel</type>  <methodname>getChannel</methodname>
                                          <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>onInput</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>onInputException</methodname>
                                                               <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>onEndFile</methodname>
                                                               <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>onCommand</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>returnResult</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>prompt1</methodname>
                                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>prompt2</methodname>
                                             <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>sendPrompt</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>prompt</parameter>
                </methodparam>
            </methodsynopsis>


         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The <classname>CTCLChannelCommander</classname> is a class that
            registers an input event handler for a Tcl channel.  When input
            is available on the channel, a line of text is read, and appended
            to a command under construction.  When the command is syntactically
            complete, it is dispatched to a Tcl interpreter for execution.
         </para>
         <para>
            The subclass <classname>CTCLStdioCommander</classname> is specifically
            tailored to accept commands on stdin.  ALong with the server listener
            <classname>CTCLServer</classname>, <classname>CTCLTcpServerInstance</classname>
            is tailored to accpet commands on a socket.
         </para>
         <para>
            Many aspects of the class are tailorable by overriding the various
            methods in derived classes.  The class is capable of generating prompts
            in case the channel is interactive.  The classs can also return the
            results of commands to the client over the medium of its choice.
            End file and exception handling can be simlarly tailored.
         </para>
         <para>
            When deriving a specific class be sure you understand the default actions
            of all of the base class members. You may save a great deal of work by
            carefully chosing exactly which members to override, or generate a
            great deal of work by making poor choices.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis>
                <methodname>CTCLChannelCommander</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>interp</parameter>
                </methodparam>
                <methodparam>
                    <type>Tcl_Channel</type>      <parameter>channel</parameter>
                </methodparam>
            </methodsynopsis>
           <para>
            Constructs a new channel commander. Activation of the commander is
            a two step process.  First the commander is constructed, second
            it <methodname>start</methodname> method is called to register the
            event handlers.  
           </para>
           <para>
            <parameter>interp</parameter> is a pointer to the interpreter
            channel on to which the commands will be dispatched.
            <parameter>channel</parameter> is the channel from which commands
            will be accepted.
           </para>
           <para>
            The application must also be visiting the event loop for
            commands to be processed from the
            <parameter>channel</parameter>.
            Tk applications automatically run the event loop.
            Pure Tcl applications run the event loop only when
            <command>vwait</command> is waiting, while the
            special shell or tcl applications based around
            <classname>CTCLLiveEventLoop</classname> run the
            event loop automatically just like Tk does.
           </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>start</methodname>
                <void />
            </methodsynopsis>
            <para>
                Enables processing of commands from the channel.  When
                the event loop is entered, if the channel is readable,
                control will be to
                <methodname>onInput</methodname> in object context.
                It is not considered an error to call
                <methodname>start</methodname> when event processing
                is in progress.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>stop</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                Requests channel processing be disabled.  The event handlers
                that arrange for control to be dispatched to the
                <methodname>onInput</methodname>
                method are disabled.  The channel remains open and must
                be closed (if desired) by any client software.
            </para>
            <methodsynopsis>
                <type>Tcl_Channel</type>  <methodname>getChannel</methodname>
                                          <void /> <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns the channel from which commands are being accepted.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>onInput</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                This member function is called when data can be read from the
                input channel.  The function attempts to read a line of text.
                The text is appended to a command under construction and,
                if <function>Tcl_CommandComplete</function> says that
                string is a syntactically complete command,
                <methodname>onCommand</methodname> is invoked to execute the
                command.  
            </para>
            <para>
                All of this command acquisition and exection is also mixed up
                with prompting.
                <methodname>prompt1</methodname>
                is called when the object is ready to get  a new command, and
                <methodname>prompt2</methodname> is called when the
                object is ready to accept the next line of a multi-line command.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>onInputException</methodname>
                                                               <void />
            </methodsynopsis>
            <para>
                Called when an exception condition is detected on the channel. The default implementation
                calls
                <methodname>onEndFile</methodname>
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>onEndFile</methodname>
                                                               <void />
            </methodsynopsis>
            <para>
                Called when reads of the channel indicate an end file condition.
                <methodname>onInputException</methodname>'s default implementation
                also calls this.  The default behavior is to invoke
                <methodname>stop</methodname> so that no additional events will
                be posted.  This is the normal and reasonable behavior because
                a channel with an endfile condition continously generates
                readable events.
            </para>
            <para>
                The channel remains open.  It is always up to client software to
                close the channel.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>onCommand</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                Called when a complete command has been accepted.  Complete in this
                case means syntactically complete.  It does not imply correctness,
                or even proper number of arguments.
            </para>
            <para>
                Default behavior is to submit the command string to the
                interpreter. Once the command has been executed,
                <methodname>returnResult</methodname>
                is executed to allow the command result to be reported
                if desired.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>returnResult</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                By default this does nothing.  It is provided to allow subclasses
                to tailore what is done with command results.  For example,
                the
                <classname>CTCLStdioCommander</classname>
                class reports the result on
                <literal>stdout</literal>.
                <classname>CTCLTcpServerInstance</classname> on the other hand
                reports the result back to the client over the socket.
            </para>
            <para>
                The <methodname>GetResultString</methodname> method of the
                interpreter object (the pointer <varname>m_pInterp</varname>
                is a pointer to the interpreter object) should be used to
                get the result string.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>prompt1</methodname>
                                <void />
            </methodsynopsis>
            <para>
                Called when its time to prompt for the first line of a command.
                This calls
                <methodname>prompt1String</methodname> to get the prompt string,
                and calls
                <methodname>sendPrompt</methodname> to actually emit the prompt.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>prompt2</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                Called when its time to prompt for additional linesof a command.
                This calls
                <methodname>prompt2String</methodname> to get the prompt string
                and calls
                <methodname>sendPrompt</methodname> to actually emit the prompt.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>sendPrompt</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>prompt</parameter>
                </methodparam>
            </methodsynopsis>
       </refsect1>
      <refsect1>
        <title>Prompting</title>
        <para>
            The class provides a framework for prompting interactive channels.
            This frameworks is based on two prompt strings that can be gotten
            via calls to
            <methodname>prompt1String</methodname> and
            <methodname>prompt2String</methodname>
            respectively.
        </para>
        <para>
            The first of these prompts is emitted when the software is
            ready to accept the first line of a new command.
            By default it is the text "<literal>% </literal>".  Scripts
            can customize this prompt by defining the
            variable <varname>tcl_prompt1</varname> to be a script
            whose returned value is the prompt.
        </para>
        <para>
            The second of these prompts is emitted when the software
            is ready to accept continuation lines of multiline commands.
            By default it is the text "<literal>%_ </literal>".
            Scripts can customize this prompt by defining the
            variable <varname>tcl_prompt2</varname> to be a script
            whose returned value is the desired prompt.
        </para>
      </refsect1>
   </refentry>
    <refentry id="manpage.CTCLStdioCommander">
      <refmeta>
         <refentrytitle>CTCLStdioCommander</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLStdioCommander</refname>
	 <refpurpose>Event driven command input on stdin/stdout</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLStdioCommander.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLStdioCommander</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLStdioCommander</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CTCLStdioCommander</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>sendPrompt</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>prompt</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>returnResult</methodname>
                                             <void />
            </methodsynopsis>

         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Provides a commander that can be hooked to the event loop to allow
            event loop driven applications to continue to process commands on
            stdin/stdout as interactive shells do.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <methodname>CTCLStdioCommander</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Constructs a commander.  <parameter>pInterp</parameter> is the
                interpreter to which the complete commands will be submitted.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>sendPrompt</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>prompt</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Overrides the base class <methodname>sendPrompt</methodname>
                method by sending the requested <parameter>prompt</parameter>
                string to the <type>Tcl_Channel</type> Tcl has open on
                <literal>stdout</literal>. The channel is also flushed to
                ensure that the prompt is made immediately visible.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>returnResult</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                Overrides the base class member.
                Retrieves the result from the interpreter, appends a newline
                character and passes the resulting string to
                <methodname>sendPrompt</methodname> which makes the result
                visible on stdout.
            </para>
      </refsect1>
   </refentry>


    <refentry id="manpage.CTCLServer">
      <refmeta>
         <refentrytitle>CTCLServer</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLServer</refname>
	 <refpurpose>Listener for a Tcl server.</refpurpose>
      </refnamediv>     
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLServer.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLServer</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLServer</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>port</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CTCLServer</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>instanceExit</methodname>
                <methodparam>
                    <type>CTCLTcpServerInstance*</type> <parameter>pInstance</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>shutdown</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>bool</type> <methodname>allowConnection</methodname>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>hostname</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>CTCLTcpServerInstance*</type>
                <methodname>createInstance</methodname>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>hostname</parameter>
                </methodparam>
            </methodsynopsis>
 
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Tcl servers allow a Tcp/Ip client to connect to a tcl application
            and poke commands at it.  While this is a very powerful communications
            mechanism, it should be used very cautiously as it can also be quite
            dangerous (imagine a client pushing a command like
            <command>exec /bin/bash -c rm -rf ~</command> for example).
         </para>
         <para>
            <classname>CTCLServer</classname> is a class that provides the listener
            portion of the server.  The application that uses this must execute
            a Tcl event loop in a timely fashion.
            <classname>CTCLServer</classname> processes connections and creates,
            where appropriate <classname>CTCLTcpServerInstance</classname> objects
            that handle communication with clients.
            The server object maintains a directory of server instances so that when
            asked to shutdown it can shutdown all server instances as well.
         </para>
         <para>
            The class provides strategy pattern hooks to support arbitrary
            authorization models, as well as the production of any subclass
            of <classname>CTCLTcpServerInstance</classname> to process
            the commands.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <methodname>CTCLServer</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>port</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Constructs and activates a server object. Activation means that
                the Tcl event loop can dispatch events for client connections
                to the object for processing.
                <parameter>pInterp</parameter> is the interpreter this server
                is supposed to be servicing.  In the standard scheme, this is
                the interpreter to which commands will be dispatched.
                <parameter>port</parameter> is the Tcp/IP port on which the
                server will listen for connections.
            </para>
            <methodsynopsis>
                <type>void</type>
                <methodname>instanceExit</methodname>
                <methodparam>
                    <type>CTCLTcpServerInstance*</type> <parameter>pInstance</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                The server maintains a directory of server instances.  When server
                instances exit they must call this function in the server listener
                passing a pointer to themselves (<varname>this</varname>) as a
                parameter.  This function locates the instance in the
                directory, removes it from the directory and
                <emphasis>deletes that object</emphasis>.
            </para>
            <para>
                Having called this, the server instance should return
                immediately as its object context has become invalid.
                If the server listener object is asked to shutdown, it will
                also call <methodname>instanceExit</methodname> on all
                instances to shut them down as well.
            </para>
            <methodsynopsis>
                <type>void</type>
                <methodname>shutdown</methodname>
                <void />
            </methodsynopsis>
            <para>
                Stops listening for connections on the server port and
                shuts down all instances by invoking
                <methodname>instanceExit</methodname> on them.
            </para>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>bool</type> <methodname>allowConnection</methodname>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>hostname</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Called at connection time to determine if the connection should
                be allowed.  <parameter>connection</parameter> is the
                <type>Tcl_Channel</type> that is open on the client.
                overrides of this are perfectly free to do any sort of
                communication back and fort with the client to determine
                its elligibility to connect. 
            </para>
            <para>
                <parameter>hostname</parameter> is the name of the host
                that is connecting.  This allows a host based authentication
                scheme to be developed.
            </para>
            <para>
                The function must return <literal>true</literal> to accept the
                connection and <literal>false</literal> to deny it.
            </para>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>CTCLTcpServerInstance*</type>
                <methodname>createInstance</methodname>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>hostname</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Called to create a client instance.  The client instance is responsible
                for interacting with the client to do whatever communication is needed.
                By making this virtual, any type descended from
                <classname>CTCLTcpServerInstance</classname> can be created.
            </para>
            <para>
                <parameter>connection</parameter> is the <type>Tcl_Channel</type>
                open on the client.
                <parameter>hostname</parameter> is the host that is connecting.
            </para>
      </refsect1>

   </refentry>

    <refentry id="manpage.CTCLTcpServerInstance">
      <refmeta>
         <refentrytitle>CTCLTcpServerInstance</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLTcpServerInstance</refname>
	 <refpurpose>Channel commander that is a server instance for <classname>CTCLServer</classname></refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CTCLTcpServerInstance.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLTcpServerInstance : public CTCLChannelCommander</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLTcpServerInstance</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>CTCLServer*</type> <parameter>pServer</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CTCLTcpServerInstance</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                            <methodname>onEndFile</methodname>
                            <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                        <methodname>returnResult</methodname>
                                        <void />
            </methodsynopsis>

         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Server instance that takes client commands and submits them to
            an interpreter.  The results of each command are sent back to the
            client. At this point the client can only look at the
            result value to determine if there was an error as no error indication
            is passed back.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <constructorsynopsis>
                <methodname>CTCLTcpServerInstance</methodname>
                <methodparam>
                    <type>CTCLInterpreter*</type> <parameter>pInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>Tcl_Channel</type> <parameter>connection</parameter>
                </methodparam>
                <methodparam>
                    <type>CTCLServer*</type> <parameter>pServer</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Constructs a new server instance.
                <parameter>pInterp</parameter> is the interpreter to which
                commands should be directed.
                <parameter>connection</parameter> is the <type>Tcl_Channel</type>
                that represents the Tcp/IP connection to the client.
                <parameter>pServer</parameter> is the TCL server object
                that starts us.  That server's
                <methodname>instanceExit</methodname> member should be called
                to shut down and clean up this object.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                            <methodname>onEndFile</methodname>
                            <void />
            </methodsynopsis>
            <para>
                Override to end of file handling.  Closes the
                channel and invokes the
                server listener's <methodname>instanceExit</methodname>
                method to get ourselves deleted.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                        <methodname>returnResult</methodname>
                                        <void />
            </methodsynopsis>
            <para>
                Returns a command result by fetching it from the interpreter
                and sending it back to the client on the socket.
            </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.CTCLObjectPackage">
      <refmeta>
         <refentrytitle>CTCLObjectPackage</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLObjectPackage</refname>
	 <refpurpose>Provide common functionality for a set of
                related commands.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;TCLObjectPackage.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLObjectPackage</classname></ooclass>
            <methodsynopsis>
                <type>void</type><methodname>addCommand</methodname>
                <methodparam>
                    <type>CTCLPackagedObjectProcessor*</type> <parameter>processor</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>CTCLObjectPackage::CommandIterator</type>
                <methodname>begin</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>CTCLObjectPackage::CommandIterator</type>
                <methodname>end</methodname>
                <void />
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class is a base class for a set of common services that
            can be offered to a set of related commands.  The commands themselves
            must be derived from CTCLPackagedObjectProcessor.  
         </para>
         <para>
            The base class provides the infrastructor for maintaining the list
            of command objects that participate in the package, for associating
            a command with the package, and for iterating through associated
            command objects.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis>
                <type>void</type><methodname>addCommand</methodname>
                <methodparam>
                    <type>CTCLPackagedObjectProcessor*</type> <parameter>processor</parameter>
                </methodparam>
            </methodsynopsis>
           <para>
                Adds a new command object to the package.  The command object
                will have its <methodname>onAttache</methodname> method
                invoked, which allows it to save the command package (passed in
                as a parameter), and to do any initialization that requires
                the command package services.
           </para>
            <methodsynopsis>
                <type>CTCLObjectPackage::CommandIterator</type>
                <methodname>begin</methodname>
                <void />
            </methodsynopsis>
            <para>
                Returns an iterator for the first command object associated
                with the object.  The iterator is a pointer like object in the
                sense that dereferencing it will yield a pointer to ta
                command object.  The iterator can be stepped through the
                collection via the incremenet operator (<literal>++</literal>).
                Iteration is complete when the iterator is equal to
                <methodname>end()</methodname> see below.
            </para>
            <methodsynopsis>
                <type>CTCLObjectPackage::CommandIterator</type>
                <methodname>end</methodname>
                <void />
            </methodsynopsis>
            <para>
                Provides an end iterator against which to compare an iterator
                over the commands to determine if all of them have been
                visited.
            </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            <classname>CTCLObjectPackage::CommandIterator</classname> is a
            pointer like object returned by the
            <methodname>begin</methodname> and <methodname>end</methodname>
            methods to allow iteration through the set of command objects
            associated with this package.
         </para>
      </refsect1>
 
      <refsect1>
         <title>
            SEE ALSO
         </title>
	 <para>
            <link linkend="manpage.CTCLPackagedObjectProcessor">
                CTCLPackagedObjectProcessor(3daq)</link>
	 </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.CTCLPackagedObjectProcessor">
      <refmeta>
         <refentrytitle>CTCLPackagedObjectProcessor</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTCLPackagedObjectProcessor</refname>
	 <refpurpose>Base class for commands living in a
                    <classname>CTCLObjectPackage</classname>
         </refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;TCLPackagedObjectProcessor.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTCLPackagedObjectProcessor</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTCLPackagedObjectProcessor</methodname>
                <methodparam><type>CTCLInterpreter&amp;</type>
                             <parameter>interp</parameter>
                </methodparam>
                <methodparam><type>std::string</type>
                             <parameter>command</parameter>
                </methodparam>
                <methodparam><type>bool</type>
                             <parameter>registerMe</parameter>
                             <initializer>true</initializer>
                </methodparam>
            </constructorsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>onAttach</methodname>
                <methodparam>
                    <type>CTCLObjectPackage*</type> <parameter>package</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>CTCLObjectPackage*</type>  <methodname>getPackage</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>void</type> <methodname>Initialize</methodname>
                <void />
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            A packaged object command is a <classname>CTCLObjectProcessor</classname>
            that can draw on a set of services shared between it and a
            set of related commands.  The set of commands and the common set
            of services is called a <firstterm>package</firstterm>.
         </para>
         <para>
            The <classname>CTCLPackagedObjectProcessor</classname> class
            described here provides a base class for such commands.  The base
            class provides mechanisms for the package to associate the object
            that contains the shared services with the command, and a mechanism
            for the subclass that actually implements real commands to access this
            associated object.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis>
                <methodname>CTCLPackagedObjectProcessor</methodname>
                <methodparam><type>CTCLInterpreter&amp;</type>
                             <parameter>interp</parameter>
                </methodparam>
                <methodparam><type>std::string</type>
                             <parameter>command</parameter>
                </methodparam>
                <methodparam><type>bool</type>
                             <parameter>registerMe</parameter>
                             <initializer>true</initializer>
                </methodparam>
            </methodsynopsis>
            <para>
                Construct the object.  The parameters are the same as for
                a <classname>CTCLObjectProcessor</classname>;
                <parameter>interp</parameter> is a reference to the TCL interpreter
                to which the command will be added.  <parameter>command</parameter>
                is the command keyword that will invoke the object's
                <methodname>operator()</methodname>.
                <parameter>regsiterMe</parameter> is
                <literal>true</literal> if the
                command should be registered on the interpreter immediately
                (this is usually the case and hence the parameter is optional,
                defaulting to <literal>true</literal>
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>onAttach</methodname>
                <methodparam>
                    <type>CTCLObjectPackage*</type> <parameter>package</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                This method is called by the package when the command object is
                added to the package.  <parameter>package</parameter> is a pointer
                to the package object, which contains its shared services.
                This is saved and can be retrieved by subclass objects via
                <methodname>getPackage</methodname>.
            </para>
            <methodsynopsis>
                <modifier>protected</modifier>
                <type>CTCLObjectPackage*</type>  <methodname>getPackage</methodname>
                <void />
            </methodsynopsis>
            <para>
                Returns the package object pointer supplied to
                <methodname>onAttach</methodname>
                by the package.  Normally this will need to be cast to a
                specific concrete package type by the caller so that its methods
                can be accessed.
            </para>
            <para>
                If called prior to the
                <methodname>onAttach</methodname> call, this returns
                a null pointer.
            </para>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>void</type> <methodname>Initialize</methodname>
                <void />
            </methodsynopsis>
            <para>
                Called by <methodname>onAttach</methodname> after the
                package has been saved (and is therefore accessible by
                <methodname>getPackage</methodname>.  This does nothing in the
                base class but can be overidden in subclasses to allow
                for initialization that requires access to the package services.
            </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
	 <para>
            <link linkend="manpage.CTCLObjectPackage">CTCLObjectPackage(3daq)</link>
	 </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.citemconfiguration">
      <refmeta>
         <refentrytitle>CItemConfiguration</refentrytitle>
         <manvolnum>3tcl</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CItemConfiguration</refname>
     <refpurpose>Hold a configuration</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CItemConfiguration.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CItemConfiguration</classname></ooclass>
            <constructorsynopsis>
                <methodname>CItemConfiguration</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CItemConfiguration</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>   <methodname>~CItemConfiguration</methodname>
                <void />
                </destructorsynopsis>
            <methodsynopsis>
                <type>CItemConfiguration&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CItemConfiguration&amp;</type> <parameter>rhs</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type>
                <methodname>getName</methodname>
                <void /><modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>cget</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>ConfigurationArray</type> <methodname>cget</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>getIntegerParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>unsigned int</type> <methodname>getUnsignedParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>bool</type>    <methodname>getBoolParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>double</type> <methodname>getFloatParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::vector&lt;int&gt;</type> <methodname>getIntegerList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addParameter</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>typeChecker</type> <parameter>checker</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>defaultValue</parameter>
                    <initializer>std::string("")</initializer>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>clearConfiguration</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>configure</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isInteger</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isBool</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isEnum</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isFloat</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier> <type>bool</type>
                <methodname>isBoolList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>bool</type> <methodname>isIntList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier> <type>bool</type>
                <methodname>isStringList</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type>  <parameter>value</parameter>
                    </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CItemConfiguration</classname> captures the configuration of an
            item.   A configuration is a set of name-value pairs.  
         </para>
         <para>
            While the values are all stored as strings, validators and type safe
            'getters' allow you to store strictly typed data as well.  A validator
            is a function that is called to ensure a proposed new value for a
            parameter is suitable for the parameter.    Validators are described
            in "Types and public data" below.  A rich set of pre-defined
            validators should meet most needs, however it is possible to write
            and use custom validators should the built in ones be insufficient for
            your application.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <methodsynopsis>
            <methodname>CItemConfiguration</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Constructs the configuration.  <parameter>name</parameter> is just
            any string you'd like to associate with the configuration.
            <methodname>getName</methodname> can be used to fetch the value
            of this string.  Names are used with collections of configurations
            when they may be inserted in an STL Map with the item name as the
            lookup key.
            </para>
        <methodsynopsis>
            <methodname>CItemConfiguration</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Copy construction.  Note that if your application causes copy
                construction several configurations with the same name can be
                be created.  If you want to ensure that copy construction can't
                exist, us a class derived from this in which the copy constructor
                is declared <firstterm>private</firstterm> but never implemented.
                </para>
        <methodsynopsis>
            <modifier>virtual</modifier>   <methodname>~CItemConfiguration</methodname>
            <void />
            </methodsynopsis>
        <para>
            Destructor.
            </para>
        <methodsynopsis>
            <type>CItemConfiguration&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CItemConfiguration&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Assignment operator.  Note that in the presence of named
            configuration items, this can result in objects with duplicate
            names.  To avoid this derive from this class and set
            the <literal>=</literal> operator to be private...without ever
            Implementing it.
            </para>
        <methodsynopsis>
            <type>int</type>
            <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Compares two objects for equality.  Equality is defined as having
            the same name, same set of configuration items with matching values.
            </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Inequality test operator is the logical inverse of equality.
            </para>
        <methodsynopsis>
            <type>std::string</type>
            <methodname>getName</methodname>
            <void /><modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the name string used to construct the object.
            </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>cget</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the string value of the configuration parameter
            <parameter>name</parameter>.  If the name is not a defined
            configuration parameter, this will throw an explanatory string exception.
            See <methodname>addParameter</methodname> for information about how
            to define configuration parameters.
            </para>
        <methodsynopsis>
            <type>ConfigurationArray</type> <methodname>cget</methodname>
            <void />
            </methodsynopsis>
        <para>
            Returns a container <type>ConfigurationArray</type> that provides
            the entire configuration.  See "Types and public data" for more
            information about the <type>ConfigurationArray</type>
            data type.
            </para>
        <methodsynopsis>
            <type>int</type> <methodname>getIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the value of a parameter <parameter>name</parameter> converted
            to an integer.  This can throw an explanatory string exception either
            if <parameter>name</parameter> is not a defined parameter or if its
            current value does not translate to an integer
            (using <function>strtoul</function>).  Typically <parameter>name</parameter>
            should have been defined with a validator that will make sure the
            value will always be a legal integer.
            </para>
        <methodsynopsis>
            <type>unsigned int</type> <methodname>getUnsignedParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Same as <methodname>getIntegerParameter</methodname> however
            <function>strtoul</function> is used to convert the string ot
            an unsigned value.  Once more the configuration parameter
            <parameter>name</parameter> should have a validator attached
            to it to ensure that the value always represents a legal
            unsigned integer.
            </para>
        <methodsynopsis>
            <type>bool</type>    <methodname>getBoolParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the value of <parameter>name</parameter> as a boolean.
            This will throw a descriptive string exception if <parameter>name</parameter>
            is not a define configuration parameter or if the value is not one of
            <literal>true</literal>,
            <literal>yes</literal>,
            <literal>1</literal>,
            <literal>on</literal>,
            or <literal>enabled</literal> for true and
            <literal>false</literal>,
            <literal>no</literal>,
            <literal>0</literal>,
            <literal>off</literal> or
            <literal>disabled</literal> for false.
            </para>
        <methodsynopsis>
            <type>double</type> <methodname>getFloatParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the value of a parameter <parameter>name</parameter>
            as a floating point <type>double</type>
            value.  If the parameter cannot be decoded as a floating point number
            a string exception is thrown that describes this.
            </para>

        <methodsynopsis>
            <type>std::vector&lt;int&gt;</type> <methodname>getIntegerList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns a parameter <parameter>name</parameter>
            that is supposed to be a list of integers.
            The list is returned as a <type>std::vector&lt;int&gt;</type>.
            A string exception is thrown describing the error in the event
            that either the parameter value is not a valid Tcl list or
            any of the values does not decode as an integer.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>addParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>typeChecker</type> <parameter>checker</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
                </methodparam>
            </methodsynopsis>
        <para>
            Defines a new configuration parameter.  The value of this configuration
            parameter is modified by calling <methodname>configure</methodname>
            below.  <parameter>name</parameter> is the name of the new parameter.
            This parameter definition is ovewritten if it already exists.
            </para>
        <para>
            <parameter>checker</parameter> is a validation function that will be
            called to approve or disapprove of changes to the configuration
            value. Passing a <literal>NULL</literal> for <parameter>checker</parameter>
            disables value checking.
            <parameter>arg</parameter> is a parameter passed to the type checker.
            See "Types and public data " below for a definition of the
            <type>typeChecker</type> function prototype.
            </para>
        <para>
            <parameter>default</parameter> is the initial value of the parameter.
            This defaults to the empty string.  Note that <parameter>default</parameter>
            is not passed through the <parameter>checker</parameter>, so it
            is up to the definer to ensure this value is a legal value for
            the functions used to fetch it from the parameter.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>clearConfiguration</methodname>
            <void />
            </methodsynopsis>
        <para>
            Destroys all parameter definitions.  After this is called,
            no configuration parameters are defined.
            </para> 
        <methodsynopsis>
            <type>void</type> <methodname>configure</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Modifies the value of the configuration parameter
            <parameter>name</parameter> to
            <parameter>value</parameter>.  If either the
            parameter <parameter>name</parameter> has not been defined, or
            <parameter>value</parameter> fails checking, a string
            exception is thrown to describe in human terms the problem.
            </para>

      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            This class exports several public data types.  For the sake of
            brevity only the final typename is give, therefore, when you
            use a type like <type>ConfigurationArray</type> remember that it
            must be qualified with the <classname>CItemConfiguration</classname>
            class name (e.g. referred to in your source code as
            <type>CItemConfiguration::ConfigurationArray</type>)
         </para>
         <para>
            One type is exported in the global (unqualified) namespace, this is
            <type>typeChecker</type> which defines the function prototype for
            a configuration parameter validity checker.  The prototype of
            this function is:
            </para>
         <methodsynopsis>
            <type>bool</type> <methodname>(*typeChecker)</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Type checkers are registered when a configuration parameter is
            created via <methodname>addParameter</methodname>.  When
            <methodname>configure</methodname> is called and the parameter
            has a type checker it is called.  <parameter>name</parameter> is the
            name of the configuration parameter being configured,
            <parameter>value</parameter> is the proposed new value for the
            parameter.
        </para>
        <para>
            <parameter>arg</parameter> is the <parameter>arg</parameter>
            parameter specified in the call to <methodname>addParameter</methodname>
            that created the configuration parameter in the first place.
            Usually this is some additional information required to validate the
            proposed value.
        </para>
        <para>
            The function must return <literal>true</literal> in the event
            the proposed <parameter>value</parameter> is acceptable and
            <type>false</type> if not.
            </para>
        <refsect2>
            <title>ConfigurationArray</title>
            <para>
                This type is defined as
                <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;</type>.
                This is a vector that contains pairs of strings.  The first string of
                each pair is the name of a configuration parameter.  The second
                string is the configuration parameter's current value.
                This type is returned from one of the overloaded <methodname>cget</methodname>
                methods.
                </para>
            <para>
                You cannot make any assumption about the order of the parameters
                in this array.
                </para>
            </refsect2>
        <refsect2>
            <title>Pre-defined type checkers and related data types</title>
            <para>
                This section describes type checkers that are defined as
                static member functions of the <classname>CItemConfiguration</classname>
                class.  Each type checker's <parameter>arg</parameter> is also
                described along with a description of the
                checker.
                </para>
            <para>
                Prior to writing your own type checker you should ensure that
                a suitable one does not already exist.
                </para>
            <para>
                For all of the type checkers the parameters have the same
                names an meanings:
                 </para>
                <variablelist>
                    <varlistentry>
                        <term><type>std::string</type> <parameter>name</parameter></term>
                        <listitem>
                            <para>
                                Name of the configuration parameter being checked.
                                </para>
                            </listitem>
                        </varlistentry>
                    <varlistentry>
                        <term><type>std::string</type> <parameter>value</parameter></term>
                        <listitem>
                            <para>
                                The proposed new value for the configuration
                                parameter.  This is the value to be checked
                                by the validation function.
                                </para>
                            </listitem>
                        </varlistentry>
                    <varlistentry>
                        <term><type>void*</type> <parameter>arg</parameter></term>
                        <listitem>
                            <para>
                                This anonymous pointer points to data that
                                is used to further qualify type checking.
                                For exmaple.  Integer type checkers can specify
                                optional limits on the range of integers that
                                are acceptable, for <methodname>isInteger</methodname>,
                                therefore <parameter>arg</parameter> is actually
                                a pointer to a data structure that specifies
                                limit information.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
               
            
            <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isInteger</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Ensures that <parameter>value</parameter> is a legal integer value.
            The <parameter>arg</parameter> parameter is a pointer to a
            <type>Limits</type> type.  This is a
            <type>std::pair&lt;limit, limit&gt;</type>.  Each <type>limit</type>
            defines a limit on the range of acceptable values.  The first one
            defines the lower end of the range, the second the high end of the
            range.
            </para>
        <para>
            If <parameter>arg</parameter> is <literal>NULL</literal> no
            limit checking is performed.
            </para>
        <para>
            The <type>limit</type> is, in turn a struct that has the following
            members:
            </para>
            <informalexample>
            <programlisting>
                bool s_checkMe;          // Check this limit if true
                long s_value             // Limit value
                </programlisting>
            </informalexample>
            <para>
                The <structname>limit</structname> structure also defines
                two construtors:
                <methodsynopsis>
                    <type></type><methodname>limit()</methodname>
                    <void />
                    </methodsynopsis>
                Defines a limit structure with <structfield>s_checkMe</structfield>
                initialized to
                <literal>false</literal> (that is a limit that will not be checked).
                <methodsynopsis>
                    <type></type><methodname>limit</methodname>
                    <methodparam>
                        <type>long</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                defines a limit with <structfield>s_checkMe</structfield> set
                to <literal>true</literal> and
                <structfield>s_value</structfield> initialized to
                <parameter>value</parameter>.
            </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isBool</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This type checker ensures that the proposed
            <parameter>value</parameter> is a legal boolean value.
            <methodname>isBool</methodname> does not use its
            <parameter>arg</parameter> parameter.  Legal boolean values
            are any text strings from the following set:
            <literal>{true, yes, 1, on, enabled, false, no, 0, off,  disabled}</literal>.
            Any string not in this set results in a failed type check.
            </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isEnum</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This is a type checker for enumerated parameters.  An enumerated
            parameter is a parameter that is constrained to have specific
            discrete values (A boolean is a special case of an enumerated
            parameter).  The <parameter>arg</parameter> value is required and
            must be a pointer to an
            <type>std::set&lt;string&gt;</type>.  The elements you put in this
            set define the allowed values for <parameter>value</parameter>.
            </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isFloat</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Checks that <parameter>value</parameter> decodes as a floating point
            number and optionally peforms limit checks on the value.
            </para>
        <para>
            <parameter>arg</parameter> is a pointer to a
            <type>FloatingLimits</type>.  <type>FloatingLimits</type> in turn
            is defined to be a <type>std::pair&lt;flimit, flimit&gt;</type>.
            The first <type>flimit</type> of the pair specifies the lower limit
            if any, while the second specifies the upper limit.  If
            <parameter>arg</parameter> is <literal>NULL</literal> no
            limit checking is performed.
            </para>
        <para>
            <type>flimit</type> is a struct that has the following
            members
            </para>

            <para>
                Data members of <structname>flimit</structname> are:
                <informalexample>
                <programlisting>
bool   s_checkMe;        // If true limit is checked.
float  s_value;          // Limit value.
                </programlisting>
                </informalexample>
                </para>
            <para>
                If <structfield>s_checkMe</structfield> is <literal>true</literal>,
                then <structfield>s_value</structfield> is relevant and is the value
                of the limit.
                </para>
            <para>
                <structfield>flimit</structfield> defines a pair of constructors:
                </para>
            <methodsynopsis>
                <type></type> <methodname>flimit</methodname>
                <void />
                </methodsynopsis>
            <para>Initializes <structfield>s_checkMe</structfield> to
            <literal>false</literal> disabling the limit.
            </para>
            <methodsynopsis>
                <type></type> <methodname>flimit</methodname>
                <methodparam>
                    <type>float</type> <parameter>value</parameter>
                    </methodparam>
                </methodsynopsis>
            <para>
                Initializes <structfield>s_checkMe</structfield>
                to <literal>true</literal> and sets
                <structfield>s_value</structfield>
                to <parameter>value</parameter>.  This enables the limit
                and sets it's value to <parameter>value</parameter>.
                </para>
 
    
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This validation function ensures tht the proposed parameter is a
            properly formatted Tcl list. <parameter>arg</parameter>, if supplied,
            allows the list size to be constrained and optionally
            elements of the list to be validated.  If <literal>NULL</literal>
            no constraints are enforced on the contents of the list.
            </para>
        <para>
            <parameter>arg</parameter> if not <literal>NULL</literal> is a pointer
            to a <structname>isListParameter</structname> struct which contains
            the following fields:
            <informalexample>
            <programlisting>
ListSizeConstraint  s_allowedSize;   // Constraints on list size.
TypeCheckInfo       s_checker;       // Element type checker.
                </programlisting>
            </informalexample>
            </para>
            <para>
                <structfield>s_allowedSize</structfield> constrains the number
                of elements in a list.  It is of type
                <structname>ListSizeConstraint</structname> which is a struct
                containing two <type>limit</type> element;
                <structfield>s_atLeast</structfield> which describes the minimum
                number of elements the list must contain and
                <structfield>s_atMost</structfield> which specifies the maximum
                numbger of elements the list must contain.  See
                the <methodname>isInteger</methodname> function description above
                for more information about the <type>limit</type> type.
                </para>
            <para>
                <structfield>s_checker</structfield>, of type
                <type>TypeCheckInfo</type> allows each element of the list to be
                validated (e.g. to require that a list contain integers that are
                all within some range).  
                <type>TypeCheckInfo</type> is a
                <type>std::pair&lt;typeChecker, void*&gt;</type>.  Where the
                <type>typeChecker</type> function is given each list value to
                validate and the <type>void*</type> element of the pair is the
                <parameter>arg</parameter> parameter passed to that validator.
                If <type>TypeCheckInfo</type> is <literal>NULL</literal> no per
                element validation is performed, however the list size can be
                constrained.
                </para>
            <para>
                When elements are validated, the <parameter>name</parameter>
                parameter passed to the element validator is the name of the
                configuration parameter that contains the list.  The
                <parameter>value</parameter> parameter is the proposed value
                of a list element.
                </para>
        <methodsynopsis>
            <modifier>static</modifier> <type>bool</type>
            <methodname>isBoolList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This is a specialization of <methodname>isList</methodname>.
            <parameter>arg</parameter> shoule be either be a pointer to
            a <type>ListSizeConstraint</type> to constrain the number of
            elements in the list or <literal>NULL</literal> to keep the size
            unsconstrained.  The method passes each list element through
            <methodname>isBool</methodname> to ensure that the
            list contains only boolean values.
            </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type> <methodname>isIntList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This is a specialization of the <methodname>isList</methodname>
            function.  <parameter>arg</parameter> should either be
            a pointer to a <type>ListSizeConstraint</type> or it should be a
            <literal>NULL</literal>.
            If <parameter>arg</parameter> is <literal>NULL</literal>,
            the size of the list is unconstrained.  If not, the
            <type>ListSizeConstraint</type> is used to validate the
            size of the list.
            </para>
        <para>
            The list items are checked via <methodname>isInteger</methodname>
            to be sure they are legal integers.  No capability to set limits on
            the integer values is provdided for at this time.
            </para>
        <methodsynopsis>
            <modifier>static</modifier> <type>bool</type>
            <methodname>isStringList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type>  <parameter>value</parameter>
                </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            This is a specialization of <methodname>isList</methodname>.  Any
            string is allowed as a list item (if it has the necessary quoting to maintain
            legal Tcl list syntax).   If not <literal>NULL</literal>,
            <parameter>arg</parameter> is a poitner to a
            <type>ListSizeConstraint</type> which can limit the number of elements
            in the list.  If <literal>NULL</literal> no list size constraint
            is enforced.
            </para>
        </refsect2>
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <para>
            In the event of error, the class thows exceptions of
            type <type>std::string</type>.  The contents of the string are a
            human readable message that explains the problem and when it was
            detected.
         </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend="manpage.cconfigurableobject">CConfigurableObject(3tcl)</link>
     </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.cconfigurableobject">
      <refmeta>
         <refentrytitle>CConfigurableObject</refentrytitle>
         <manvolnum>3tcl</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CConfigurableObject</refname>
     <refpurpose>Base class for objects tht have a configuration.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CConfigurableObject.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CConfigurableObject</classname></ooclass>
            <constructorsynopsis>
                <methodname>CConfigurableObject</methodname>
                <void />
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CConfigurableObject</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CConfigurableObject&amp;</type> <parameter>rhs</parameter>
                    </methodparam>
                </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CConfigurableObject</methodname>
                <void />
                </destructorsynopsis>
            <methodsynopsis>
                <type>CConfigurableObject&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CConfigurableObject&amp;</type> <parameter>rsh</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CConfigurableObject&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CConfigurableObject&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>Attach</methodname>
                <methodparam>
                    <type>CItemConfiguration*</type> <parameter>pConfiguration</parameter>
                    </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>dynamic</parameter>
                    <initializer>true</initializer>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>configure</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getName</methodname>
                <void />
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type>
                <methodname>cget</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>CItemConfiguration::ConfigurationArray</type>
                <methodname>cget</methodname>
                <void />
                </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>onAttach</methodname>
                <void /><modifier>=0</modifier>
                </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CConfigurableObject</classname> is an abstract base class
            for objects
            that contain configurations via the
            <classname>CItemConfiguration</classname>
            class.  The class embeds an <classname>CItemConfiguration</classname>
            and provides a mechanism for initializing the configuration as it is
            attached.
         </para>
        <para>
            Due to the rules regarding virtual member use in constructors,
            construction and initialization of a <classname>CConfigurableObject</classname>
            is usually a two step process.  The object is constructed, and then
            either an empty or initialized configuration is attached to the
            object via  call to <methodname>Attach</methodname>.
            </para>
        <para>
            When <methodname>Attach</methodname> is called it, in turn calls
            the virtual method (pure/abstract in this base class), to
            allow the actual concrete class to initialize the configuration
            by defining an appropriate set of parameters and their constraints.
            </para>
        <para>
            Once initialized, a partial facade is supplied that allows external
            clients to configure and dump the configuration of an object.
            </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <methodsynopsis>
            <methodname>CConfigurableObject</methodname>
            <void />
            </methodsynopsis>
        <para>
            Construts a configurable object.  Note that this does not
            create a configuration unless explicitly done by the constructor.
            Normally due to restrictions in when virtual functions are actually
            virtual (they are not in constructors), The client that constructs
            this will also construct and attach a
            <classname>CItemConfiguration</classname> via
            <methodname>Attach</methodname> soon after constructing the object.
            </para>
        <methodsynopsis>
            <methodname>CConfigurableObject</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CConfigurableObject&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Copy construction.  This results in a snapshot of the configuration
            being dynamically made, and marked for deletion on destruction of
            the object.  No attempt is made to synchronize the copy with the
            original.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <methodname>~CConfigurableObject</methodname>
            <void />
            </methodsynopsis>
        <para>
            Destroys the configurable object.  If the configuration attached
            was marked as dynamcially allocated it is deleted in order
            to prevent memory leaks.  Dynamic marking is done either
            by copy construction or by specifying at
            <methodname>Attach</methodname> time that the object is responsible
            for deleting <classname>ItemConfiguration</classname>
            object being attached.
            </para>
        <methodsynopsis>
            <type>CConfigurableObject&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CConfigurableObject&amp;</type> <parameter>rsh</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Object assignment.  If the target object's configuration exists
            and was dynamically attached, it is deleted.  Regardless, the source's
            configuration cloned and assigned to the current configuration with
            dynamic marking.
            </para>
        <methodsynopsis>
            <type>int</type> <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CConfigurableObject&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns nonzero if <parameter>rhs</parameter>'s configuration is
            identical to that of <parameter>this</parameter>.
            </para>
        <methodsynopsis>
            <type>int</type>
            <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CConfigurableObject&amp;</type>
                <parameter>rhs</parameter>
                </methodparam>
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns nonzero if <methodname>operator==</methodname> returns 0.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>Attach</methodname>
            <methodparam>
                <type>CItemConfiguration*</type> <parameter>pConfiguration</parameter>
                </methodparam>
            <methodparam>
                <type>bool</type> <parameter>dynamic</parameter>
                <initializer>true</initializer>
                </methodparam>
            </methodsynopsis>
        <para>
            The client should call this to attach a configuration,
            <parameter>pConfiguration</parameter>, (either
            pre-configured or empty) to the object.
            <parameter>dynamic</parameter> should be <literal>true</literal>
            if <parameter>pConfiguration</parameter> should be
            deleted when the object is destroyed.
            </para>
        <para>
            The virtual function <methodname>onAttach</methodname> will be invoked
            to allow the configuration to be set up for the object.
            </para>
        <methodsynopsis>
            <type>void</type> <methodname>configure</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Passes the <parameter>name</parameter> and <parameter>value</parameter>
            parameters on to the configuration object's
            <classname>CItemConfiguration</classname> object.  If no configuration
            has been attached to the object, a string exception is
            thrown describing this fact.
            </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>getName</methodname>
            <void />
            <modifier>const</modifier>
            </methodsynopsis>
        <para>
            Returns the configuration's name.  This will throw a string
            exception if no configuration has been attached to the object.
            </para>
        <methodsynopsis>
            <type>std::string</type>
            <methodname>cget</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
        <para>
            Returns the value of a configuration option <parameter>name</parameter>.
            The assumption is that clients only want to present configuration
            option values to humans, or save them and therefore ther is only
            a facade in front of the string value function.
            </para>
        <para>
            In addition to the string exceptions that can be thrown by the
            configuration object, an exception will be thrown if the
            object has no attached configuration.
            </para>
        <methodsynopsis>
            <type>CItemConfiguration::ConfigurationArray</type>
            <methodname>cget</methodname>
            <void />
            </methodsynopsis>
        <para>
            Returns the entire configuration. Throws a string exception if no
            configuration object has been attached.
            </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>void</type> <methodname>onAttach</methodname>
            <void /><modifier>=0</modifier>
            </methodsynopsis>
        <para>
            Concrete base classes should supply and implement this. Normally
            <methodname>onAttache</methodname> is used to initialize the
            configuration which is stored in the protected data member
            <varname>m_pConfiguration</varname>, a pointer to
            <classname>CItemConfiguration</classname>.
            </para>
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <para>
            <type>std::string</type> exceptions are thrown both from this and
            the calls it makes to <classname>CItemConfiguration</classname>.
         </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
     <para>
        <link linkend='manpage.citemconfiguration'>CItemConfiguration</link>
     </para>
      </refsect1>
   </refentry>


<!-- /manpage -->

<!-- manpage 1daq -->

<refentry id="manpage.evttclsh">
  <refmeta>
     <refentrytitle>evttclsh</refentrytitle>
     <manvolnum>1tcl</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>evttclsh</refname>
     <refpurpose>Tcl interpreter that always runs an event loop</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
evttclsh
	</command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
	A tclsh that is always running the event loop.
     </para>
  </refsect1>

</refentry>


<!-- /manpage -->

